{"mappings":"C,A,W,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,E,E,E,O,C,W,W,O,C,G,E,S,I,E,E,S,E,E,S,E,E,S,E,E,SCMA,IAAM,EAAW,CACf,KAAM,SAAS,aAAA,CAAc,SAC7B,YAAa,SAAS,aAAA,CAAc,0BACpC,WAAY,SAAS,aAAA,CAAc,sBACnC,WAAY,SAAS,aAAA,CAAc,sBACnC,QAAS,SAAS,aAAA,CAAc,aAChC,WAAY,SAAS,aAAA,CAAc,YACrC,EAmBA,eAAe,EAAgB,CAAc,EAC3C,GAAI,CACF,IAAM,EAAO,MAAM,AAAA,CAAA,EAAA,EAAA,WAAU,AAAV,IACb,EAAY,EAAK,OAAvB,CACA,OAAO,AAMX,SAA+B,CAAS,CAAE,CAAc,EACtD,IAAI,EAAkB,EAAE,CACxB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAgB,IAAK,CACvC,IAAI,EAAc,KAAK,KAAA,CAAM,KAAK,MAAA,GAAW,EAAU,MAAvD,EACA,EAAgB,IAAA,CAAK,EAAU,MAAA,CAAO,EAAa,EAAE,CAAC,EAAE,CAC1D,CACA,OAAO,CACT,EAbiC,EAAW,EAC1C,CAAE,MAAO,EAAO,CACd,AAAA,CAAA,EAAA,EAAA,MAAK,AAAL,EAAO,OAAA,CAAQ,gDACjB,CACF,CAzBA,AAEA,CAAA,iBACE,GAAI,OAAO,QAAA,CAAS,IAAA,CAAK,QAAA,CAAS,qBAAsB,CACtD,EAAS,UAAA,CAAW,SAAA,CAAU,GAAA,CAAI,YAClC,EAAS,OAAA,CAAQ,KAAA,CAAM,OAAA,CAAU,OACjC,MACF,CACA,GAAI,CACF,IAAM,EAAW,MAAM,EAAgB,GACvC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","sources":["<anon>","src/js/hero.js","src/js/swiper.js","node_modules/swiper/swiper-bundle.js","src/js/heroUi.js","src/js/trailer-modal.js","src/js/api.js","src/js/loader.js","node_modules/notiflix/build/notiflix-loading-aio.js"],"sourcesContent":["(function () {\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequired7c6\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequired7c6\"] = parcelRequire;\n}\nparcelRequire.register(\"gVa74\", function(module, exports) {\n\n$parcel$export(module.exports, \"heroRefs\", function () { return $c519d076f6352209$export$4ab48b83441cb96c; });\n\nvar $RX4Re = parcelRequire(\"RX4Re\");\n\nvar $758Z4 = parcelRequire(\"758Z4\");\n\nvar $cxvFw = parcelRequire(\"cxvFw\");\n\nvar $b7ONl = parcelRequire(\"b7ONl\");\n\nvar $6JpON = parcelRequire(\"6JpON\");\nconst $c519d076f6352209$export$4ab48b83441cb96c = {\n    hero: document.querySelector(\".hero\"),\n    backDropRef: document.querySelector(\".hero-trailer-backdrop\"),\n    trailerRef: document.querySelector(\".trailer-container\"),\n    trailerBtn: document.querySelector(\".modal-trailer-btn\"),\n    heroBtn: document.querySelector(\".hero-btn\"),\n    heroImgRef: document.querySelector(\".hero-img\")\n};\n$c519d076f6352209$var$heroHandler();\nasync function $c519d076f6352209$var$heroHandler() {\n    if (window.location.href.includes(\"/my-lib-page.html\")) {\n        $c519d076f6352209$export$4ab48b83441cb96c.heroImgRef.classList.add(\"hero-lib\");\n        $c519d076f6352209$export$4ab48b83441cb96c.heroBtn.style.display = \"none\";\n        return;\n    }\n    try {\n        const movieArr = await $c519d076f6352209$var$getTopMoviesArr(1);\n        if (movieArr.length === 0) return;\n        (0, $758Z4.renderHeroSlider)(movieArr);\n    } catch (error) {\n        $c519d076f6352209$export$4ab48b83441cb96c.heroImgRef.classList.add(\"hero-main\");\n    }\n}\nasync function $c519d076f6352209$var$getTopMoviesArr(numberOfMovies) {\n    try {\n        const data = await (0, $b7ONl.getTrending)();\n        const moviesArr = data.results;\n        return $c519d076f6352209$var$createRandomMoviesArr(moviesArr, numberOfMovies);\n    } catch (error) {\n        (0, $6JpON.Notify).warning(\"OOPS... Something go wrong, please try again.\");\n    }\n}\nfunction $c519d076f6352209$var$createRandomMoviesArr(moviesArr, numberOfMovies) {\n    let randomMoviesArr = [];\n    for(let i = 0; i < numberOfMovies; i++){\n        let randomIndex = Math.floor(Math.random() * moviesArr.length);\n        randomMoviesArr.push(moviesArr.splice(randomIndex, 1)[0]);\n    }\n    return randomMoviesArr;\n}\ndocument.addEventListener(\"click\", (0, $cxvFw.onWatchTrailer));\n\n});\nparcelRequire.register(\"RX4Re\", function(module, exports) {\n\n$parcel$export(module.exports, \"swiperInit\", function () { return $0a22c6e20035bdaf$export$858f609fb9acf511; });\n$parcel$export(module.exports, \"renderSwiper\", function () { return $0a22c6e20035bdaf$export$dfd6410bdb174d21; });\n\nvar $e6cIt = parcelRequire(\"e6cIt\");\n\n\nvar $gVa74 = parcelRequire(\"gVa74\");\nlet $0a22c6e20035bdaf$export$34cb4889b4dd2cb1 = null;\nfunction $0a22c6e20035bdaf$export$858f609fb9acf511() {\n    $0a22c6e20035bdaf$export$34cb4889b4dd2cb1 = new (0, (/*@__PURE__*/$parcel$interopDefault($e6cIt)))(\".swiper\", {\n        direction: \"horizontal\",\n        loop: true,\n        speed: 2000,\n        parallax: true,\n        spaceBetween: 0,\n        autoplay: {\n            delay: 5000,\n            disableOnInteraction: false\n        }\n    });\n}\nfunction $0a22c6e20035bdaf$export$dfd6410bdb174d21() {\n    const markup = `<div class=\"swiper container\">\n  <div class=\"swiper-wrapper\"></div>`;\n    (0, $gVa74.heroRefs).hero.innerHTML = markup;\n}\n\n});\nparcelRequire.register(\"e6cIt\", function(module, exports) {\n/**\n * Swiper 10.1.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: August 1, 2023\n */ var $a43b7d65e6bbcaac$var$Swiper = function() {\n    \"use strict\";\n    /**\n   * SSR Window 4.0.2\n   * Better handling for window object in SSR environment\n   * https://github.com/nolimits4web/ssr-window\n   *\n   * Copyright 2021, Vladimir Kharlampidi\n   *\n   * Licensed under MIT\n   *\n   * Released on: December 13, 2021\n   */ /* eslint-disable no-param-reassign */ function isObject$1(obj) {\n        return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n    }\n    function extend$1(target, src) {\n        if (target === void 0) target = {};\n        if (src === void 0) src = {};\n        Object.keys(src).forEach((key)=>{\n            if (typeof target[key] === \"undefined\") target[key] = src[key];\n            else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) extend$1(target[key], src[key]);\n        });\n    }\n    const ssrDocument = {\n        body: {},\n        addEventListener () {},\n        removeEventListener () {},\n        activeElement: {\n            blur () {},\n            nodeName: \"\"\n        },\n        querySelector () {\n            return null;\n        },\n        querySelectorAll () {\n            return [];\n        },\n        getElementById () {\n            return null;\n        },\n        createEvent () {\n            return {\n                initEvent () {}\n            };\n        },\n        createElement () {\n            return {\n                children: [],\n                childNodes: [],\n                style: {},\n                setAttribute () {},\n                getElementsByTagName () {\n                    return [];\n                }\n            };\n        },\n        createElementNS () {\n            return {};\n        },\n        importNode () {\n            return null;\n        },\n        location: {\n            hash: \"\",\n            host: \"\",\n            hostname: \"\",\n            href: \"\",\n            origin: \"\",\n            pathname: \"\",\n            protocol: \"\",\n            search: \"\"\n        }\n    };\n    function getDocument() {\n        const doc = typeof document !== \"undefined\" ? document : {};\n        extend$1(doc, ssrDocument);\n        return doc;\n    }\n    const ssrWindow = {\n        document: ssrDocument,\n        navigator: {\n            userAgent: \"\"\n        },\n        location: {\n            hash: \"\",\n            host: \"\",\n            hostname: \"\",\n            href: \"\",\n            origin: \"\",\n            pathname: \"\",\n            protocol: \"\",\n            search: \"\"\n        },\n        history: {\n            replaceState () {},\n            pushState () {},\n            go () {},\n            back () {}\n        },\n        CustomEvent: function CustomEvent() {\n            return this;\n        },\n        addEventListener () {},\n        removeEventListener () {},\n        getComputedStyle () {\n            return {\n                getPropertyValue () {\n                    return \"\";\n                }\n            };\n        },\n        Image () {},\n        Date () {},\n        screen: {},\n        setTimeout () {},\n        clearTimeout () {},\n        matchMedia () {\n            return {};\n        },\n        requestAnimationFrame (callback) {\n            if (typeof setTimeout === \"undefined\") {\n                callback();\n                return null;\n            }\n            return setTimeout(callback, 0);\n        },\n        cancelAnimationFrame (id) {\n            if (typeof setTimeout === \"undefined\") return;\n            clearTimeout(id);\n        }\n    };\n    function getWindow() {\n        const win = typeof window !== \"undefined\" ? window : {};\n        extend$1(win, ssrWindow);\n        return win;\n    }\n    function deleteProps(obj) {\n        const object = obj;\n        Object.keys(object).forEach((key)=>{\n            try {\n                object[key] = null;\n            } catch (e) {\n            // no getter for object\n            }\n            try {\n                delete object[key];\n            } catch (e) {\n            // something got wrong\n            }\n        });\n    }\n    function nextTick(callback, delay) {\n        if (delay === void 0) delay = 0;\n        return setTimeout(callback, delay);\n    }\n    function now() {\n        return Date.now();\n    }\n    function getComputedStyle$1(el) {\n        const window1 = getWindow();\n        let style;\n        if (window1.getComputedStyle) style = window1.getComputedStyle(el, null);\n        if (!style && el.currentStyle) style = el.currentStyle;\n        if (!style) style = el.style;\n        return style;\n    }\n    function getTranslate(el, axis) {\n        if (axis === void 0) axis = \"x\";\n        const window1 = getWindow();\n        let matrix;\n        let curTransform;\n        let transformMatrix;\n        const curStyle = getComputedStyle$1(el);\n        if (window1.WebKitCSSMatrix) {\n            curTransform = curStyle.transform || curStyle.webkitTransform;\n            if (curTransform.split(\",\").length > 6) curTransform = curTransform.split(\", \").map((a)=>a.replace(\",\", \".\")).join(\", \");\n            // Some old versions of Webkit choke when 'none' is passed; pass\n            // empty string instead in this case\n            transformMatrix = new window1.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n        } else {\n            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n            matrix = transformMatrix.toString().split(\",\");\n        }\n        if (axis === \"x\") {\n            // Latest Chrome and webkits Fix\n            if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n            else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n            else curTransform = parseFloat(matrix[4]);\n        }\n        if (axis === \"y\") {\n            // Latest Chrome and webkits Fix\n            if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n            else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n            else curTransform = parseFloat(matrix[5]);\n        }\n        return curTransform || 0;\n    }\n    function isObject(o) {\n        return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n    }\n    function isNode(node) {\n        // eslint-disable-next-line\n        if (typeof window !== \"undefined\" && typeof window.HTMLElement !== \"undefined\") return node instanceof HTMLElement;\n        return node && (node.nodeType === 1 || node.nodeType === 11);\n    }\n    function extend() {\n        const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n        const noExtend = [\n            \"__proto__\",\n            \"constructor\",\n            \"prototype\"\n        ];\n        for(let i = 1; i < arguments.length; i += 1){\n            const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n            if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n                const keysArray = Object.keys(Object(nextSource)).filter((key)=>noExtend.indexOf(key) < 0);\n                for(let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){\n                    const nextKey = keysArray[nextIndex];\n                    const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                    if (desc !== undefined && desc.enumerable) {\n                        if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey];\n                            else extend(to[nextKey], nextSource[nextKey]);\n                        } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                            to[nextKey] = {};\n                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey];\n                            else extend(to[nextKey], nextSource[nextKey]);\n                        } else to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n        return to;\n    }\n    function setCSSProperty(el, varName, varValue) {\n        el.style.setProperty(varName, varValue);\n    }\n    function animateCSSModeScroll(_ref) {\n        let { swiper: swiper, targetPosition: targetPosition, side: side } = _ref;\n        const window1 = getWindow();\n        const startPosition = -swiper.translate;\n        let startTime = null;\n        let time;\n        const duration = swiper.params.speed;\n        swiper.wrapperEl.style.scrollSnapType = \"none\";\n        window1.cancelAnimationFrame(swiper.cssModeFrameID);\n        const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n        const isOutOfBound = (current, target)=>{\n            return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n        };\n        const animate = ()=>{\n            time = new Date().getTime();\n            if (startTime === null) startTime = time;\n            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n            const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n            if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;\n            swiper.wrapperEl.scrollTo({\n                [side]: currentPosition\n            });\n            if (isOutOfBound(currentPosition, targetPosition)) {\n                swiper.wrapperEl.style.overflow = \"hidden\";\n                swiper.wrapperEl.style.scrollSnapType = \"\";\n                setTimeout(()=>{\n                    swiper.wrapperEl.style.overflow = \"\";\n                    swiper.wrapperEl.scrollTo({\n                        [side]: currentPosition\n                    });\n                });\n                window1.cancelAnimationFrame(swiper.cssModeFrameID);\n                return;\n            }\n            swiper.cssModeFrameID = window1.requestAnimationFrame(animate);\n        };\n        animate();\n    }\n    function getSlideTransformEl(slideEl) {\n        return slideEl.querySelector(\".swiper-slide-transform\") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(\".swiper-slide-transform\") || slideEl;\n    }\n    function elementChildren(element, selector) {\n        if (selector === void 0) selector = \"\";\n        return [\n            ...element.children\n        ].filter((el)=>el.matches(selector));\n    }\n    function createElement(tag, classes) {\n        if (classes === void 0) classes = [];\n        const el = document.createElement(tag);\n        el.classList.add(...Array.isArray(classes) ? classes : [\n            classes\n        ]);\n        return el;\n    }\n    function elementOffset(el) {\n        const window1 = getWindow();\n        const document1 = getDocument();\n        const box = el.getBoundingClientRect();\n        const body = document1.body;\n        const clientTop = el.clientTop || body.clientTop || 0;\n        const clientLeft = el.clientLeft || body.clientLeft || 0;\n        const scrollTop = el === window1 ? window1.scrollY : el.scrollTop;\n        const scrollLeft = el === window1 ? window1.scrollX : el.scrollLeft;\n        return {\n            top: box.top + scrollTop - clientTop,\n            left: box.left + scrollLeft - clientLeft\n        };\n    }\n    function elementPrevAll(el, selector) {\n        const prevEls = [];\n        while(el.previousElementSibling){\n            const prev = el.previousElementSibling; // eslint-disable-line\n            if (selector) {\n                if (prev.matches(selector)) prevEls.push(prev);\n            } else prevEls.push(prev);\n            el = prev;\n        }\n        return prevEls;\n    }\n    function elementNextAll(el, selector) {\n        const nextEls = [];\n        while(el.nextElementSibling){\n            const next = el.nextElementSibling; // eslint-disable-line\n            if (selector) {\n                if (next.matches(selector)) nextEls.push(next);\n            } else nextEls.push(next);\n            el = next;\n        }\n        return nextEls;\n    }\n    function elementStyle(el, prop) {\n        const window1 = getWindow();\n        return window1.getComputedStyle(el, null).getPropertyValue(prop);\n    }\n    function elementIndex(el) {\n        let child = el;\n        let i;\n        if (child) {\n            i = 0;\n            // eslint-disable-next-line\n            while((child = child.previousSibling) !== null)if (child.nodeType === 1) i += 1;\n            return i;\n        }\n        return undefined;\n    }\n    function elementParents(el, selector) {\n        const parents = []; // eslint-disable-line\n        let parent = el.parentElement; // eslint-disable-line\n        while(parent){\n            if (selector) {\n                if (parent.matches(selector)) parents.push(parent);\n            } else parents.push(parent);\n            parent = parent.parentElement;\n        }\n        return parents;\n    }\n    function elementTransitionEnd(el, callback) {\n        function fireCallBack(e) {\n            if (e.target !== el) return;\n            callback.call(el, e);\n            el.removeEventListener(\"transitionend\", fireCallBack);\n        }\n        if (callback) el.addEventListener(\"transitionend\", fireCallBack);\n    }\n    function elementOuterSize(el, size, includeMargins) {\n        const window1 = getWindow();\n        if (includeMargins) return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n        return el.offsetWidth;\n    }\n    let support;\n    function calcSupport() {\n        const window1 = getWindow();\n        const document1 = getDocument();\n        return {\n            smoothScroll: document1.documentElement && document1.documentElement.style && \"scrollBehavior\" in document1.documentElement.style,\n            touch: !!(\"ontouchstart\" in window1 || window1.DocumentTouch && document1 instanceof window1.DocumentTouch)\n        };\n    }\n    function getSupport() {\n        if (!support) support = calcSupport();\n        return support;\n    }\n    let deviceCached;\n    function calcDevice(_temp) {\n        let { userAgent: userAgent } = _temp === void 0 ? {} : _temp;\n        const support = getSupport();\n        const window1 = getWindow();\n        const platform = window1.navigator.platform;\n        const ua = userAgent || window1.navigator.userAgent;\n        const device = {\n            ios: false,\n            android: false\n        };\n        const screenWidth = window1.screen.width;\n        const screenHeight = window1.screen.height;\n        const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n        let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n        const windows = platform === \"Win32\";\n        let macos = platform === \"MacIntel\";\n        // iPadOs 13 fix\n        const iPadScreens = [\n            \"1024x1366\",\n            \"1366x1024\",\n            \"834x1194\",\n            \"1194x834\",\n            \"834x1112\",\n            \"1112x834\",\n            \"768x1024\",\n            \"1024x768\",\n            \"820x1180\",\n            \"1180x820\",\n            \"810x1080\",\n            \"1080x810\"\n        ];\n        if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n            ipad = ua.match(/(Version)\\/([\\d.]+)/);\n            if (!ipad) ipad = [\n                0,\n                1,\n                \"13_0_0\"\n            ];\n            macos = false;\n        }\n        // Android\n        if (android && !windows) {\n            device.os = \"android\";\n            device.android = true;\n        }\n        if (ipad || iphone || ipod) {\n            device.os = \"ios\";\n            device.ios = true;\n        }\n        // Export object\n        return device;\n    }\n    function getDevice(overrides) {\n        if (overrides === void 0) overrides = {};\n        if (!deviceCached) deviceCached = calcDevice(overrides);\n        return deviceCached;\n    }\n    let browser;\n    function calcBrowser() {\n        const window1 = getWindow();\n        let needPerspectiveFix = false;\n        function isSafari() {\n            const ua = window1.navigator.userAgent.toLowerCase();\n            return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n        }\n        if (isSafari()) {\n            const ua = String(window1.navigator.userAgent);\n            if (ua.includes(\"Version/\")) {\n                const [major, minor] = ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((num)=>Number(num));\n                needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n            }\n        }\n        return {\n            isSafari: needPerspectiveFix || isSafari(),\n            needPerspectiveFix: needPerspectiveFix,\n            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window1.navigator.userAgent)\n        };\n    }\n    function getBrowser() {\n        if (!browser) browser = calcBrowser();\n        return browser;\n    }\n    function Resize(_ref) {\n        let { swiper: swiper, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        let observer = null;\n        let animationFrame = null;\n        const resizeHandler = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit(\"beforeResize\");\n            emit(\"resize\");\n        };\n        const createObserver = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            observer = new ResizeObserver((entries)=>{\n                animationFrame = window1.requestAnimationFrame(()=>{\n                    const { width: width, height: height } = swiper;\n                    let newWidth = width;\n                    let newHeight = height;\n                    entries.forEach((_ref2)=>{\n                        let { contentBoxSize: contentBoxSize, contentRect: contentRect, target: target } = _ref2;\n                        if (target && target !== swiper.el) return;\n                        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n                        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n                    });\n                    if (newWidth !== width || newHeight !== height) resizeHandler();\n                });\n            });\n            observer.observe(swiper.el);\n        };\n        const removeObserver = ()=>{\n            if (animationFrame) window1.cancelAnimationFrame(animationFrame);\n            if (observer && observer.unobserve && swiper.el) {\n                observer.unobserve(swiper.el);\n                observer = null;\n            }\n        };\n        const orientationChangeHandler = ()=>{\n            if (!swiper || swiper.destroyed || !swiper.initialized) return;\n            emit(\"orientationchange\");\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.resizeObserver && typeof window1.ResizeObserver !== \"undefined\") {\n                createObserver();\n                return;\n            }\n            window1.addEventListener(\"resize\", resizeHandler);\n            window1.addEventListener(\"orientationchange\", orientationChangeHandler);\n        });\n        on(\"destroy\", ()=>{\n            removeObserver();\n            window1.removeEventListener(\"resize\", resizeHandler);\n            window1.removeEventListener(\"orientationchange\", orientationChangeHandler);\n        });\n    }\n    function Observer(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const observers = [];\n        const window1 = getWindow();\n        const attach = function(target, options) {\n            if (options === void 0) options = {};\n            const ObserverFunc = window1.MutationObserver || window1.WebkitMutationObserver;\n            const observer = new ObserverFunc((mutations)=>{\n                // The observerUpdate event should only be triggered\n                // once despite the number of mutations.  Additional\n                // triggers are redundant and are very costly\n                if (swiper.__preventObserver__) return;\n                if (mutations.length === 1) {\n                    emit(\"observerUpdate\", mutations[0]);\n                    return;\n                }\n                const observerUpdate = function observerUpdate() {\n                    emit(\"observerUpdate\", mutations[0]);\n                };\n                if (window1.requestAnimationFrame) window1.requestAnimationFrame(observerUpdate);\n                else window1.setTimeout(observerUpdate, 0);\n            });\n            observer.observe(target, {\n                attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n                childList: typeof options.childList === \"undefined\" ? true : options.childList,\n                characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n            });\n            observers.push(observer);\n        };\n        const init = ()=>{\n            if (!swiper.params.observer) return;\n            if (swiper.params.observeParents) {\n                const containerParents = elementParents(swiper.hostEl);\n                for(let i = 0; i < containerParents.length; i += 1)attach(containerParents[i]);\n            }\n            // Observe container\n            attach(swiper.hostEl, {\n                childList: swiper.params.observeSlideChildren\n            });\n            // Observe wrapper\n            attach(swiper.wrapperEl, {\n                attributes: false\n            });\n        };\n        const destroy = ()=>{\n            observers.forEach((observer)=>{\n                observer.disconnect();\n            });\n            observers.splice(0, observers.length);\n        };\n        extendParams({\n            observer: false,\n            observeParents: false,\n            observeSlideChildren: false\n        });\n        on(\"init\", init);\n        on(\"destroy\", destroy);\n    }\n    /* eslint-disable no-underscore-dangle */ var eventsEmitter = {\n        on (events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            const method = priority ? \"unshift\" : \"push\";\n            events.split(\" \").forEach((event1)=>{\n                if (!self.eventsListeners[event1]) self.eventsListeners[event1] = [];\n                self.eventsListeners[event1][method](handler);\n            });\n            return self;\n        },\n        once (events, handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            function onceHandler() {\n                self.off(events, onceHandler);\n                if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];\n                handler.apply(self, args);\n            }\n            onceHandler.__emitterProxy = handler;\n            return self.on(events, onceHandler, priority);\n        },\n        onAny (handler, priority) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (typeof handler !== \"function\") return self;\n            const method = priority ? \"unshift\" : \"push\";\n            if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);\n            return self;\n        },\n        offAny (handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsAnyListeners) return self;\n            const index = self.eventsAnyListeners.indexOf(handler);\n            if (index >= 0) self.eventsAnyListeners.splice(index, 1);\n            return self;\n        },\n        off (events, handler) {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            events.split(\" \").forEach((event1)=>{\n                if (typeof handler === \"undefined\") self.eventsListeners[event1] = [];\n                else if (self.eventsListeners[event1]) self.eventsListeners[event1].forEach((eventHandler, index)=>{\n                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event1].splice(index, 1);\n                });\n            });\n            return self;\n        },\n        emit () {\n            const self = this;\n            if (!self.eventsListeners || self.destroyed) return self;\n            if (!self.eventsListeners) return self;\n            let events;\n            let data;\n            let context;\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];\n            if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n                events = args[0];\n                data = args.slice(1, args.length);\n                context = self;\n            } else {\n                events = args[0].events;\n                data = args[0].data;\n                context = args[0].context || self;\n            }\n            data.unshift(context);\n            const eventsArray = Array.isArray(events) ? events : events.split(\" \");\n            eventsArray.forEach((event1)=>{\n                if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler)=>{\n                    eventHandler.apply(context, [\n                        event1,\n                        ...data\n                    ]);\n                });\n                if (self.eventsListeners && self.eventsListeners[event1]) self.eventsListeners[event1].forEach((eventHandler)=>{\n                    eventHandler.apply(context, data);\n                });\n            });\n            return self;\n        }\n    };\n    function updateSize() {\n        const swiper = this;\n        let width;\n        let height;\n        const el = swiper.el;\n        if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) width = swiper.params.width;\n        else width = el.clientWidth;\n        if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) height = swiper.params.height;\n        else height = el.clientHeight;\n        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;\n        // Subtract paddings\n        width = width - parseInt(elementStyle(el, \"padding-left\") || 0, 10) - parseInt(elementStyle(el, \"padding-right\") || 0, 10);\n        height = height - parseInt(elementStyle(el, \"padding-top\") || 0, 10) - parseInt(elementStyle(el, \"padding-bottom\") || 0, 10);\n        if (Number.isNaN(width)) width = 0;\n        if (Number.isNaN(height)) height = 0;\n        Object.assign(swiper, {\n            width: width,\n            height: height,\n            size: swiper.isHorizontal() ? width : height\n        });\n    }\n    function updateSlides() {\n        const swiper = this;\n        function getDirectionLabel(property) {\n            if (swiper.isHorizontal()) return property;\n            // prettier-ignore\n            return ({\n                \"width\": \"height\",\n                \"margin-top\": \"margin-left\",\n                \"margin-bottom \": \"margin-right\",\n                \"margin-left\": \"margin-top\",\n                \"margin-right\": \"margin-bottom\",\n                \"padding-left\": \"padding-top\",\n                \"padding-right\": \"padding-bottom\",\n                \"marginRight\": \"marginBottom\"\n            })[property];\n        }\n        function getDirectionPropertyValue(node, label) {\n            return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n        }\n        const params = swiper.params;\n        const { wrapperEl: wrapperEl, slidesEl: slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL: wrongRTL } = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n        const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n        let snapGrid = [];\n        const slidesGrid = [];\n        const slidesSizesGrid = [];\n        let offsetBefore = params.slidesOffsetBefore;\n        if (typeof offsetBefore === \"function\") offsetBefore = params.slidesOffsetBefore.call(swiper);\n        let offsetAfter = params.slidesOffsetAfter;\n        if (typeof offsetAfter === \"function\") offsetAfter = params.slidesOffsetAfter.call(swiper);\n        const previousSnapGridLength = swiper.snapGrid.length;\n        const previousSlidesGridLength = swiper.slidesGrid.length;\n        let spaceBetween = params.spaceBetween;\n        let slidePosition = -offsetBefore;\n        let prevSlideSize = 0;\n        let index = 0;\n        if (typeof swiperSize === \"undefined\") return;\n        if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n        else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n        swiper.virtualSize = -spaceBetween;\n        // reset margins\n        slides.forEach((slideEl)=>{\n            if (rtl) slideEl.style.marginLeft = \"\";\n            else slideEl.style.marginRight = \"\";\n            slideEl.style.marginBottom = \"\";\n            slideEl.style.marginTop = \"\";\n        });\n        // reset cssMode offsets\n        if (params.centeredSlides && params.cssMode) {\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n        }\n        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n        if (gridEnabled) swiper.grid.initSlides(slidesLength);\n        // Calc slides\n        let slideSize;\n        const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key)=>{\n            return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n        }).length > 0;\n        for(let i = 0; i < slidesLength; i += 1){\n            slideSize = 0;\n            let slide;\n            if (slides[i]) slide = slides[i];\n            if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n            if (slides[i] && elementStyle(slide, \"display\") === \"none\") continue; // eslint-disable-line\n            if (params.slidesPerView === \"auto\") {\n                if (shouldResetSlideSize) slides[i].style[getDirectionLabel(\"width\")] = ``;\n                const slideStyles = getComputedStyle(slide);\n                const currentTransform = slide.style.transform;\n                const currentWebKitTransform = slide.style.webkitTransform;\n                if (currentTransform) slide.style.transform = \"none\";\n                if (currentWebKitTransform) slide.style.webkitTransform = \"none\";\n                if (params.roundLengths) slideSize = swiper.isHorizontal() ? elementOuterSize(slide, \"width\", true) : elementOuterSize(slide, \"height\", true);\n                else {\n                    // eslint-disable-next-line\n                    const width = getDirectionPropertyValue(slideStyles, \"width\");\n                    const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n                    const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n                    const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n                    const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n                    const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n                    if (boxSizing && boxSizing === \"border-box\") slideSize = width + marginLeft + marginRight;\n                    else {\n                        const { clientWidth: clientWidth, offsetWidth: offsetWidth } = slide;\n                        slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n                    }\n                }\n                if (currentTransform) slide.style.transform = currentTransform;\n                if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n            } else {\n                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n                if (params.roundLengths) slideSize = Math.floor(slideSize);\n                if (slides[i]) slides[i].style[getDirectionLabel(\"width\")] = `${slideSize}px`;\n            }\n            if (slides[i]) slides[i].swiperSlideSize = slideSize;\n            slidesSizesGrid.push(slideSize);\n            if (params.centeredSlides) {\n                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n                if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n                if (Math.abs(slidePosition) < 0.001) slidePosition = 0;\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n            } else {\n                if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n                if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n                slidesGrid.push(slidePosition);\n                slidePosition = slidePosition + slideSize + spaceBetween;\n            }\n            swiper.virtualSize += slideSize + spaceBetween;\n            prevSlideSize = slideSize;\n            index += 1;\n        }\n        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n        if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n        if (params.setWrapperSize) wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n        if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n        // Remove last grid elements depending on width\n        if (!params.centeredSlides) {\n            const newSlidesGrid = [];\n            for(let i = 0; i < snapGrid.length; i += 1){\n                let slidesGridItem = snapGrid[i];\n                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);\n            }\n            snapGrid = newSlidesGrid;\n            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n        if (isVirtual && params.loop) {\n            const size = slidesSizesGrid[0] + spaceBetween;\n            if (params.slidesPerGroup > 1) {\n                const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n                const groupSize = size * params.slidesPerGroup;\n                for(let i = 0; i < groups; i += 1)snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n            }\n            for(let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1){\n                if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n                slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n                swiper.virtualSize += size;\n            }\n        }\n        if (snapGrid.length === 0) snapGrid = [\n            0\n        ];\n        if (spaceBetween !== 0) {\n            const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : getDirectionLabel(\"marginRight\");\n            slides.filter((_, slideIndex)=>{\n                if (!params.cssMode || params.loop) return true;\n                if (slideIndex === slides.length - 1) return false;\n                return true;\n            }).forEach((slideEl)=>{\n                slideEl.style[key] = `${spaceBetween}px`;\n            });\n        }\n        if (params.centeredSlides && params.centeredSlidesBounds) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach((slideSizeValue)=>{\n                allSlidesSize += slideSizeValue + (spaceBetween || 0);\n            });\n            allSlidesSize -= spaceBetween;\n            const maxSnap = allSlidesSize - swiperSize;\n            snapGrid = snapGrid.map((snap)=>{\n                if (snap <= 0) return -offsetBefore;\n                if (snap > maxSnap) return maxSnap + offsetAfter;\n                return snap;\n            });\n        }\n        if (params.centerInsufficientSlides) {\n            let allSlidesSize = 0;\n            slidesSizesGrid.forEach((slideSizeValue)=>{\n                allSlidesSize += slideSizeValue + (spaceBetween || 0);\n            });\n            allSlidesSize -= spaceBetween;\n            if (allSlidesSize < swiperSize) {\n                const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n                snapGrid.forEach((snap, snapIndex)=>{\n                    snapGrid[snapIndex] = snap - allSlidesOffset;\n                });\n                slidesGrid.forEach((snap, snapIndex)=>{\n                    slidesGrid[snapIndex] = snap + allSlidesOffset;\n                });\n            }\n        }\n        Object.assign(swiper, {\n            slides: slides,\n            snapGrid: snapGrid,\n            slidesGrid: slidesGrid,\n            slidesSizesGrid: slidesSizesGrid\n        });\n        if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n            setCSSProperty(wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n            const addToSnapGrid = -swiper.snapGrid[0];\n            const addToSlidesGrid = -swiper.slidesGrid[0];\n            swiper.snapGrid = swiper.snapGrid.map((v)=>v + addToSnapGrid);\n            swiper.slidesGrid = swiper.slidesGrid.map((v)=>v + addToSlidesGrid);\n        }\n        if (slidesLength !== previousSlidesLength) swiper.emit(\"slidesLengthChange\");\n        if (snapGrid.length !== previousSnapGridLength) {\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            swiper.emit(\"snapGridLengthChange\");\n        }\n        if (slidesGrid.length !== previousSlidesGridLength) swiper.emit(\"slidesGridLengthChange\");\n        if (params.watchSlidesProgress) swiper.updateSlidesOffset();\n        if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n            const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n            if (slidesLength <= params.maxBackfaceHiddenSlides) {\n                if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n            } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);\n        }\n    }\n    function updateAutoHeight(speed) {\n        const swiper = this;\n        const activeSlides = [];\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        let newHeight = 0;\n        let i;\n        if (typeof speed === \"number\") swiper.setTransition(speed);\n        else if (speed === true) swiper.setTransition(swiper.params.speed);\n        const getSlideByIndex = (index)=>{\n            if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];\n            return swiper.slides[index];\n        };\n        // Find slides currently in view\n        if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n            if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide)=>{\n                activeSlides.push(slide);\n            });\n            else for(i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1){\n                const index = swiper.activeIndex + i;\n                if (index > swiper.slides.length && !isVirtual) break;\n                activeSlides.push(getSlideByIndex(index));\n            }\n        } else activeSlides.push(getSlideByIndex(swiper.activeIndex));\n        // Find new height from highest slide in view\n        for(i = 0; i < activeSlides.length; i += 1)if (typeof activeSlides[i] !== \"undefined\") {\n            const height = activeSlides[i].offsetHeight;\n            newHeight = height > newHeight ? height : newHeight;\n        }\n        // Update Height\n        if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n    }\n    function updateSlidesOffset() {\n        const swiper = this;\n        const slides = swiper.slides;\n        // eslint-disable-next-line\n        const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n        for(let i = 0; i < slides.length; i += 1)slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n    }\n    function updateSlidesProgress(translate) {\n        if (translate === void 0) translate = this && this.translate || 0;\n        const swiper = this;\n        const params = swiper.params;\n        const { slides: slides, rtlTranslate: rtl, snapGrid: snapGrid } = swiper;\n        if (slides.length === 0) return;\n        if (typeof slides[0].swiperSlideOffset === \"undefined\") swiper.updateSlidesOffset();\n        let offsetCenter = -translate;\n        if (rtl) offsetCenter = translate;\n        // Visible Slides\n        slides.forEach((slideEl)=>{\n            slideEl.classList.remove(params.slideVisibleClass);\n        });\n        swiper.visibleSlidesIndexes = [];\n        swiper.visibleSlides = [];\n        let spaceBetween = params.spaceBetween;\n        if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n        else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n        for(let i = 0; i < slides.length; i += 1){\n            const slide = slides[i];\n            let slideOffset = slide.swiperSlideOffset;\n            if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;\n            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n            const slideBefore = -(offsetCenter - slideOffset);\n            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n            if (isVisible) {\n                swiper.visibleSlides.push(slide);\n                swiper.visibleSlidesIndexes.push(i);\n                slides[i].classList.add(params.slideVisibleClass);\n            }\n            slide.progress = rtl ? -slideProgress : slideProgress;\n            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n        }\n    }\n    function updateProgress(translate) {\n        const swiper = this;\n        if (typeof translate === \"undefined\") {\n            const multiplier = swiper.rtlTranslate ? -1 : 1;\n            // eslint-disable-next-line\n            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n        }\n        const params = swiper.params;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        let { progress: progress, isBeginning: isBeginning, isEnd: isEnd, progressLoop: progressLoop } = swiper;\n        const wasBeginning = isBeginning;\n        const wasEnd = isEnd;\n        if (translatesDiff === 0) {\n            progress = 0;\n            isBeginning = true;\n            isEnd = true;\n        } else {\n            progress = (translate - swiper.minTranslate()) / translatesDiff;\n            const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n            const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n            isBeginning = isBeginningRounded || progress <= 0;\n            isEnd = isEndRounded || progress >= 1;\n            if (isBeginningRounded) progress = 0;\n            if (isEndRounded) progress = 1;\n        }\n        if (params.loop) {\n            const firstSlideIndex = swiper.getSlideIndexByData(0);\n            const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n            const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n            const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n            const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n            const translateAbs = Math.abs(translate);\n            if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n            else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n            if (progressLoop > 1) progressLoop -= 1;\n        }\n        Object.assign(swiper, {\n            progress: progress,\n            progressLoop: progressLoop,\n            isBeginning: isBeginning,\n            isEnd: isEnd\n        });\n        if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n        if (isBeginning && !wasBeginning) swiper.emit(\"reachBeginning toEdge\");\n        if (isEnd && !wasEnd) swiper.emit(\"reachEnd toEdge\");\n        if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit(\"fromEdge\");\n        swiper.emit(\"progress\", progress);\n    }\n    function updateSlidesClasses() {\n        const swiper = this;\n        const { slides: slides, params: params, slidesEl: slidesEl, activeIndex: activeIndex } = swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        const getFilteredSlide = (selector)=>{\n            return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n        };\n        slides.forEach((slideEl)=>{\n            slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n        });\n        let activeSlide;\n        if (isVirtual) {\n            if (params.loop) {\n                let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n                activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n        } else activeSlide = slides[activeIndex];\n        if (activeSlide) {\n            // Active classes\n            activeSlide.classList.add(params.slideActiveClass);\n            // Next Slide\n            let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            if (params.loop && !nextSlide) nextSlide = slides[0];\n            if (nextSlide) nextSlide.classList.add(params.slideNextClass);\n            // Prev Slide\n            let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            params.loop;\n            if (prevSlide) prevSlide.classList.add(params.slidePrevClass);\n        }\n        swiper.emitSlidesClasses();\n    }\n    const processLazyPreloader = (swiper, imageEl)=>{\n        if (!swiper || swiper.destroyed || !swiper.params) return;\n        const slideSelector = ()=>swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n        const slideEl = imageEl.closest(slideSelector());\n        if (slideEl) {\n            const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            if (lazyEl) lazyEl.remove();\n        }\n    };\n    const unlazy = (swiper, index)=>{\n        if (!swiper.slides[index]) return;\n        const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n        if (imageEl) imageEl.removeAttribute(\"loading\");\n    };\n    const preload = (swiper)=>{\n        if (!swiper || swiper.destroyed || !swiper.params) return;\n        let amount = swiper.params.lazyPreloadPrevNext;\n        const len = swiper.slides.length;\n        if (!len || !amount || amount < 0) return;\n        amount = Math.min(amount, len);\n        const slidesPerView = swiper.params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n        const activeIndex = swiper.activeIndex;\n        if (swiper.params.grid && swiper.params.grid.rows > 1) {\n            const activeColumn = activeIndex;\n            const preloadColumns = [\n                activeColumn - amount\n            ];\n            preloadColumns.push(...Array.from({\n                length: amount\n            }).map((_, i)=>{\n                return activeColumn + slidesPerView + i;\n            }));\n            swiper.slides.forEach((slideEl, i)=>{\n                if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n            });\n            return;\n        }\n        const slideIndexLastInView = activeIndex + slidesPerView - 1;\n        if (swiper.params.rewind || swiper.params.loop) for(let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1){\n            const realIndex = (i % len + len) % len;\n            if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n        }\n        else {\n            for(let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1)if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) unlazy(swiper, i);\n        }\n    };\n    function getActiveIndexByTranslate(swiper) {\n        const { slidesGrid: slidesGrid, params: params } = swiper;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        let activeIndex;\n        for(let i = 0; i < slidesGrid.length; i += 1){\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i;\n                else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;\n            } else if (translate >= slidesGrid[i]) activeIndex = i;\n        }\n        // Normalize slideIndex\n        if (params.normalizeSlideIndex) {\n            if (activeIndex < 0 || typeof activeIndex === \"undefined\") activeIndex = 0;\n        }\n        return activeIndex;\n    }\n    function updateActiveIndex(newActiveIndex) {\n        const swiper = this;\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        const { snapGrid: snapGrid, params: params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;\n        let activeIndex = newActiveIndex;\n        let snapIndex;\n        const getVirtualRealIndex = (aIndex)=>{\n            let realIndex = aIndex - swiper.virtual.slidesBefore;\n            if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;\n            if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;\n            return realIndex;\n        };\n        if (typeof activeIndex === \"undefined\") activeIndex = getActiveIndexByTranslate(swiper);\n        if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate);\n        else {\n            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n        }\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        if (activeIndex === previousIndex) {\n            if (snapIndex !== previousSnapIndex) {\n                swiper.snapIndex = snapIndex;\n                swiper.emit(\"snapIndexChange\");\n            }\n            if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.realIndex = getVirtualRealIndex(activeIndex);\n            return;\n        }\n        // Get real index\n        let realIndex;\n        if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex);\n        else if (swiper.slides[activeIndex]) realIndex = parseInt(swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\") || activeIndex, 10);\n        else realIndex = activeIndex;\n        Object.assign(swiper, {\n            previousSnapIndex: previousSnapIndex,\n            snapIndex: snapIndex,\n            previousRealIndex: previousRealIndex,\n            realIndex: realIndex,\n            previousIndex: previousIndex,\n            activeIndex: activeIndex\n        });\n        if (swiper.initialized) preload(swiper);\n        swiper.emit(\"activeIndexChange\");\n        swiper.emit(\"snapIndexChange\");\n        if (previousRealIndex !== realIndex) swiper.emit(\"realIndexChange\");\n        if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit(\"slideChange\");\n    }\n    function updateClickedSlide(e) {\n        const swiper = this;\n        const params = swiper.params;\n        const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n        let slideFound = false;\n        let slideIndex;\n        if (slide) {\n            for(let i = 0; i < swiper.slides.length; i += 1)if (swiper.slides[i] === slide) {\n                slideFound = true;\n                slideIndex = i;\n                break;\n            }\n        }\n        if (slide && slideFound) {\n            swiper.clickedSlide = slide;\n            if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute(\"data-swiper-slide-index\"), 10);\n            else swiper.clickedIndex = slideIndex;\n        } else {\n            swiper.clickedSlide = undefined;\n            swiper.clickedIndex = undefined;\n            return;\n        }\n        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();\n    }\n    var update = {\n        updateSize: updateSize,\n        updateSlides: updateSlides,\n        updateAutoHeight: updateAutoHeight,\n        updateSlidesOffset: updateSlidesOffset,\n        updateSlidesProgress: updateSlidesProgress,\n        updateProgress: updateProgress,\n        updateSlidesClasses: updateSlidesClasses,\n        updateActiveIndex: updateActiveIndex,\n        updateClickedSlide: updateClickedSlide\n    };\n    function getSwiperTranslate(axis) {\n        if (axis === void 0) axis = this.isHorizontal() ? \"x\" : \"y\";\n        const swiper = this;\n        const { params: params, rtlTranslate: rtl, translate: translate, wrapperEl: wrapperEl } = swiper;\n        if (params.virtualTranslate) return rtl ? -translate : translate;\n        if (params.cssMode) return translate;\n        let currentTranslate = getTranslate(wrapperEl, axis);\n        currentTranslate += swiper.cssOverflowAdjustment();\n        if (rtl) currentTranslate = -currentTranslate;\n        return currentTranslate || 0;\n    }\n    function setTranslate(translate, byController) {\n        const swiper = this;\n        const { rtlTranslate: rtl, params: params, wrapperEl: wrapperEl, progress: progress } = swiper;\n        let x = 0;\n        let y = 0;\n        const z = 0;\n        if (swiper.isHorizontal()) x = rtl ? -translate : translate;\n        else y = translate;\n        if (params.roundLengths) {\n            x = Math.floor(x);\n            y = Math.floor(y);\n        }\n        swiper.previousTranslate = swiper.translate;\n        swiper.translate = swiper.isHorizontal() ? x : y;\n        if (params.cssMode) wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n        else if (!params.virtualTranslate) {\n            if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment();\n            else y -= swiper.cssOverflowAdjustment();\n            wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n        }\n        // Check if we need to update progress\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (translatesDiff === 0) newProgress = 0;\n        else newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n        if (newProgress !== progress) swiper.updateProgress(translate);\n        swiper.emit(\"setTranslate\", swiper.translate, byController);\n    }\n    function minTranslate() {\n        return -this.snapGrid[0];\n    }\n    function maxTranslate() {\n        return -this.snapGrid[this.snapGrid.length - 1];\n    }\n    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n        if (translate === void 0) translate = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (translateBounds === void 0) translateBounds = true;\n        const swiper = this;\n        const { params: params, wrapperEl: wrapperEl } = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition) return false;\n        const minTranslate = swiper.minTranslate();\n        const maxTranslate = swiper.maxTranslate();\n        let newTranslate;\n        if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n        else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n        else newTranslate = translate;\n        // Update progress\n        swiper.updateProgress(newTranslate);\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            if (speed === 0) wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n            else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper: swiper,\n                        targetPosition: -newTranslate,\n                        side: isH ? \"left\" : \"top\"\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? \"left\" : \"top\"]: -newTranslate,\n                    behavior: \"smooth\"\n                });\n            }\n            return true;\n        }\n        if (speed === 0) {\n            swiper.setTransition(0);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit(\"beforeTransitionStart\", speed, internal);\n                swiper.emit(\"transitionEnd\");\n            }\n        } else {\n            swiper.setTransition(speed);\n            swiper.setTranslate(newTranslate);\n            if (runCallbacks) {\n                swiper.emit(\"beforeTransitionStart\", speed, internal);\n                swiper.emit(\"transitionStart\");\n            }\n            if (!swiper.animating) {\n                swiper.animating = true;\n                if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n                    if (!swiper || swiper.destroyed) return;\n                    if (e.target !== this) return;\n                    swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n                    swiper.onTranslateToWrapperTransitionEnd = null;\n                    delete swiper.onTranslateToWrapperTransitionEnd;\n                    if (runCallbacks) swiper.emit(\"transitionEnd\");\n                };\n                swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n            }\n        }\n        return true;\n    }\n    var translate = {\n        getTranslate: getSwiperTranslate,\n        setTranslate: setTranslate,\n        minTranslate: minTranslate,\n        maxTranslate: maxTranslate,\n        translateTo: translateTo\n    };\n    function setTransition(duration, byController) {\n        const swiper = this;\n        if (!swiper.params.cssMode) swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n        swiper.emit(\"setTransition\", duration, byController);\n    }\n    function transitionEmit(_ref) {\n        let { swiper: swiper, runCallbacks: runCallbacks, direction: direction, step: step } = _ref;\n        const { activeIndex: activeIndex, previousIndex: previousIndex } = swiper;\n        let dir = direction;\n        if (!dir) {\n            if (activeIndex > previousIndex) dir = \"next\";\n            else if (activeIndex < previousIndex) dir = \"prev\";\n            else dir = \"reset\";\n        }\n        swiper.emit(`transition${step}`);\n        if (runCallbacks && activeIndex !== previousIndex) {\n            if (dir === \"reset\") {\n                swiper.emit(`slideResetTransition${step}`);\n                return;\n            }\n            swiper.emit(`slideChangeTransition${step}`);\n            if (dir === \"next\") swiper.emit(`slideNextTransition${step}`);\n            else swiper.emit(`slidePrevTransition${step}`);\n        }\n    }\n    function transitionStart(runCallbacks, direction) {\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params } = swiper;\n        if (params.cssMode) return;\n        if (params.autoHeight) swiper.updateAutoHeight();\n        transitionEmit({\n            swiper: swiper,\n            runCallbacks: runCallbacks,\n            direction: direction,\n            step: \"Start\"\n        });\n    }\n    function transitionEnd(runCallbacks, direction) {\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params } = swiper;\n        swiper.animating = false;\n        if (params.cssMode) return;\n        swiper.setTransition(0);\n        transitionEmit({\n            swiper: swiper,\n            runCallbacks: runCallbacks,\n            direction: direction,\n            step: \"End\"\n        });\n    }\n    var transition = {\n        setTransition: setTransition,\n        transitionStart: transitionStart,\n        transitionEnd: transitionEnd\n    };\n    function slideTo(index, speed, runCallbacks, internal, initial) {\n        if (index === void 0) index = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (typeof index === \"string\") index = parseInt(index, 10);\n        const swiper = this;\n        let slideIndex = index;\n        if (slideIndex < 0) slideIndex = 0;\n        const { params: params, snapGrid: snapGrid, slidesGrid: slidesGrid, previousIndex: previousIndex, activeIndex: activeIndex, rtlTranslate: rtl, wrapperEl: wrapperEl, enabled: enabled } = swiper;\n        if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n        const translate = -snapGrid[snapIndex];\n        // Normalize slideIndex\n        if (params.normalizeSlideIndex) for(let i = 0; i < slidesGrid.length; i += 1){\n            const normalizedTranslate = -Math.floor(translate * 100);\n            const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n            const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i;\n                else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;\n            } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;\n        }\n        // Directions locks\n        if (swiper.initialized && slideIndex !== activeIndex) {\n            if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) return false;\n            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n                if ((activeIndex || 0) !== slideIndex) return false;\n            }\n        }\n        if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit(\"beforeSlideChangeStart\");\n        // Update progress\n        swiper.updateProgress(translate);\n        let direction;\n        if (slideIndex > activeIndex) direction = \"next\";\n        else if (slideIndex < activeIndex) direction = \"prev\";\n        else direction = \"reset\";\n        // Update Index\n        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n            swiper.updateActiveIndex(slideIndex);\n            // Update Height\n            if (params.autoHeight) swiper.updateAutoHeight();\n            swiper.updateSlidesClasses();\n            if (params.effect !== \"slide\") swiper.setTranslate(translate);\n            if (direction !== \"reset\") {\n                swiper.transitionStart(runCallbacks, direction);\n                swiper.transitionEnd(runCallbacks, direction);\n            }\n            return false;\n        }\n        if (params.cssMode) {\n            const isH = swiper.isHorizontal();\n            const t = rtl ? translate : -translate;\n            if (speed === 0) {\n                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n                if (isVirtual) {\n                    swiper.wrapperEl.style.scrollSnapType = \"none\";\n                    swiper._immediateVirtual = true;\n                }\n                if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n                    swiper._cssModeVirtualInitialSet = true;\n                    requestAnimationFrame(()=>{\n                        wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                    });\n                } else wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                if (isVirtual) requestAnimationFrame(()=>{\n                    swiper.wrapperEl.style.scrollSnapType = \"\";\n                    swiper._immediateVirtual = false;\n                });\n            } else {\n                if (!swiper.support.smoothScroll) {\n                    animateCSSModeScroll({\n                        swiper: swiper,\n                        targetPosition: t,\n                        side: isH ? \"left\" : \"top\"\n                    });\n                    return true;\n                }\n                wrapperEl.scrollTo({\n                    [isH ? \"left\" : \"top\"]: t,\n                    behavior: \"smooth\"\n                });\n            }\n            return true;\n        }\n        swiper.setTransition(speed);\n        swiper.setTranslate(translate);\n        swiper.updateActiveIndex(slideIndex);\n        swiper.updateSlidesClasses();\n        swiper.emit(\"beforeTransitionStart\", speed, internal);\n        swiper.transitionStart(runCallbacks, direction);\n        if (speed === 0) swiper.transitionEnd(runCallbacks, direction);\n        else if (!swiper.animating) {\n            swiper.animating = true;\n            if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n                if (!swiper || swiper.destroyed) return;\n                if (e.target !== this) return;\n                swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n                swiper.onSlideToWrapperTransitionEnd = null;\n                delete swiper.onSlideToWrapperTransitionEnd;\n                swiper.transitionEnd(runCallbacks, direction);\n            };\n            swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n        }\n        return true;\n    }\n    function slideToLoop(index, speed, runCallbacks, internal) {\n        if (index === void 0) index = 0;\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (typeof index === \"string\") {\n            const indexAsNumber = parseInt(index, 10);\n            index = indexAsNumber;\n        }\n        const swiper = this;\n        let newIndex = index;\n        if (swiper.params.loop) {\n            if (swiper.virtual && swiper.params.virtual.enabled) // eslint-disable-next-line\n            newIndex = newIndex + swiper.virtual.slidesBefore;\n            else newIndex = swiper.getSlideIndexByData(newIndex);\n        }\n        return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideNext(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { enabled: enabled, params: params, animating: animating } = swiper;\n        if (!enabled) return swiper;\n        let perGroup = params.slidesPerGroup;\n        if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        if (params.loop) {\n            if (animating && !isVirtual && params.loopPreventsSliding) return false;\n            swiper.loopFix({\n                direction: \"next\"\n            });\n            // eslint-disable-next-line\n            swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        }\n        if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);\n        return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slidePrev(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        const { params: params, snapGrid: snapGrid, slidesGrid: slidesGrid, rtlTranslate: rtlTranslate, enabled: enabled, animating: animating } = swiper;\n        if (!enabled) return swiper;\n        const isVirtual = swiper.virtual && params.virtual.enabled;\n        if (params.loop) {\n            if (animating && !isVirtual && params.loopPreventsSliding) return false;\n            swiper.loopFix({\n                direction: \"prev\"\n            });\n            // eslint-disable-next-line\n            swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        }\n        const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n        function normalize(val) {\n            if (val < 0) return -Math.floor(Math.abs(val));\n            return Math.floor(val);\n        }\n        const normalizedTranslate = normalize(translate);\n        const normalizedSnapGrid = snapGrid.map((val)=>normalize(val));\n        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n        if (typeof prevSnap === \"undefined\" && params.cssMode) {\n            let prevSnapIndex;\n            snapGrid.forEach((snap, snapIndex)=>{\n                if (normalizedTranslate >= snap) // prevSnap = snap;\n                prevSnapIndex = snapIndex;\n            });\n            if (typeof prevSnapIndex !== \"undefined\") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n        let prevIndex = 0;\n        if (typeof prevSnap !== \"undefined\") {\n            prevIndex = slidesGrid.indexOf(prevSnap);\n            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n            if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n                prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n                prevIndex = Math.max(prevIndex, 0);\n            }\n        }\n        if (params.rewind && swiper.isBeginning) {\n            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n        }\n        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideReset(speed, runCallbacks, internal) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        const swiper = this;\n        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n    }\n    /* eslint no-unused-vars: \"off\" */ function slideToClosest(speed, runCallbacks, internal, threshold) {\n        if (speed === void 0) speed = this.params.speed;\n        if (runCallbacks === void 0) runCallbacks = true;\n        if (threshold === void 0) threshold = 0.5;\n        const swiper = this;\n        let index = swiper.activeIndex;\n        const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n        const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n        if (translate >= swiper.snapGrid[snapIndex]) {\n            // The current translate is on or after the current snap index, so the choice\n            // is between the current index and the one after it.\n            const currentSnap = swiper.snapGrid[snapIndex];\n            const nextSnap = swiper.snapGrid[snapIndex + 1];\n            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;\n        } else {\n            // The current translate is before the current snap index, so the choice\n            // is between the current index and the one before it.\n            const prevSnap = swiper.snapGrid[snapIndex - 1];\n            const currentSnap = swiper.snapGrid[snapIndex];\n            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;\n        }\n        index = Math.max(index, 0);\n        index = Math.min(index, swiper.slidesGrid.length - 1);\n        return swiper.slideTo(index, speed, runCallbacks, internal);\n    }\n    function slideToClickedSlide() {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n        let slideToIndex = swiper.clickedIndex;\n        let realIndex;\n        const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n        if (params.loop) {\n            if (swiper.animating) return;\n            realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n            if (params.centeredSlides) {\n                if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n                    swiper.loopFix();\n                    slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                    nextTick(()=>{\n                        swiper.slideTo(slideToIndex);\n                    });\n                } else swiper.slideTo(slideToIndex);\n            } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n                swiper.loopFix();\n                slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                nextTick(()=>{\n                    swiper.slideTo(slideToIndex);\n                });\n            } else swiper.slideTo(slideToIndex);\n        } else swiper.slideTo(slideToIndex);\n    }\n    var slide = {\n        slideTo: slideTo,\n        slideToLoop: slideToLoop,\n        slideNext: slideNext,\n        slidePrev: slidePrev,\n        slideReset: slideReset,\n        slideToClosest: slideToClosest,\n        slideToClickedSlide: slideToClickedSlide\n    };\n    function loopCreate(slideRealIndex) {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        slides.forEach((el, index)=>{\n            el.setAttribute(\"data-swiper-slide-index\", index);\n        });\n        swiper.loopFix({\n            slideRealIndex: slideRealIndex,\n            direction: params.centeredSlides ? undefined : \"next\"\n        });\n    }\n    function loopFix(_temp) {\n        let { slideRealIndex: slideRealIndex, slideTo: slideTo = true, direction: direction, setTranslate: setTranslate, activeSlideIndex: activeSlideIndex, byController: byController, byMousewheel: byMousewheel } = _temp === void 0 ? {} : _temp;\n        const swiper = this;\n        if (!swiper.params.loop) return;\n        swiper.emit(\"beforeLoopFix\");\n        const { slides: slides, allowSlidePrev: allowSlidePrev, allowSlideNext: allowSlideNext, slidesEl: slidesEl, params: params } = swiper;\n        swiper.allowSlidePrev = true;\n        swiper.allowSlideNext = true;\n        if (swiper.virtual && params.virtual.enabled) {\n            if (slideTo) {\n                if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n                else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n                else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n            }\n            swiper.allowSlidePrev = allowSlidePrev;\n            swiper.allowSlideNext = allowSlideNext;\n            swiper.emit(\"loopFix\");\n            return;\n        }\n        const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n        let loopedSlides = params.loopedSlides || slidesPerView;\n        if (loopedSlides % params.slidesPerGroup !== 0) loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n        swiper.loopedSlides = loopedSlides;\n        const prependSlidesIndexes = [];\n        const appendSlidesIndexes = [];\n        let activeIndex = swiper.activeIndex;\n        if (typeof activeSlideIndex === \"undefined\") activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el)=>el.classList.contains(params.slideActiveClass))[0]);\n        else activeIndex = activeSlideIndex;\n        const isNext = direction === \"next\" || !direction;\n        const isPrev = direction === \"prev\" || !direction;\n        let slidesPrepended = 0;\n        let slidesAppended = 0;\n        // prepend last slides before start\n        if (activeSlideIndex < loopedSlides) {\n            slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n            for(let i = 0; i < loopedSlides - activeSlideIndex; i += 1){\n                const index = i - Math.floor(i / slides.length) * slides.length;\n                prependSlidesIndexes.push(slides.length - index - 1);\n            }\n        } else if (activeSlideIndex /* + slidesPerView */  > swiper.slides.length - loopedSlides * 2) {\n            slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n            for(let i = 0; i < slidesAppended; i += 1){\n                const index = i - Math.floor(i / slides.length) * slides.length;\n                appendSlidesIndexes.push(index);\n            }\n        }\n        if (isPrev) prependSlidesIndexes.forEach((index)=>{\n            swiper.slides[index].swiperLoopMoveDOM = true;\n            slidesEl.prepend(swiper.slides[index]);\n            swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n        if (isNext) appendSlidesIndexes.forEach((index)=>{\n            swiper.slides[index].swiperLoopMoveDOM = true;\n            slidesEl.append(swiper.slides[index]);\n            swiper.slides[index].swiperLoopMoveDOM = false;\n        });\n        swiper.recalcSlides();\n        if (params.slidesPerView === \"auto\") swiper.updateSlides();\n        if (params.watchSlidesProgress) swiper.updateSlidesOffset();\n        if (slideTo) {\n            if (prependSlidesIndexes.length > 0 && isPrev) {\n                if (typeof slideRealIndex === \"undefined\") {\n                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n                    const diff = newSlideTranslate - currentSlideTranslate;\n                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff);\n                    else {\n                        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n                        if (setTranslate) {\n                            swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n                            swiper.touchEventsData.currentTranslate = swiper.translate;\n                        }\n                    }\n                } else if (setTranslate) {\n                    swiper.slideToLoop(slideRealIndex, 0, false, true);\n                    swiper.touchEventsData.currentTranslate = swiper.translate;\n                }\n            } else if (appendSlidesIndexes.length > 0 && isNext) {\n                if (typeof slideRealIndex === \"undefined\") {\n                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                    const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n                    const diff = newSlideTranslate - currentSlideTranslate;\n                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff);\n                    else {\n                        swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n                        if (setTranslate) {\n                            swiper.touches[swiper.isHorizontal() ? \"startX\" : \"startY\"] += diff;\n                            swiper.touchEventsData.currentTranslate = swiper.translate;\n                        }\n                    }\n                } else swiper.slideToLoop(slideRealIndex, 0, false, true);\n            }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.controller && swiper.controller.control && !byController) {\n            const loopParams = {\n                slideRealIndex: slideRealIndex,\n                slideTo: false,\n                direction: direction,\n                setTranslate: setTranslate,\n                activeSlideIndex: activeSlideIndex,\n                byController: true\n            };\n            if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c)=>{\n                if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n            });\n            else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix(loopParams);\n        }\n        swiper.emit(\"loopFix\");\n    }\n    function loopDestroy() {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n        swiper.recalcSlides();\n        const newSlidesOrder = [];\n        swiper.slides.forEach((slideEl)=>{\n            const index = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n            newSlidesOrder[index] = slideEl;\n        });\n        swiper.slides.forEach((slideEl)=>{\n            slideEl.removeAttribute(\"data-swiper-slide-index\");\n        });\n        newSlidesOrder.forEach((slideEl)=>{\n            slidesEl.append(slideEl);\n        });\n        swiper.recalcSlides();\n        swiper.slideTo(swiper.realIndex, 0);\n    }\n    var loop = {\n        loopCreate: loopCreate,\n        loopFix: loopFix,\n        loopDestroy: loopDestroy\n    };\n    function setGrabCursor(moving) {\n        const swiper = this;\n        if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n        if (swiper.isElement) swiper.__preventObserver__ = true;\n        el.style.cursor = \"move\";\n        el.style.cursor = moving ? \"grabbing\" : \"grab\";\n        if (swiper.isElement) requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n    function unsetGrabCursor() {\n        const swiper = this;\n        if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n        if (swiper.isElement) swiper.__preventObserver__ = true;\n        swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n        if (swiper.isElement) requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n    var grabCursor = {\n        setGrabCursor: setGrabCursor,\n        unsetGrabCursor: unsetGrabCursor\n    };\n    // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n    function closestElement(selector, base) {\n        if (base === void 0) base = this;\n        function __closestFrom(el) {\n            if (!el || el === getDocument() || el === getWindow()) return null;\n            if (el.assignedSlot) el = el.assignedSlot;\n            const found = el.closest(selector);\n            if (!found && !el.getRootNode) return null;\n            return found || __closestFrom(el.getRootNode().host);\n        }\n        return __closestFrom(base);\n    }\n    function onTouchStart(event1) {\n        const swiper = this;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        const data = swiper.touchEventsData;\n        data.evCache.push(event1);\n        const { params: params, touches: touches, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        if (swiper.animating && params.preventInteractionOnTransition) return;\n        if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        let targetEl = e.target;\n        if (params.touchEventsTarget === \"wrapper\") {\n            if (!swiper.wrapperEl.contains(targetEl)) return;\n        }\n        if (\"which\" in e && e.which === 3) return;\n        if (\"button\" in e && e.button > 0) return;\n        if (data.isTouched && data.isMoved) return;\n        // change target el for shadow root component\n        const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n        // eslint-disable-next-line\n        const eventPath = event1.composedPath ? event1.composedPath() : event1.path;\n        if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];\n        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n        const isTargetShadow = !!(e.target && e.target.shadowRoot);\n        // use closestElement for shadow root element to get the actual closest for nested shadow root element\n        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n            swiper.allowClick = true;\n            return;\n        }\n        if (params.swipeHandler) {\n            if (!targetEl.closest(params.swipeHandler)) return;\n        }\n        touches.currentX = e.pageX;\n        touches.currentY = e.pageY;\n        const startX = touches.currentX;\n        const startY = touches.currentY;\n        // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n        const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n        const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window1.innerWidth - edgeSwipeThreshold)) {\n            if (edgeSwipeDetection === \"prevent\") event1.preventDefault();\n            else return;\n        }\n        Object.assign(data, {\n            isTouched: true,\n            isMoved: false,\n            allowTouchCallbacks: true,\n            isScrolling: undefined,\n            startMoving: undefined\n        });\n        touches.startX = startX;\n        touches.startY = startY;\n        data.touchStartTime = now();\n        swiper.allowClick = true;\n        swiper.updateSize();\n        swiper.swipeDirection = undefined;\n        if (params.threshold > 0) data.allowThresholdMove = false;\n        let preventDefault = true;\n        if (targetEl.matches(data.focusableElements)) {\n            preventDefault = false;\n            if (targetEl.nodeName === \"SELECT\") data.isTouched = false;\n        }\n        if (document1.activeElement && document1.activeElement.matches(data.focusableElements) && document1.activeElement !== targetEl) document1.activeElement.blur();\n        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();\n        swiper.emit(\"touchStart\", e);\n    }\n    function onTouchMove(event1) {\n        const document1 = getDocument();\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const { params: params, touches: touches, rtlTranslate: rtl, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        if (!data.isTouched) {\n            if (data.startMoving && data.isScrolling) swiper.emit(\"touchMoveOpposite\", e);\n            return;\n        }\n        const pointerIndex = data.evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n        if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n        const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n        const pageX = targetTouch.pageX;\n        const pageY = targetTouch.pageY;\n        if (e.preventedByNestedSwiper) {\n            touches.startX = pageX;\n            touches.startY = pageY;\n            return;\n        }\n        if (!swiper.allowTouchMove) {\n            if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;\n            if (data.isTouched) {\n                Object.assign(touches, {\n                    startX: pageX,\n                    startY: pageY,\n                    prevX: swiper.touches.currentX,\n                    prevY: swiper.touches.currentY,\n                    currentX: pageX,\n                    currentY: pageY\n                });\n                data.touchStartTime = now();\n            }\n            return;\n        }\n        if (params.touchReleaseOnEdges && !params.loop) {\n            if (swiper.isVertical()) // Vertical\n            {\n                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n                    data.isTouched = false;\n                    data.isMoved = false;\n                    return;\n                }\n            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;\n        }\n        if (document1.activeElement) {\n            if (e.target === document1.activeElement && e.target.matches(data.focusableElements)) {\n                data.isMoved = true;\n                swiper.allowClick = false;\n                return;\n            }\n        }\n        if (data.allowTouchCallbacks) swiper.emit(\"touchMove\", e);\n        if (e.targetTouches && e.targetTouches.length > 1) return;\n        touches.currentX = pageX;\n        touches.currentY = pageY;\n        const diffX = touches.currentX - touches.startX;\n        const diffY = touches.currentY - touches.startY;\n        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n        if (typeof data.isScrolling === \"undefined\") {\n            let touchAngle;\n            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false;\n            else // eslint-disable-next-line\n            if (diffX * diffX + diffY * diffY >= 25) {\n                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n            }\n        }\n        if (data.isScrolling) swiper.emit(\"touchMoveOpposite\", e);\n        if (typeof data.startMoving === \"undefined\") {\n            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;\n        }\n        if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n            data.isTouched = false;\n            return;\n        }\n        if (!data.startMoving) return;\n        swiper.allowClick = false;\n        if (!params.cssMode && e.cancelable) e.preventDefault();\n        if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();\n        let diff = swiper.isHorizontal() ? diffX : diffY;\n        let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n        if (params.oneWayMovement) {\n            diff = Math.abs(diff) * (rtl ? 1 : -1);\n            touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n        }\n        touches.diff = diff;\n        diff *= params.touchRatio;\n        if (rtl) {\n            diff = -diff;\n            touchesDiff = -touchesDiff;\n        }\n        const prevTouchesDirection = swiper.touchesDirection;\n        swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n        swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n        const isLoop = swiper.params.loop && !params.cssMode;\n        if (!data.isMoved) {\n            if (isLoop) swiper.loopFix({\n                direction: swiper.swipeDirection\n            });\n            data.startTranslate = swiper.getTranslate();\n            swiper.setTransition(0);\n            if (swiper.animating) {\n                const evt = new window.CustomEvent(\"transitionend\", {\n                    bubbles: true,\n                    cancelable: true\n                });\n                swiper.wrapperEl.dispatchEvent(evt);\n            }\n            data.allowMomentumBounce = false;\n            // Grab Cursor\n            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);\n            swiper.emit(\"sliderFirstMove\", e);\n        }\n        let loopFixed;\n        if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n            // need another loop fix\n            swiper.loopFix({\n                direction: swiper.swipeDirection,\n                setTranslate: true\n            });\n            loopFixed = true;\n        }\n        swiper.emit(\"sliderMove\", e);\n        data.isMoved = true;\n        data.currentTranslate = diff + data.startTranslate;\n        let disableParentSwiper = true;\n        let resistanceRatio = params.resistanceRatio;\n        if (params.touchReleaseOnEdges) resistanceRatio = 0;\n        if (diff > 0) {\n            if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) swiper.loopFix({\n                direction: \"prev\",\n                setTranslate: true,\n                activeSlideIndex: 0\n            });\n            if (data.currentTranslate > swiper.minTranslate()) {\n                disableParentSwiper = false;\n                if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n            }\n        } else if (diff < 0) {\n            if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) swiper.loopFix({\n                direction: \"next\",\n                setTranslate: true,\n                activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n            });\n            if (data.currentTranslate < swiper.maxTranslate()) {\n                disableParentSwiper = false;\n                if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n            }\n        }\n        if (disableParentSwiper) e.preventedByNestedSwiper = true;\n        // Directions locks\n        if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;\n        if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;\n        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;\n        // Threshold\n        if (params.threshold > 0) {\n            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n                if (!data.allowThresholdMove) {\n                    data.allowThresholdMove = true;\n                    touches.startX = touches.currentX;\n                    touches.startY = touches.currentY;\n                    data.currentTranslate = data.startTranslate;\n                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n                    return;\n                }\n            } else {\n                data.currentTranslate = data.startTranslate;\n                return;\n            }\n        }\n        if (!params.followFinger || params.cssMode) return;\n        // Update active index in free mode\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        if (params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();\n        // Update progress\n        swiper.updateProgress(data.currentTranslate);\n        // Update translate\n        swiper.setTranslate(data.currentTranslate);\n    }\n    function onTouchEnd(event1) {\n        const swiper = this;\n        const data = swiper.touchEventsData;\n        const pointerIndex = data.evCache.findIndex((cachedEv)=>cachedEv.pointerId === event1.pointerId);\n        if (pointerIndex >= 0) data.evCache.splice(pointerIndex, 1);\n        if ([\n            \"pointercancel\",\n            \"pointerout\",\n            \"pointerleave\"\n        ].includes(event1.type)) {\n            const proceed = event1.type === \"pointercancel\" && (swiper.browser.isSafari || swiper.browser.isWebView);\n            if (!proceed) return;\n        }\n        const { params: params, touches: touches, rtlTranslate: rtl, slidesGrid: slidesGrid, enabled: enabled } = swiper;\n        if (!enabled) return;\n        if (!params.simulateTouch && event1.pointerType === \"mouse\") return;\n        let e = event1;\n        if (e.originalEvent) e = e.originalEvent;\n        if (data.allowTouchCallbacks) swiper.emit(\"touchEnd\", e);\n        data.allowTouchCallbacks = false;\n        if (!data.isTouched) {\n            if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        // Return Grab Cursor\n        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);\n        // Time diff\n        const touchEndTime = now();\n        const timeDiff = touchEndTime - data.touchStartTime;\n        // Tap, doubleTap, Click\n        if (swiper.allowClick) {\n            const pathTree = e.path || e.composedPath && e.composedPath();\n            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n            swiper.emit(\"tap click\", e);\n            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit(\"doubleTap doubleClick\", e);\n        }\n        data.lastClickTime = now();\n        nextTick(()=>{\n            if (!swiper.destroyed) swiper.allowClick = true;\n        });\n        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n            data.isTouched = false;\n            data.isMoved = false;\n            data.startMoving = false;\n            return;\n        }\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        let currentPos;\n        if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate;\n        else currentPos = -data.currentTranslate;\n        if (params.cssMode) return;\n        if (params.freeMode && params.freeMode.enabled) {\n            swiper.freeMode.onTouchEnd({\n                currentPos: currentPos\n            });\n            return;\n        }\n        // Find current slide\n        let stopIndex = 0;\n        let groupSize = swiper.slidesSizesGrid[0];\n        for(let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){\n            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n            if (typeof slidesGrid[i + increment] !== \"undefined\") {\n                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n                    stopIndex = i;\n                    groupSize = slidesGrid[i + increment] - slidesGrid[i];\n                }\n            } else if (currentPos >= slidesGrid[i]) {\n                stopIndex = i;\n                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n            }\n        }\n        let rewindFirstIndex = null;\n        let rewindLastIndex = null;\n        if (params.rewind) {\n            if (swiper.isBeginning) rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n            else if (swiper.isEnd) rewindFirstIndex = 0;\n        }\n        // Find current slide size\n        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n        const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (timeDiff > params.longSwipesMs) {\n            // Long touches\n            if (!params.longSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (swiper.swipeDirection === \"next\") {\n                if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n                else swiper.slideTo(stopIndex);\n            }\n            if (swiper.swipeDirection === \"prev\") {\n                if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);\n                else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex);\n                else swiper.slideTo(stopIndex);\n            }\n        } else {\n            // Short swipes\n            if (!params.shortSwipes) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n            if (!isNavButtonTarget) {\n                if (swiper.swipeDirection === \"next\") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n                if (swiper.swipeDirection === \"prev\") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n            } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment);\n            else swiper.slideTo(stopIndex);\n        }\n    }\n    function onResize() {\n        const swiper = this;\n        const { params: params, el: el } = swiper;\n        if (el && el.offsetWidth === 0) return;\n        // Breakpoints\n        if (params.breakpoints) swiper.setBreakpoint();\n        // Save locks\n        const { allowSlideNext: allowSlideNext, allowSlidePrev: allowSlidePrev, snapGrid: snapGrid } = swiper;\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        // Disable locks on resize\n        swiper.allowSlideNext = true;\n        swiper.allowSlidePrev = true;\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateSlidesClasses();\n        const isVirtualLoop = isVirtual && params.loop;\n        if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n        else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        else swiper.slideTo(swiper.activeIndex, 0, false, true);\n        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n            clearTimeout(swiper.autoplay.resizeTimeout);\n            swiper.autoplay.resizeTimeout = setTimeout(()=>{\n                if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();\n            }, 500);\n        }\n        // Return locks after resize\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();\n    }\n    function onClick(e) {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        if (!swiper.allowClick) {\n            if (swiper.params.preventClicks) e.preventDefault();\n            if (swiper.params.preventClicksPropagation && swiper.animating) {\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n    }\n    function onScroll() {\n        const swiper = this;\n        const { wrapperEl: wrapperEl, rtlTranslate: rtlTranslate, enabled: enabled } = swiper;\n        if (!enabled) return;\n        swiper.previousTranslate = swiper.translate;\n        if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft;\n        else swiper.translate = -wrapperEl.scrollTop;\n        // eslint-disable-next-line\n        if (swiper.translate === 0) swiper.translate = 0;\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        let newProgress;\n        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n        if (translatesDiff === 0) newProgress = 0;\n        else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n        if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n        swiper.emit(\"setTranslate\", swiper.translate, false);\n    }\n    function onLoad(e) {\n        const swiper = this;\n        processLazyPreloader(swiper, e.target);\n        if (swiper.params.cssMode || swiper.params.slidesPerView !== \"auto\" && !swiper.params.autoHeight) return;\n        swiper.update();\n    }\n    let dummyEventAttached = false;\n    function dummyEventListener() {}\n    const events = (swiper, method)=>{\n        const document1 = getDocument();\n        const { params: params, el: el, wrapperEl: wrapperEl, device: device } = swiper;\n        const capture = !!params.nested;\n        const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n        const swiperMethod = method;\n        // Touch Events\n        el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n            passive: false\n        });\n        document1[domMethod](\"pointermove\", swiper.onTouchMove, {\n            passive: false,\n            capture: capture\n        });\n        document1[domMethod](\"pointerup\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointerout\", swiper.onTouchEnd, {\n            passive: true\n        });\n        document1[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n            passive: true\n        });\n        // Prevent Links Clicks\n        if (params.preventClicks || params.preventClicksPropagation) el[domMethod](\"click\", swiper.onClick, true);\n        if (params.cssMode) wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n        // Resize handler\n        if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n        else swiper[swiperMethod](\"observerUpdate\", onResize, true);\n        // Images loader\n        el[domMethod](\"load\", swiper.onLoad, {\n            capture: true\n        });\n    };\n    function attachEvents() {\n        const swiper = this;\n        const document1 = getDocument();\n        const { params: params } = swiper;\n        swiper.onTouchStart = onTouchStart.bind(swiper);\n        swiper.onTouchMove = onTouchMove.bind(swiper);\n        swiper.onTouchEnd = onTouchEnd.bind(swiper);\n        if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);\n        swiper.onClick = onClick.bind(swiper);\n        swiper.onLoad = onLoad.bind(swiper);\n        if (!dummyEventAttached) {\n            document1.addEventListener(\"touchstart\", dummyEventListener);\n            dummyEventAttached = true;\n        }\n        events(swiper, \"on\");\n    }\n    function detachEvents() {\n        const swiper = this;\n        events(swiper, \"off\");\n    }\n    var events$1 = {\n        attachEvents: attachEvents,\n        detachEvents: detachEvents\n    };\n    const isGridEnabled = (swiper, params)=>{\n        return swiper.grid && params.grid && params.grid.rows > 1;\n    };\n    function setBreakpoint() {\n        const swiper = this;\n        const { realIndex: realIndex, initialized: initialized, params: params, el: el } = swiper;\n        const breakpoints = params.breakpoints;\n        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n        // Get breakpoint for window width and update parameters\n        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n        const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n        const wasMultiRow = isGridEnabled(swiper, params);\n        const isMultiRow = isGridEnabled(swiper, breakpointParams);\n        const wasEnabled = params.enabled;\n        if (wasMultiRow && !isMultiRow) {\n            el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        } else if (!wasMultiRow && isMultiRow) {\n            el.classList.add(`${params.containerModifierClass}grid`);\n            if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") el.classList.add(`${params.containerModifierClass}grid-column`);\n            swiper.emitContainerClasses();\n        }\n        // Toggle navigation, pagination, scrollbar\n        [\n            \"navigation\",\n            \"pagination\",\n            \"scrollbar\"\n        ].forEach((prop)=>{\n            if (typeof breakpointParams[prop] === \"undefined\") return;\n            const wasModuleEnabled = params[prop] && params[prop].enabled;\n            const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n            if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();\n            if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();\n        });\n        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n        if (directionChanged && initialized) swiper.changeDirection();\n        extend(swiper.params, breakpointParams);\n        const isEnabled = swiper.params.enabled;\n        Object.assign(swiper, {\n            allowTouchMove: swiper.params.allowTouchMove,\n            allowSlideNext: swiper.params.allowSlideNext,\n            allowSlidePrev: swiper.params.allowSlidePrev\n        });\n        if (wasEnabled && !isEnabled) swiper.disable();\n        else if (!wasEnabled && isEnabled) swiper.enable();\n        swiper.currentBreakpoint = breakpoint;\n        swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n        if (needsReLoop && initialized) {\n            swiper.loopDestroy();\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        }\n        swiper.emit(\"breakpoint\", breakpointParams);\n    }\n    function getBreakpoint(breakpoints, base, containerEl) {\n        if (base === void 0) base = \"window\";\n        if (!breakpoints || base === \"container\" && !containerEl) return undefined;\n        let breakpoint = false;\n        const window1 = getWindow();\n        const currentHeight = base === \"window\" ? window1.innerHeight : containerEl.clientHeight;\n        const points = Object.keys(breakpoints).map((point)=>{\n            if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n                const minRatio = parseFloat(point.substr(1));\n                const value = currentHeight * minRatio;\n                return {\n                    value: value,\n                    point: point\n                };\n            }\n            return {\n                value: point,\n                point: point\n            };\n        });\n        points.sort((a, b)=>parseInt(a.value, 10) - parseInt(b.value, 10));\n        for(let i = 0; i < points.length; i += 1){\n            const { point: point, value: value } = points[i];\n            if (base === \"window\") {\n                if (window1.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;\n            } else if (value <= containerEl.clientWidth) breakpoint = point;\n        }\n        return breakpoint || \"max\";\n    }\n    var breakpoints = {\n        setBreakpoint: setBreakpoint,\n        getBreakpoint: getBreakpoint\n    };\n    function prepareClasses(entries, prefix) {\n        const resultClasses = [];\n        entries.forEach((item)=>{\n            if (typeof item === \"object\") Object.keys(item).forEach((classNames)=>{\n                if (item[classNames]) resultClasses.push(prefix + classNames);\n            });\n            else if (typeof item === \"string\") resultClasses.push(prefix + item);\n        });\n        return resultClasses;\n    }\n    function addClasses() {\n        const swiper = this;\n        const { classNames: classNames, params: params, rtl: rtl, el: el, device: device } = swiper;\n        // prettier-ignore\n        const suffixes = prepareClasses([\n            \"initialized\",\n            params.direction,\n            {\n                \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n            },\n            {\n                \"autoheight\": params.autoHeight\n            },\n            {\n                \"rtl\": rtl\n            },\n            {\n                \"grid\": params.grid && params.grid.rows > 1\n            },\n            {\n                \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n            },\n            {\n                \"android\": device.android\n            },\n            {\n                \"ios\": device.ios\n            },\n            {\n                \"css-mode\": params.cssMode\n            },\n            {\n                \"centered\": params.cssMode && params.centeredSlides\n            },\n            {\n                \"watch-progress\": params.watchSlidesProgress\n            }\n        ], params.containerModifierClass);\n        classNames.push(...suffixes);\n        el.classList.add(...classNames);\n        swiper.emitContainerClasses();\n    }\n    function removeClasses() {\n        const swiper = this;\n        const { el: el, classNames: classNames } = swiper;\n        el.classList.remove(...classNames);\n        swiper.emitContainerClasses();\n    }\n    var classes = {\n        addClasses: addClasses,\n        removeClasses: removeClasses\n    };\n    function checkOverflow() {\n        const swiper = this;\n        const { isLocked: wasLocked, params: params } = swiper;\n        const { slidesOffsetBefore: slidesOffsetBefore } = params;\n        if (slidesOffsetBefore) {\n            const lastSlideIndex = swiper.slides.length - 1;\n            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n            swiper.isLocked = swiper.size > lastSlideRightEdge;\n        } else swiper.isLocked = swiper.snapGrid.length === 1;\n        if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;\n        if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;\n        if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;\n        if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n    }\n    var checkOverflow$1 = {\n        checkOverflow: checkOverflow\n    };\n    var defaults = {\n        init: true,\n        direction: \"horizontal\",\n        oneWayMovement: false,\n        touchEventsTarget: \"wrapper\",\n        initialSlide: 0,\n        speed: 300,\n        cssMode: false,\n        updateOnWindowResize: true,\n        resizeObserver: true,\n        nested: false,\n        createElements: false,\n        enabled: true,\n        focusableElements: \"input, select, option, textarea, button, video, label\",\n        // Overrides\n        width: null,\n        height: null,\n        //\n        preventInteractionOnTransition: false,\n        // ssr\n        userAgent: null,\n        url: null,\n        // To support iOS's swipe-to-go-back gesture (when being used in-app).\n        edgeSwipeDetection: false,\n        edgeSwipeThreshold: 20,\n        // Autoheight\n        autoHeight: false,\n        // Set wrapper width\n        setWrapperSize: false,\n        // Virtual Translate\n        virtualTranslate: false,\n        // Effects\n        effect: \"slide\",\n        // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n        // Breakpoints\n        breakpoints: undefined,\n        breakpointsBase: \"window\",\n        // Slides grid\n        spaceBetween: 0,\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        slidesPerGroupSkip: 0,\n        slidesPerGroupAuto: false,\n        centeredSlides: false,\n        centeredSlidesBounds: false,\n        slidesOffsetBefore: 0,\n        // in px\n        slidesOffsetAfter: 0,\n        // in px\n        normalizeSlideIndex: true,\n        centerInsufficientSlides: false,\n        // Disable swiper and hide navigation when container not overflow\n        watchOverflow: true,\n        // Round length\n        roundLengths: false,\n        // Touches\n        touchRatio: 1,\n        touchAngle: 45,\n        simulateTouch: true,\n        shortSwipes: true,\n        longSwipes: true,\n        longSwipesRatio: 0.5,\n        longSwipesMs: 300,\n        followFinger: true,\n        allowTouchMove: true,\n        threshold: 5,\n        touchMoveStopPropagation: false,\n        touchStartPreventDefault: true,\n        touchStartForcePreventDefault: false,\n        touchReleaseOnEdges: false,\n        // Unique Navigation Elements\n        uniqueNavElements: true,\n        // Resistance\n        resistance: true,\n        resistanceRatio: 0.85,\n        // Progress\n        watchSlidesProgress: false,\n        // Cursor\n        grabCursor: false,\n        // Clicks\n        preventClicks: true,\n        preventClicksPropagation: true,\n        slideToClickedSlide: false,\n        // loop\n        loop: false,\n        loopedSlides: null,\n        loopPreventsSliding: true,\n        // rewind\n        rewind: false,\n        // Swiping/no swiping\n        allowSlidePrev: true,\n        allowSlideNext: true,\n        swipeHandler: null,\n        // '.swipe-handler',\n        noSwiping: true,\n        noSwipingClass: \"swiper-no-swiping\",\n        noSwipingSelector: null,\n        // Passive Listeners\n        passiveListeners: true,\n        maxBackfaceHiddenSlides: 10,\n        // NS\n        containerModifierClass: \"swiper-\",\n        // NEW\n        slideClass: \"swiper-slide\",\n        slideActiveClass: \"swiper-slide-active\",\n        slideVisibleClass: \"swiper-slide-visible\",\n        slideNextClass: \"swiper-slide-next\",\n        slidePrevClass: \"swiper-slide-prev\",\n        wrapperClass: \"swiper-wrapper\",\n        lazyPreloaderClass: \"swiper-lazy-preloader\",\n        lazyPreloadPrevNext: 0,\n        // Callbacks\n        runCallbacksOnInit: true,\n        // Internals\n        _emitClasses: false\n    };\n    function moduleExtendParams(params, allModulesParams) {\n        return function extendParams(obj) {\n            if (obj === void 0) obj = {};\n            const moduleParamName = Object.keys(obj)[0];\n            const moduleParams = obj[moduleParamName];\n            if (typeof moduleParams !== \"object\" || moduleParams === null) {\n                extend(allModulesParams, obj);\n                return;\n            }\n            if ([\n                \"navigation\",\n                \"pagination\",\n                \"scrollbar\"\n            ].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) params[moduleParamName] = {\n                auto: true\n            };\n            if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n                extend(allModulesParams, obj);\n                return;\n            }\n            if (params[moduleParamName] === true) params[moduleParamName] = {\n                enabled: true\n            };\n            if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) params[moduleParamName].enabled = true;\n            if (!params[moduleParamName]) params[moduleParamName] = {\n                enabled: false\n            };\n            extend(allModulesParams, obj);\n        };\n    }\n    /* eslint no-param-reassign: \"off\" */ const prototypes = {\n        eventsEmitter: eventsEmitter,\n        update: update,\n        translate: translate,\n        transition: transition,\n        slide: slide,\n        loop: loop,\n        grabCursor: grabCursor,\n        events: events$1,\n        breakpoints: breakpoints,\n        checkOverflow: checkOverflow$1,\n        classes: classes\n    };\n    const extendedDefaults = {};\n    class Swiper {\n        constructor(){\n            let el;\n            let params;\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];\n            if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") params = args[0];\n            else [el, params] = args;\n            if (!params) params = {};\n            params = extend({}, params);\n            if (el && !params.el) params.el = el;\n            const document1 = getDocument();\n            if (params.el && typeof params.el === \"string\" && document1.querySelectorAll(params.el).length > 1) {\n                const swipers = [];\n                document1.querySelectorAll(params.el).forEach((containerEl)=>{\n                    const newParams = extend({}, params, {\n                        el: containerEl\n                    });\n                    swipers.push(new Swiper(newParams));\n                });\n                // eslint-disable-next-line no-constructor-return\n                return swipers;\n            }\n            // Swiper Instance\n            const swiper = this;\n            swiper.__swiper__ = true;\n            swiper.support = getSupport();\n            swiper.device = getDevice({\n                userAgent: params.userAgent\n            });\n            swiper.browser = getBrowser();\n            swiper.eventsListeners = {};\n            swiper.eventsAnyListeners = [];\n            swiper.modules = [\n                ...swiper.__modules__\n            ];\n            if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);\n            const allModulesParams = {};\n            swiper.modules.forEach((mod)=>{\n                mod({\n                    params: params,\n                    swiper: swiper,\n                    extendParams: moduleExtendParams(params, allModulesParams),\n                    on: swiper.on.bind(swiper),\n                    once: swiper.once.bind(swiper),\n                    off: swiper.off.bind(swiper),\n                    emit: swiper.emit.bind(swiper)\n                });\n            });\n            // Extend defaults with modules params\n            const swiperParams = extend({}, defaults, allModulesParams);\n            // Extend defaults with passed params\n            swiper.params = extend({}, swiperParams, extendedDefaults, params);\n            swiper.originalParams = extend({}, swiper.params);\n            swiper.passedParams = extend({}, params);\n            // add event listeners\n            if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName)=>{\n                swiper.on(eventName, swiper.params.on[eventName]);\n            });\n            if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);\n            // Extend Swiper\n            Object.assign(swiper, {\n                enabled: swiper.params.enabled,\n                el: el,\n                // Classes\n                classNames: [],\n                // Slides\n                slides: [],\n                slidesGrid: [],\n                snapGrid: [],\n                slidesSizesGrid: [],\n                // isDirection\n                isHorizontal () {\n                    return swiper.params.direction === \"horizontal\";\n                },\n                isVertical () {\n                    return swiper.params.direction === \"vertical\";\n                },\n                // Indexes\n                activeIndex: 0,\n                realIndex: 0,\n                //\n                isBeginning: true,\n                isEnd: false,\n                // Props\n                translate: 0,\n                previousTranslate: 0,\n                progress: 0,\n                velocity: 0,\n                animating: false,\n                cssOverflowAdjustment () {\n                    // Returns 0 unless `translate` is > 2**23\n                    // Should be subtracted from css values to prevent overflow\n                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n                },\n                // Locks\n                allowSlideNext: swiper.params.allowSlideNext,\n                allowSlidePrev: swiper.params.allowSlidePrev,\n                // Touch Events\n                touchEventsData: {\n                    isTouched: undefined,\n                    isMoved: undefined,\n                    allowTouchCallbacks: undefined,\n                    touchStartTime: undefined,\n                    isScrolling: undefined,\n                    currentTranslate: undefined,\n                    startTranslate: undefined,\n                    allowThresholdMove: undefined,\n                    // Form elements to match\n                    focusableElements: swiper.params.focusableElements,\n                    // Last click time\n                    lastClickTime: 0,\n                    clickTimeout: undefined,\n                    // Velocities\n                    velocities: [],\n                    allowMomentumBounce: undefined,\n                    startMoving: undefined,\n                    evCache: []\n                },\n                // Clicks\n                allowClick: true,\n                // Touches\n                allowTouchMove: swiper.params.allowTouchMove,\n                touches: {\n                    startX: 0,\n                    startY: 0,\n                    currentX: 0,\n                    currentY: 0,\n                    diff: 0\n                },\n                // Images\n                imagesToLoad: [],\n                imagesLoaded: 0\n            });\n            swiper.emit(\"_swiper\");\n            // Init\n            if (swiper.params.init) swiper.init();\n            // Return app instance\n            // eslint-disable-next-line no-constructor-return\n            return swiper;\n        }\n        getSlideIndex(slideEl) {\n            const { slidesEl: slidesEl, params: params } = this;\n            const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n            const firstSlideIndex = elementIndex(slides[0]);\n            return elementIndex(slideEl) - firstSlideIndex;\n        }\n        getSlideIndexByData(index) {\n            return this.getSlideIndex(this.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === index)[0]);\n        }\n        recalcSlides() {\n            const swiper = this;\n            const { slidesEl: slidesEl, params: params } = swiper;\n            swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n        }\n        enable() {\n            const swiper = this;\n            if (swiper.enabled) return;\n            swiper.enabled = true;\n            if (swiper.params.grabCursor) swiper.setGrabCursor();\n            swiper.emit(\"enable\");\n        }\n        disable() {\n            const swiper = this;\n            if (!swiper.enabled) return;\n            swiper.enabled = false;\n            if (swiper.params.grabCursor) swiper.unsetGrabCursor();\n            swiper.emit(\"disable\");\n        }\n        setProgress(progress, speed) {\n            const swiper = this;\n            progress = Math.min(Math.max(progress, 0), 1);\n            const min = swiper.minTranslate();\n            const max = swiper.maxTranslate();\n            const current = (max - min) * progress + min;\n            swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        emitContainerClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const cls = swiper.el.className.split(\" \").filter((className)=>{\n                return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n            });\n            swiper.emit(\"_containerClasses\", cls.join(\" \"));\n        }\n        getSlideClasses(slideEl) {\n            const swiper = this;\n            if (swiper.destroyed) return \"\";\n            return slideEl.className.split(\" \").filter((className)=>{\n                return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n            }).join(\" \");\n        }\n        emitSlidesClasses() {\n            const swiper = this;\n            if (!swiper.params._emitClasses || !swiper.el) return;\n            const updates = [];\n            swiper.slides.forEach((slideEl)=>{\n                const classNames = swiper.getSlideClasses(slideEl);\n                updates.push({\n                    slideEl: slideEl,\n                    classNames: classNames\n                });\n                swiper.emit(\"_slideClass\", slideEl, classNames);\n            });\n            swiper.emit(\"_slideClasses\", updates);\n        }\n        slidesPerViewDynamic(view, exact) {\n            if (view === void 0) view = \"current\";\n            if (exact === void 0) exact = false;\n            const swiper = this;\n            const { params: params, slides: slides, slidesGrid: slidesGrid, slidesSizesGrid: slidesSizesGrid, size: swiperSize, activeIndex: activeIndex } = swiper;\n            let spv = 1;\n            if (params.centeredSlides) {\n                let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n                let breakLoop;\n                for(let i = activeIndex + 1; i < slides.length; i += 1)if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n                for(let i = activeIndex - 1; i >= 0; i -= 1)if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n            } else {\n                // eslint-disable-next-line\n                if (view === \"current\") for(let i = activeIndex + 1; i < slides.length; i += 1){\n                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n                    if (slideInView) spv += 1;\n                }\n                else // previous\n                for(let i = activeIndex - 1; i >= 0; i -= 1){\n                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n                    if (slideInView) spv += 1;\n                }\n            }\n            return spv;\n        }\n        update() {\n            const swiper = this;\n            if (!swiper || swiper.destroyed) return;\n            const { snapGrid: snapGrid, params: params } = swiper;\n            // Breakpoints\n            if (params.breakpoints) swiper.setBreakpoint();\n            [\n                ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n            ].forEach((imageEl)=>{\n                if (imageEl.complete) processLazyPreloader(swiper, imageEl);\n            });\n            swiper.updateSize();\n            swiper.updateSlides();\n            swiper.updateProgress();\n            swiper.updateSlidesClasses();\n            function setTranslate() {\n                const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n                swiper.setTranslate(newTranslate);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n            let translated;\n            if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n                setTranslate();\n                if (params.autoHeight) swiper.updateAutoHeight();\n            } else {\n                if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n                    const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n                    translated = swiper.slideTo(slides.length - 1, 0, false, true);\n                } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n                if (!translated) setTranslate();\n            }\n            if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();\n            swiper.emit(\"update\");\n        }\n        changeDirection(newDirection, needUpdate) {\n            if (needUpdate === void 0) needUpdate = true;\n            const swiper = this;\n            const currentDirection = swiper.params.direction;\n            if (!newDirection) // eslint-disable-next-line\n            newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n            if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") return swiper;\n            swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n            swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n            swiper.emitContainerClasses();\n            swiper.params.direction = newDirection;\n            swiper.slides.forEach((slideEl)=>{\n                if (newDirection === \"vertical\") slideEl.style.width = \"\";\n                else slideEl.style.height = \"\";\n            });\n            swiper.emit(\"changeDirection\");\n            if (needUpdate) swiper.update();\n            return swiper;\n        }\n        changeLanguageDirection(direction) {\n            const swiper = this;\n            if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\") return;\n            swiper.rtl = direction === \"rtl\";\n            swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n            if (swiper.rtl) {\n                swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n                swiper.el.dir = \"rtl\";\n            } else {\n                swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n                swiper.el.dir = \"ltr\";\n            }\n            swiper.update();\n        }\n        mount(element) {\n            const swiper = this;\n            if (swiper.mounted) return true;\n            // Find el\n            let el = element || swiper.params.el;\n            if (typeof el === \"string\") el = document.querySelector(el);\n            if (!el) return false;\n            el.swiper = swiper;\n            if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === \"SWIPER-CONTAINER\") swiper.isElement = true;\n            const getWrapperSelector = ()=>{\n                return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n            };\n            const getWrapper = ()=>{\n                if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n                    const res = el.shadowRoot.querySelector(getWrapperSelector());\n                    // Children needs to return slot items\n                    return res;\n                }\n                return elementChildren(el, getWrapperSelector())[0];\n            };\n            // Find Wrapper\n            let wrapperEl = getWrapper();\n            if (!wrapperEl && swiper.params.createElements) {\n                wrapperEl = createElement(\"div\", swiper.params.wrapperClass);\n                el.append(wrapperEl);\n                elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl)=>{\n                    wrapperEl.append(slideEl);\n                });\n            }\n            Object.assign(swiper, {\n                el: el,\n                wrapperEl: wrapperEl,\n                slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n                hostEl: swiper.isElement ? el.parentNode.host : el,\n                mounted: true,\n                // RTL\n                rtl: el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\",\n                rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || elementStyle(el, \"direction\") === \"rtl\"),\n                wrongRTL: elementStyle(wrapperEl, \"display\") === \"-webkit-box\"\n            });\n            return true;\n        }\n        init(el) {\n            const swiper = this;\n            if (swiper.initialized) return swiper;\n            const mounted = swiper.mount(el);\n            if (mounted === false) return swiper;\n            swiper.emit(\"beforeInit\");\n            // Set breakpoint\n            if (swiper.params.breakpoints) swiper.setBreakpoint();\n            // Add Classes\n            swiper.addClasses();\n            // Update size\n            swiper.updateSize();\n            // Update slides\n            swiper.updateSlides();\n            if (swiper.params.watchOverflow) swiper.checkOverflow();\n            // Set Grab Cursor\n            if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();\n            // Slide To Initial Slide\n            if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n            else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n            // Create loop\n            if (swiper.params.loop) swiper.loopCreate();\n            // Attach events\n            swiper.attachEvents();\n            [\n                ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n            ].forEach((imageEl)=>{\n                if (imageEl.complete) processLazyPreloader(swiper, imageEl);\n                else imageEl.addEventListener(\"load\", (e)=>{\n                    processLazyPreloader(swiper, e.target);\n                });\n            });\n            preload(swiper);\n            // Init Flag\n            swiper.initialized = true;\n            preload(swiper);\n            // Emit\n            swiper.emit(\"init\");\n            swiper.emit(\"afterInit\");\n            return swiper;\n        }\n        destroy(deleteInstance, cleanStyles) {\n            if (deleteInstance === void 0) deleteInstance = true;\n            if (cleanStyles === void 0) cleanStyles = true;\n            const swiper = this;\n            const { params: params, el: el, wrapperEl: wrapperEl, slides: slides } = swiper;\n            if (typeof swiper.params === \"undefined\" || swiper.destroyed) return null;\n            swiper.emit(\"beforeDestroy\");\n            // Init Flag\n            swiper.initialized = false;\n            // Detach events\n            swiper.detachEvents();\n            // Destroy loop\n            if (params.loop) swiper.loopDestroy();\n            // Cleanup styles\n            if (cleanStyles) {\n                swiper.removeClasses();\n                el.removeAttribute(\"style\");\n                wrapperEl.removeAttribute(\"style\");\n                if (slides && slides.length) slides.forEach((slideEl)=>{\n                    slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n                    slideEl.removeAttribute(\"style\");\n                    slideEl.removeAttribute(\"data-swiper-slide-index\");\n                });\n            }\n            swiper.emit(\"destroy\");\n            // Detach emitter events\n            Object.keys(swiper.eventsListeners).forEach((eventName)=>{\n                swiper.off(eventName);\n            });\n            if (deleteInstance !== false) {\n                swiper.el.swiper = null;\n                deleteProps(swiper);\n            }\n            swiper.destroyed = true;\n            return null;\n        }\n        static extendDefaults(newDefaults) {\n            extend(extendedDefaults, newDefaults);\n        }\n        static get extendedDefaults() {\n            return extendedDefaults;\n        }\n        static get defaults() {\n            return defaults;\n        }\n        static installModule(mod) {\n            if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n            const modules = Swiper.prototype.__modules__;\n            if (typeof mod === \"function\" && modules.indexOf(mod) < 0) modules.push(mod);\n        }\n        static use(module) {\n            if (Array.isArray(module)) {\n                module.forEach((m)=>Swiper.installModule(m));\n                return Swiper;\n            }\n            Swiper.installModule(module);\n            return Swiper;\n        }\n    }\n    Object.keys(prototypes).forEach((prototypeGroup)=>{\n        Object.keys(prototypes[prototypeGroup]).forEach((protoMethod)=>{\n            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n        });\n    });\n    Swiper.use([\n        Resize,\n        Observer\n    ]);\n    function Virtual(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        extendParams({\n            virtual: {\n                enabled: false,\n                slides: [],\n                cache: true,\n                renderSlide: null,\n                renderExternal: null,\n                renderExternalUpdate: true,\n                addSlidesBefore: 0,\n                addSlidesAfter: 0\n            }\n        });\n        let cssModeTimeout;\n        const document1 = getDocument();\n        swiper.virtual = {\n            cache: {},\n            from: undefined,\n            to: undefined,\n            slides: [],\n            offset: 0,\n            slidesGrid: []\n        };\n        const tempDOM = document1.createElement(\"div\");\n        function renderSlide(slide, index) {\n            const params = swiper.params.virtual;\n            if (params.cache && swiper.virtual.cache[index]) return swiper.virtual.cache[index];\n            // eslint-disable-next-line\n            let slideEl;\n            if (params.renderSlide) {\n                slideEl = params.renderSlide.call(swiper, slide, index);\n                if (typeof slideEl === \"string\") {\n                    tempDOM.innerHTML = slideEl;\n                    slideEl = tempDOM.children[0];\n                }\n            } else if (swiper.isElement) slideEl = createElement(\"swiper-slide\");\n            else slideEl = createElement(\"div\", swiper.params.slideClass);\n            slideEl.setAttribute(\"data-swiper-slide-index\", index);\n            if (!params.renderSlide) slideEl.innerHTML = slide;\n            if (params.cache) swiper.virtual.cache[index] = slideEl;\n            return slideEl;\n        }\n        function update(force) {\n            const { slidesPerView: slidesPerView, slidesPerGroup: slidesPerGroup, centeredSlides: centeredSlides, loop: isLoop } = swiper.params;\n            const { addSlidesBefore: addSlidesBefore, addSlidesAfter: addSlidesAfter } = swiper.params.virtual;\n            const { from: previousFrom, to: previousTo, slides: slides, slidesGrid: previousSlidesGrid, offset: previousOffset } = swiper.virtual;\n            if (!swiper.params.cssMode) swiper.updateActiveIndex();\n            const activeIndex = swiper.activeIndex || 0;\n            let offsetProp;\n            if (swiper.rtlTranslate) offsetProp = \"right\";\n            else offsetProp = swiper.isHorizontal() ? \"left\" : \"top\";\n            let slidesAfter;\n            let slidesBefore;\n            if (centeredSlides) {\n                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n            } else {\n                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n                slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n            }\n            let from = activeIndex - slidesBefore;\n            let to = activeIndex + slidesAfter;\n            if (!isLoop) {\n                from = Math.max(from, 0);\n                to = Math.min(to, slides.length - 1);\n            }\n            let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n            if (isLoop && activeIndex >= slidesBefore) {\n                from -= slidesBefore;\n                if (!centeredSlides) offset += swiper.slidesGrid[0];\n            } else if (isLoop && activeIndex < slidesBefore) {\n                from = -slidesBefore;\n                if (centeredSlides) offset += swiper.slidesGrid[0];\n            }\n            Object.assign(swiper.virtual, {\n                from: from,\n                to: to,\n                offset: offset,\n                slidesGrid: swiper.slidesGrid,\n                slidesBefore: slidesBefore,\n                slidesAfter: slidesAfter\n            });\n            function onRendered() {\n                swiper.updateSlides();\n                swiper.updateProgress();\n                swiper.updateSlidesClasses();\n                emit(\"virtualUpdate\");\n            }\n            if (previousFrom === from && previousTo === to && !force) {\n                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) swiper.slides.forEach((slideEl)=>{\n                    slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n                });\n                swiper.updateProgress();\n                emit(\"virtualUpdate\");\n                return;\n            }\n            if (swiper.params.virtual.renderExternal) {\n                swiper.params.virtual.renderExternal.call(swiper, {\n                    offset: offset,\n                    from: from,\n                    to: to,\n                    slides: function getSlides() {\n                        const slidesToRender = [];\n                        for(let i = from; i <= to; i += 1)slidesToRender.push(slides[i]);\n                        return slidesToRender;\n                    }()\n                });\n                if (swiper.params.virtual.renderExternalUpdate) onRendered();\n                else emit(\"virtualUpdate\");\n                return;\n            }\n            const prependIndexes = [];\n            const appendIndexes = [];\n            const getSlideIndex = (index)=>{\n                let slideIndex = index;\n                if (index < 0) slideIndex = slides.length + index;\n                else if (slideIndex >= slides.length) // eslint-disable-next-line\n                slideIndex = slideIndex - slides.length;\n                return slideIndex;\n            };\n            if (force) swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach((slideEl)=>{\n                slideEl.remove();\n            });\n            else {\n                for(let i = previousFrom; i <= previousTo; i += 1)if (i < from || i > to) {\n                    const slideIndex = getSlideIndex(i);\n                    swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach((slideEl)=>{\n                        slideEl.remove();\n                    });\n                }\n            }\n            const loopFrom = isLoop ? -slides.length : 0;\n            const loopTo = isLoop ? slides.length * 2 : slides.length;\n            for(let i = loopFrom; i < loopTo; i += 1)if (i >= from && i <= to) {\n                const slideIndex = getSlideIndex(i);\n                if (typeof previousTo === \"undefined\" || force) appendIndexes.push(slideIndex);\n                else {\n                    if (i > previousTo) appendIndexes.push(slideIndex);\n                    if (i < previousFrom) prependIndexes.push(slideIndex);\n                }\n            }\n            appendIndexes.forEach((index)=>{\n                swiper.slidesEl.append(renderSlide(slides[index], index));\n            });\n            if (isLoop) for(let i = prependIndexes.length - 1; i >= 0; i -= 1){\n                const index = prependIndexes[i];\n                swiper.slidesEl.prepend(renderSlide(slides[index], index));\n            }\n            else {\n                prependIndexes.sort((a, b)=>b - a);\n                prependIndexes.forEach((index)=>{\n                    swiper.slidesEl.prepend(renderSlide(slides[index], index));\n                });\n            }\n            elementChildren(swiper.slidesEl, \".swiper-slide, swiper-slide\").forEach((slideEl)=>{\n                slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n            });\n            onRendered();\n        }\n        function appendSlide(slides) {\n            if (typeof slides === \"object\" && \"length\" in slides) {\n                for(let i = 0; i < slides.length; i += 1)if (slides[i]) swiper.virtual.slides.push(slides[i]);\n            } else swiper.virtual.slides.push(slides);\n            update(true);\n        }\n        function prependSlide(slides) {\n            const activeIndex = swiper.activeIndex;\n            let newActiveIndex = activeIndex + 1;\n            let numberOfNewSlides = 1;\n            if (Array.isArray(slides)) {\n                for(let i = 0; i < slides.length; i += 1)if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n                newActiveIndex = activeIndex + slides.length;\n                numberOfNewSlides = slides.length;\n            } else swiper.virtual.slides.unshift(slides);\n            if (swiper.params.virtual.cache) {\n                const cache = swiper.virtual.cache;\n                const newCache = {};\n                Object.keys(cache).forEach((cachedIndex)=>{\n                    const cachedEl = cache[cachedIndex];\n                    const cachedElIndex = cachedEl.getAttribute(\"data-swiper-slide-index\");\n                    if (cachedElIndex) cachedEl.setAttribute(\"data-swiper-slide-index\", parseInt(cachedElIndex, 10) + numberOfNewSlides);\n                    newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n                });\n                swiper.virtual.cache = newCache;\n            }\n            update(true);\n            swiper.slideTo(newActiveIndex, 0);\n        }\n        function removeSlide(slidesIndexes) {\n            if (typeof slidesIndexes === \"undefined\" || slidesIndexes === null) return;\n            let activeIndex = swiper.activeIndex;\n            if (Array.isArray(slidesIndexes)) for(let i = slidesIndexes.length - 1; i >= 0; i -= 1){\n                swiper.virtual.slides.splice(slidesIndexes[i], 1);\n                if (swiper.params.virtual.cache) delete swiper.virtual.cache[slidesIndexes[i]];\n                if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n                activeIndex = Math.max(activeIndex, 0);\n            }\n            else {\n                swiper.virtual.slides.splice(slidesIndexes, 1);\n                if (swiper.params.virtual.cache) delete swiper.virtual.cache[slidesIndexes];\n                if (slidesIndexes < activeIndex) activeIndex -= 1;\n                activeIndex = Math.max(activeIndex, 0);\n            }\n            update(true);\n            swiper.slideTo(activeIndex, 0);\n        }\n        function removeAllSlides() {\n            swiper.virtual.slides = [];\n            if (swiper.params.virtual.cache) swiper.virtual.cache = {};\n            update(true);\n            swiper.slideTo(0, 0);\n        }\n        on(\"beforeInit\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            let domSlidesAssigned;\n            if (typeof swiper.passedParams.virtual.slides === \"undefined\") {\n                const slides = [\n                    ...swiper.slidesEl.children\n                ].filter((el)=>el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n                if (slides && slides.length) {\n                    swiper.virtual.slides = [\n                        ...slides\n                    ];\n                    domSlidesAssigned = true;\n                    slides.forEach((slideEl, slideIndex)=>{\n                        slideEl.setAttribute(\"data-swiper-slide-index\", slideIndex);\n                        swiper.virtual.cache[slideIndex] = slideEl;\n                        slideEl.remove();\n                    });\n                }\n            }\n            if (!domSlidesAssigned) swiper.virtual.slides = swiper.params.virtual.slides;\n            swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n            swiper.params.watchSlidesProgress = true;\n            swiper.originalParams.watchSlidesProgress = true;\n            if (!swiper.params.initialSlide) update();\n        });\n        on(\"setTranslate\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            if (swiper.params.cssMode && !swiper._immediateVirtual) {\n                clearTimeout(cssModeTimeout);\n                cssModeTimeout = setTimeout(()=>{\n                    update();\n                }, 100);\n            } else update();\n        });\n        on(\"init update resize\", ()=>{\n            if (!swiper.params.virtual.enabled) return;\n            if (swiper.params.cssMode) setCSSProperty(swiper.wrapperEl, \"--swiper-virtual-size\", `${swiper.virtualSize}px`);\n        });\n        Object.assign(swiper.virtual, {\n            appendSlide: appendSlide,\n            prependSlide: prependSlide,\n            removeSlide: removeSlide,\n            removeAllSlides: removeAllSlides,\n            update: update\n        });\n    }\n    /* eslint-disable consistent-return */ function Keyboard(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        swiper.keyboard = {\n            enabled: false\n        };\n        extendParams({\n            keyboard: {\n                enabled: false,\n                onlyInViewport: true,\n                pageUpDown: true\n            }\n        });\n        function handle(event1) {\n            if (!swiper.enabled) return;\n            const { rtlTranslate: rtl } = swiper;\n            let e = event1;\n            if (e.originalEvent) e = e.originalEvent; // jquery fix\n            const kc = e.keyCode || e.charCode;\n            const pageUpDown = swiper.params.keyboard.pageUpDown;\n            const isPageUp = pageUpDown && kc === 33;\n            const isPageDown = pageUpDown && kc === 34;\n            const isArrowLeft = kc === 37;\n            const isArrowRight = kc === 39;\n            const isArrowUp = kc === 38;\n            const isArrowDown = kc === 40;\n            // Directions locks\n            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) return false;\n            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) return false;\n            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) return undefined;\n            if (document1.activeElement && document1.activeElement.nodeName && (document1.activeElement.nodeName.toLowerCase() === \"input\" || document1.activeElement.nodeName.toLowerCase() === \"textarea\")) return undefined;\n            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n                let inView = false;\n                // Check that swiper should be inside of visible area of window\n                if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) return undefined;\n                const el = swiper.el;\n                const swiperWidth = el.clientWidth;\n                const swiperHeight = el.clientHeight;\n                const windowWidth = window1.innerWidth;\n                const windowHeight = window1.innerHeight;\n                const swiperOffset = elementOffset(el);\n                if (rtl) swiperOffset.left -= el.scrollLeft;\n                const swiperCoord = [\n                    [\n                        swiperOffset.left,\n                        swiperOffset.top\n                    ],\n                    [\n                        swiperOffset.left + swiperWidth,\n                        swiperOffset.top\n                    ],\n                    [\n                        swiperOffset.left,\n                        swiperOffset.top + swiperHeight\n                    ],\n                    [\n                        swiperOffset.left + swiperWidth,\n                        swiperOffset.top + swiperHeight\n                    ]\n                ];\n                for(let i = 0; i < swiperCoord.length; i += 1){\n                    const point = swiperCoord[i];\n                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n                        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n                        inView = true;\n                    }\n                }\n                if (!inView) return undefined;\n            }\n            if (swiper.isHorizontal()) {\n                if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n                    if (e.preventDefault) e.preventDefault();\n                    else e.returnValue = false;\n                }\n                if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n                if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n            } else {\n                if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n                    if (e.preventDefault) e.preventDefault();\n                    else e.returnValue = false;\n                }\n                if (isPageDown || isArrowDown) swiper.slideNext();\n                if (isPageUp || isArrowUp) swiper.slidePrev();\n            }\n            emit(\"keyPress\", kc);\n            return undefined;\n        }\n        function enable() {\n            if (swiper.keyboard.enabled) return;\n            document1.addEventListener(\"keydown\", handle);\n            swiper.keyboard.enabled = true;\n        }\n        function disable() {\n            if (!swiper.keyboard.enabled) return;\n            document1.removeEventListener(\"keydown\", handle);\n            swiper.keyboard.enabled = false;\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.keyboard.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.keyboard.enabled) disable();\n        });\n        Object.assign(swiper.keyboard, {\n            enable: enable,\n            disable: disable\n        });\n    }\n    /* eslint-disable consistent-return */ function Mousewheel(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        extendParams({\n            mousewheel: {\n                enabled: false,\n                releaseOnEdges: false,\n                invert: false,\n                forceToAxis: false,\n                sensitivity: 1,\n                eventsTarget: \"container\",\n                thresholdDelta: null,\n                thresholdTime: null,\n                noMousewheelClass: \"swiper-no-mousewheel\"\n            }\n        });\n        swiper.mousewheel = {\n            enabled: false\n        };\n        let timeout;\n        let lastScrollTime = now();\n        let lastEventBeforeSnap;\n        const recentWheelEvents = [];\n        function normalize(e) {\n            // Reasonable defaults\n            const PIXEL_STEP = 10;\n            const LINE_HEIGHT = 40;\n            const PAGE_HEIGHT = 800;\n            let sX = 0;\n            let sY = 0; // spinX, spinY\n            let pX = 0;\n            let pY = 0; // pixelX, pixelY\n            // Legacy\n            if (\"detail\" in e) sY = e.detail;\n            if (\"wheelDelta\" in e) sY = -e.wheelDelta / 120;\n            if (\"wheelDeltaY\" in e) sY = -e.wheelDeltaY / 120;\n            if (\"wheelDeltaX\" in e) sX = -e.wheelDeltaX / 120;\n            // side scrolling on FF with DOMMouseScroll\n            if (\"axis\" in e && e.axis === e.HORIZONTAL_AXIS) {\n                sX = sY;\n                sY = 0;\n            }\n            pX = sX * PIXEL_STEP;\n            pY = sY * PIXEL_STEP;\n            if (\"deltaY\" in e) pY = e.deltaY;\n            if (\"deltaX\" in e) pX = e.deltaX;\n            if (e.shiftKey && !pX) {\n                // if user scrolls with shift he wants horizontal scroll\n                pX = pY;\n                pY = 0;\n            }\n            if ((pX || pY) && e.deltaMode) {\n                if (e.deltaMode === 1) {\n                    // delta in LINE units\n                    pX *= LINE_HEIGHT;\n                    pY *= LINE_HEIGHT;\n                } else {\n                    // delta in PAGE units\n                    pX *= PAGE_HEIGHT;\n                    pY *= PAGE_HEIGHT;\n                }\n            }\n            // Fall-back if spin cannot be determined\n            if (pX && !sX) sX = pX < 1 ? -1 : 1;\n            if (pY && !sY) sY = pY < 1 ? -1 : 1;\n            return {\n                spinX: sX,\n                spinY: sY,\n                pixelX: pX,\n                pixelY: pY\n            };\n        }\n        function handleMouseEnter() {\n            if (!swiper.enabled) return;\n            swiper.mouseEntered = true;\n        }\n        function handleMouseLeave() {\n            if (!swiper.enabled) return;\n            swiper.mouseEntered = false;\n        }\n        function animateSlider(newEvent) {\n            if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) // Prevent if delta of wheel scroll delta is below configured threshold\n            return false;\n            if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) // Prevent if time between scrolls is below configured threshold\n            return false;\n            // If the movement is NOT big enough and\n            // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n            //   Don't go any further (avoid insignificant scroll movement).\n            if (newEvent.delta >= 6 && now() - lastScrollTime < 60) // Return false as a default\n            return true;\n            // If user is scrolling towards the end:\n            //   If the slider hasn't hit the latest slide or\n            //   if the slider is a loop and\n            //   if the slider isn't moving right now:\n            //     Go to next slide and\n            //     emit a scroll event.\n            // Else (the user is scrolling towards the beginning) and\n            // if the slider hasn't hit the first slide or\n            // if the slider is a loop and\n            // if the slider isn't moving right now:\n            //   Go to prev slide and\n            //   emit a scroll event.\n            if (newEvent.direction < 0) {\n                if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n                    swiper.slideNext();\n                    emit(\"scroll\", newEvent.raw);\n                }\n            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n                swiper.slidePrev();\n                emit(\"scroll\", newEvent.raw);\n            }\n            // If you got here is because an animation has been triggered so store the current time\n            lastScrollTime = new window1.Date().getTime();\n            // Return false as a default\n            return false;\n        }\n        function releaseScroll(newEvent) {\n            const params = swiper.params.mousewheel;\n            if (newEvent.direction < 0) {\n                if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) // Return true to animate scroll on edges\n                return true;\n            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) // Return true to animate scroll on edges\n            return true;\n            return false;\n        }\n        function handle(event1) {\n            let e = event1;\n            let disableParentSwiper = true;\n            if (!swiper.enabled) return;\n            // Ignore event if the target or its parents have the swiper-no-mousewheel class\n            if (event1.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n            const params = swiper.params.mousewheel;\n            if (swiper.params.cssMode) e.preventDefault();\n            let targetEl = swiper.el;\n            if (swiper.params.mousewheel.eventsTarget !== \"container\") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n            const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n            if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n            if (e.originalEvent) e = e.originalEvent; // jquery fix\n            let delta = 0;\n            const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n            const data = normalize(e);\n            if (params.forceToAxis) {\n                if (swiper.isHorizontal()) {\n                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n                    else return true;\n                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n                else return true;\n            } else delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n            if (delta === 0) return true;\n            if (params.invert) delta = -delta;\n            // Get the scroll positions\n            let positions = swiper.getTranslate() + delta * params.sensitivity;\n            if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n            if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n            // When loop is true:\n            //     the disableParentSwiper will be true.\n            // When loop is false:\n            //     if the scroll positions is not on edge,\n            //     then the disableParentSwiper will be true.\n            //     if the scroll on edge positions,\n            //     then the disableParentSwiper will be false.\n            disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n            if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n            if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n                // Register the new event in a variable which stores the relevant data\n                const newEvent = {\n                    time: now(),\n                    delta: Math.abs(delta),\n                    direction: Math.sign(delta),\n                    raw: event1\n                };\n                // Keep the most recent events\n                if (recentWheelEvents.length >= 2) recentWheelEvents.shift(); // only store the last N events\n                const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n                recentWheelEvents.push(newEvent);\n                // If there is at least one previous recorded event:\n                //   If direction has changed or\n                //   if the scroll is quicker than the previous one:\n                //     Animate the slider.\n                // Else (this is the first time the wheel is moved):\n                //     Animate the slider.\n                if (prevEvent) {\n                    if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) animateSlider(newEvent);\n                } else animateSlider(newEvent);\n                // If it's time to release the scroll:\n                //   Return now so you don't hit the preventDefault.\n                if (releaseScroll(newEvent)) return true;\n            } else {\n                // Freemode or scrollContainer:\n                // If we recently snapped after a momentum scroll, then ignore wheel events\n                // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n                // or if it's a new scroll (larger delta or inverse sign as last event before\n                // an end-of-momentum snap).\n                const newEvent = {\n                    time: now(),\n                    delta: Math.abs(delta),\n                    direction: Math.sign(delta)\n                };\n                const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n                if (!ignoreWheelEvents) {\n                    lastEventBeforeSnap = undefined;\n                    let position = swiper.getTranslate() + delta * params.sensitivity;\n                    const wasBeginning = swiper.isBeginning;\n                    const wasEnd = swiper.isEnd;\n                    if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n                    if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n                    swiper.setTransition(0);\n                    swiper.setTranslate(position);\n                    swiper.updateProgress();\n                    swiper.updateActiveIndex();\n                    swiper.updateSlidesClasses();\n                    if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) swiper.updateSlidesClasses();\n                    if (swiper.params.loop) swiper.loopFix({\n                        direction: newEvent.direction < 0 ? \"next\" : \"prev\",\n                        byMousewheel: true\n                    });\n                    if (swiper.params.freeMode.sticky) {\n                        // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n                        // the end of a momentum scroll by storing recent (N=15?) wheel events.\n                        // 1. do all N events have decreasing or same (absolute value) delta?\n                        // 2. did all N events arrive in the last M (M=500?) msecs?\n                        // 3. does the earliest event have an (absolute value) delta that's\n                        //    at least P (P=1?) larger than the most recent event's delta?\n                        // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n                        // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n                        // Snap immediately and ignore remaining wheel events in this scroll.\n                        // See comment above for \"remaining wheel events in this scroll\" determination.\n                        // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n                        clearTimeout(timeout);\n                        timeout = undefined;\n                        if (recentWheelEvents.length >= 15) recentWheelEvents.shift(); // only store the last N events\n                        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n                        const firstEvent = recentWheelEvents[0];\n                        recentWheelEvents.push(newEvent);\n                        if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n                        recentWheelEvents.splice(0);\n                        else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n                            // We're at the end of the deceleration of a momentum scroll, so there's no need\n                            // to wait for more events. Snap ASAP on the next tick.\n                            // Also, because there's some remaining momentum we'll bias the snap in the\n                            // direction of the ongoing scroll because it's better UX for the scroll to snap\n                            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n                            // if it's already scrolled more than 20% in the current direction, keep going.\n                            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n                            lastEventBeforeSnap = newEvent;\n                            recentWheelEvents.splice(0);\n                            timeout = nextTick(()=>{\n                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                            }, 0); // no delay; move on next tick\n                        }\n                        if (!timeout) // if we get here, then we haven't detected the end of a momentum scroll, so\n                        // we'll consider a scroll \"complete\" when there haven't been any wheel events\n                        // for 500ms.\n                        timeout = nextTick(()=>{\n                            const snapToThreshold = 0.5;\n                            lastEventBeforeSnap = newEvent;\n                            recentWheelEvents.splice(0);\n                            swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n                        }, 500);\n                    }\n                    // Emit event\n                    if (!ignoreWheelEvents) emit(\"scroll\", e);\n                    // Stop autoplay\n                    if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n                    // Return page scroll on edge positions\n                    if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) return true;\n                }\n            }\n            if (e.preventDefault) e.preventDefault();\n            else e.returnValue = false;\n            return false;\n        }\n        function events(method) {\n            let targetEl = swiper.el;\n            if (swiper.params.mousewheel.eventsTarget !== \"container\") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n            targetEl[method](\"mouseenter\", handleMouseEnter);\n            targetEl[method](\"mouseleave\", handleMouseLeave);\n            targetEl[method](\"wheel\", handle);\n        }\n        function enable() {\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.removeEventListener(\"wheel\", handle);\n                return true;\n            }\n            if (swiper.mousewheel.enabled) return false;\n            events(\"addEventListener\");\n            swiper.mousewheel.enabled = true;\n            return true;\n        }\n        function disable() {\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.addEventListener(event, handle);\n                return true;\n            }\n            if (!swiper.mousewheel.enabled) return false;\n            events(\"removeEventListener\");\n            swiper.mousewheel.enabled = false;\n            return true;\n        }\n        on(\"init\", ()=>{\n            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) disable();\n            if (swiper.params.mousewheel.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.cssMode) enable();\n            if (swiper.mousewheel.enabled) disable();\n        });\n        Object.assign(swiper.mousewheel, {\n            enable: enable,\n            disable: disable\n        });\n    }\n    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n        if (swiper.params.createElements) Object.keys(checkProps).forEach((key)=>{\n            if (!params[key] && params.auto === true) {\n                let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n                if (!element) {\n                    element = createElement(\"div\", checkProps[key]);\n                    element.className = checkProps[key];\n                    swiper.el.append(element);\n                }\n                params[key] = element;\n                originalParams[key] = element;\n            }\n        });\n        return params;\n    }\n    function Navigation(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        extendParams({\n            navigation: {\n                nextEl: null,\n                prevEl: null,\n                hideOnClick: false,\n                disabledClass: \"swiper-button-disabled\",\n                hiddenClass: \"swiper-button-hidden\",\n                lockClass: \"swiper-button-lock\",\n                navigationDisabledClass: \"swiper-navigation-disabled\"\n            }\n        });\n        swiper.navigation = {\n            nextEl: null,\n            prevEl: null\n        };\n        const makeElementsArray = (el)=>(Array.isArray(el) ? el : [\n                el\n            ]).filter((e)=>!!e);\n        function getEl(el) {\n            let res;\n            if (el && typeof el === \"string\" && swiper.isElement) {\n                res = swiper.el.querySelector(el);\n                if (res) return res;\n            }\n            if (el) {\n                if (typeof el === \"string\") res = [\n                    ...document.querySelectorAll(el)\n                ];\n                if (swiper.params.uniqueNavElements && typeof el === \"string\" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el);\n            }\n            if (el && !res) return el;\n            // if (Array.isArray(res) && res.length === 1) res = res[0];\n            return res;\n        }\n        function toggleEl(el, disabled) {\n            const params = swiper.params.navigation;\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                if (subEl) {\n                    subEl.classList[disabled ? \"add\" : \"remove\"](...params.disabledClass.split(\" \"));\n                    if (subEl.tagName === \"BUTTON\") subEl.disabled = disabled;\n                    if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n                }\n            });\n        }\n        function update() {\n            // Update Navigation Buttons\n            const { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            if (swiper.params.loop) {\n                toggleEl(prevEl, false);\n                toggleEl(nextEl, false);\n                return;\n            }\n            toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n            toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n        }\n        function onPrevClick(e) {\n            e.preventDefault();\n            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slidePrev();\n            emit(\"navigationPrev\");\n        }\n        function onNextClick(e) {\n            e.preventDefault();\n            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n            swiper.slideNext();\n            emit(\"navigationNext\");\n        }\n        function init() {\n            const params = swiper.params.navigation;\n            swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n                nextEl: \"swiper-button-next\",\n                prevEl: \"swiper-button-prev\"\n            });\n            if (!(params.nextEl || params.prevEl)) return;\n            let nextEl = getEl(params.nextEl);\n            let prevEl = getEl(params.prevEl);\n            Object.assign(swiper.navigation, {\n                nextEl: nextEl,\n                prevEl: prevEl\n            });\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const initButton = (el, dir)=>{\n                if (el) el.addEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n                if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(\" \"));\n            };\n            nextEl.forEach((el)=>initButton(el, \"next\"));\n            prevEl.forEach((el)=>initButton(el, \"prev\"));\n        }\n        function destroy() {\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const destroyButton = (el, dir)=>{\n                el.removeEventListener(\"click\", dir === \"next\" ? onNextClick : onPrevClick);\n                el.classList.remove(...swiper.params.navigation.disabledClass.split(\" \"));\n            };\n            nextEl.forEach((el)=>destroyButton(el, \"next\"));\n            prevEl.forEach((el)=>destroyButton(el, \"prev\"));\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.navigation.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                update();\n            }\n        });\n        on(\"toEdge fromEdge lock unlock\", ()=>{\n            update();\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        on(\"enable disable\", ()=>{\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            [\n                ...nextEl,\n                ...prevEl\n            ].filter((el)=>!!el).forEach((el)=>el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.navigation.lockClass));\n        });\n        on(\"click\", (_s, e)=>{\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            const targetEl = e.target;\n            if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n                let isHidden;\n                if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n                else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n                if (isHidden === true) emit(\"navigationShow\");\n                else emit(\"navigationHide\");\n                [\n                    ...nextEl,\n                    ...prevEl\n                ].filter((el)=>!!el).forEach((el)=>el.classList.toggle(swiper.params.navigation.hiddenClass));\n            }\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n            init();\n            update();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(\" \"));\n            destroy();\n        };\n        Object.assign(swiper.navigation, {\n            enable: enable,\n            disable: disable,\n            update: update,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function classesToSelector(classes) {\n        if (classes === void 0) classes = \"\";\n        return `.${classes.trim().replace(/([\\.:!+\\/])/g, \"\\\\$1\") // eslint-disable-line\n        .replace(/ /g, \".\")}`;\n    }\n    function Pagination(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const pfx = \"swiper-pagination\";\n        extendParams({\n            pagination: {\n                el: null,\n                bulletElement: \"span\",\n                clickable: false,\n                hideOnClick: false,\n                renderBullet: null,\n                renderProgressbar: null,\n                renderFraction: null,\n                renderCustom: null,\n                progressbarOpposite: false,\n                type: \"bullets\",\n                // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n                dynamicBullets: false,\n                dynamicMainBullets: 1,\n                formatFractionCurrent: (number)=>number,\n                formatFractionTotal: (number)=>number,\n                bulletClass: `${pfx}-bullet`,\n                bulletActiveClass: `${pfx}-bullet-active`,\n                modifierClass: `${pfx}-`,\n                currentClass: `${pfx}-current`,\n                totalClass: `${pfx}-total`,\n                hiddenClass: `${pfx}-hidden`,\n                progressbarFillClass: `${pfx}-progressbar-fill`,\n                progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n                clickableClass: `${pfx}-clickable`,\n                lockClass: `${pfx}-lock`,\n                horizontalClass: `${pfx}-horizontal`,\n                verticalClass: `${pfx}-vertical`,\n                paginationDisabledClass: `${pfx}-disabled`\n            }\n        });\n        swiper.pagination = {\n            el: null,\n            bullets: []\n        };\n        let bulletSize;\n        let dynamicBulletIndex = 0;\n        const makeElementsArray = (el)=>(Array.isArray(el) ? el : [\n                el\n            ]).filter((e)=>!!e);\n        function isPaginationDisabled() {\n            return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n        }\n        function setSideBullets(bulletEl, position) {\n            const { bulletActiveClass: bulletActiveClass } = swiper.params.pagination;\n            if (!bulletEl) return;\n            bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n            if (bulletEl) {\n                bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n                bulletEl = bulletEl[`${position === \"prev\" ? \"previous\" : \"next\"}ElementSibling`];\n                if (bulletEl) bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n            }\n        }\n        function onBulletClick(e) {\n            const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n            if (!bulletEl) return;\n            e.preventDefault();\n            const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n            if (swiper.params.loop) {\n                if (swiper.realIndex === index) return;\n                const newSlideIndex = swiper.getSlideIndexByData(index);\n                const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n                if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) swiper.loopFix({\n                    direction: newSlideIndex > currentSlideIndex ? \"next\" : \"prev\",\n                    activeSlideIndex: newSlideIndex,\n                    slideTo: false\n                });\n                swiper.slideToLoop(index);\n            } else swiper.slideTo(index);\n        }\n        function update() {\n            // Render || Update Pagination bullets/items\n            const rtl = swiper.rtl;\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            let el = swiper.pagination.el;\n            el = makeElementsArray(el);\n            // Current/Total\n            let current;\n            let previousIndex;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n            const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n            if (swiper.params.loop) {\n                previousIndex = swiper.previousRealIndex || 0;\n                current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n            } else if (typeof swiper.snapIndex !== \"undefined\") {\n                current = swiper.snapIndex;\n                previousIndex = swiper.previousSnapIndex;\n            } else {\n                previousIndex = swiper.previousIndex || 0;\n                current = swiper.activeIndex || 0;\n            }\n            // Types\n            if (params.type === \"bullets\" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n                const bullets = swiper.pagination.bullets;\n                let firstIndex;\n                let lastIndex;\n                let midIndex;\n                if (params.dynamicBullets) {\n                    bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? \"width\" : \"height\", true);\n                    el.forEach((subEl)=>{\n                        subEl.style[swiper.isHorizontal() ? \"width\" : \"height\"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n                    });\n                    if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n                        dynamicBulletIndex += current - (previousIndex || 0);\n                        if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1;\n                        else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;\n                    }\n                    firstIndex = Math.max(current - dynamicBulletIndex, 0);\n                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n                    midIndex = (lastIndex + firstIndex) / 2;\n                }\n                bullets.forEach((bulletEl)=>{\n                    const classesToRemove = [\n                        ...[\n                            \"\",\n                            \"-next\",\n                            \"-next-next\",\n                            \"-prev\",\n                            \"-prev-prev\",\n                            \"-main\"\n                        ].map((suffix)=>`${params.bulletActiveClass}${suffix}`)\n                    ].map((s)=>typeof s === \"string\" && s.includes(\" \") ? s.split(\" \") : s).flat();\n                    bulletEl.classList.remove(...classesToRemove);\n                });\n                if (el.length > 1) bullets.forEach((bullet)=>{\n                    const bulletIndex = elementIndex(bullet);\n                    if (bulletIndex === current) bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n                    else if (swiper.isElement) bullet.setAttribute(\"part\", \"bullet\");\n                    if (params.dynamicBullets) {\n                        if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) bullet.classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n                        if (bulletIndex === firstIndex) setSideBullets(bullet, \"prev\");\n                        if (bulletIndex === lastIndex) setSideBullets(bullet, \"next\");\n                    }\n                });\n                else {\n                    const bullet = bullets[current];\n                    if (bullet) bullet.classList.add(...params.bulletActiveClass.split(\" \"));\n                    if (swiper.isElement) bullets.forEach((bulletEl, bulletIndex)=>{\n                        bulletEl.setAttribute(\"part\", bulletIndex === current ? \"bullet-active\" : \"bullet\");\n                    });\n                    if (params.dynamicBullets) {\n                        const firstDisplayedBullet = bullets[firstIndex];\n                        const lastDisplayedBullet = bullets[lastIndex];\n                        for(let i = firstIndex; i <= lastIndex; i += 1)if (bullets[i]) bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(\" \"));\n                        setSideBullets(firstDisplayedBullet, \"prev\");\n                        setSideBullets(lastDisplayedBullet, \"next\");\n                    }\n                }\n                if (params.dynamicBullets) {\n                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n                    const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n                    const offsetProp = rtl ? \"right\" : \"left\";\n                    bullets.forEach((bullet)=>{\n                        bullet.style[swiper.isHorizontal() ? offsetProp : \"top\"] = `${bulletsOffset}px`;\n                    });\n                }\n            }\n            el.forEach((subEl, subElIndex)=>{\n                if (params.type === \"fraction\") {\n                    subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl)=>{\n                        fractionEl.textContent = params.formatFractionCurrent(current + 1);\n                    });\n                    subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl)=>{\n                        totalEl.textContent = params.formatFractionTotal(total);\n                    });\n                }\n                if (params.type === \"progressbar\") {\n                    let progressbarDirection;\n                    if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? \"vertical\" : \"horizontal\";\n                    else progressbarDirection = swiper.isHorizontal() ? \"horizontal\" : \"vertical\";\n                    const scale = (current + 1) / total;\n                    let scaleX = 1;\n                    let scaleY = 1;\n                    if (progressbarDirection === \"horizontal\") scaleX = scale;\n                    else scaleY = scale;\n                    subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl)=>{\n                        progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n                        progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n                    });\n                }\n                if (params.type === \"custom\" && params.renderCustom) {\n                    subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n                    if (subElIndex === 0) emit(\"paginationRender\", subEl);\n                } else {\n                    if (subElIndex === 0) emit(\"paginationRender\", subEl);\n                    emit(\"paginationUpdate\", subEl);\n                }\n                if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? \"add\" : \"remove\"](params.lockClass);\n            });\n        }\n        function render() {\n            // Render Container\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n            let el = swiper.pagination.el;\n            el = makeElementsArray(el);\n            let paginationHTML = \"\";\n            if (params.type === \"bullets\") {\n                let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n                if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) numberOfBullets = slidesLength;\n                for(let i = 0; i < numberOfBullets; i += 1)if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n                else // prettier-ignore\n                paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : \"\"} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n            }\n            if (params.type === \"fraction\") {\n                if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n                else paginationHTML = `<span class=\"${params.currentClass}\"></span>` + \" / \" + `<span class=\"${params.totalClass}\"></span>`;\n            }\n            if (params.type === \"progressbar\") {\n                if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n                else paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n            }\n            swiper.pagination.bullets = [];\n            el.forEach((subEl)=>{\n                if (params.type !== \"custom\") subEl.innerHTML = paginationHTML || \"\";\n                if (params.type === \"bullets\") swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n            });\n            if (params.type !== \"custom\") emit(\"paginationRender\", el[0]);\n        }\n        function init() {\n            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n                el: \"swiper-pagination\"\n            });\n            const params = swiper.params.pagination;\n            if (!params.el) return;\n            let el;\n            if (typeof params.el === \"string\" && swiper.isElement) el = swiper.el.querySelector(params.el);\n            if (!el && typeof params.el === \"string\") el = [\n                ...document.querySelectorAll(params.el)\n            ];\n            if (!el) el = params.el;\n            if (!el || el.length === 0) return;\n            if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && Array.isArray(el) && el.length > 1) {\n                el = [\n                    ...swiper.el.querySelectorAll(params.el)\n                ];\n                // check if it belongs to another nested Swiper\n                if (el.length > 1) el = el.filter((subEl)=>{\n                    if (elementParents(subEl, \".swiper\")[0] !== swiper.el) return false;\n                    return true;\n                })[0];\n            }\n            if (Array.isArray(el) && el.length === 1) el = el[0];\n            Object.assign(swiper.pagination, {\n                el: el\n            });\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                if (params.type === \"bullets\" && params.clickable) subEl.classList.add(params.clickableClass);\n                subEl.classList.add(params.modifierClass + params.type);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n                if (params.type === \"bullets\" && params.dynamicBullets) {\n                    subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n                    dynamicBulletIndex = 0;\n                    if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;\n                }\n                if (params.type === \"progressbar\" && params.progressbarOpposite) subEl.classList.add(params.progressbarOppositeClass);\n                if (params.clickable) subEl.addEventListener(\"click\", onBulletClick);\n                if (!swiper.enabled) subEl.classList.add(params.lockClass);\n            });\n        }\n        function destroy() {\n            const params = swiper.params.pagination;\n            if (isPaginationDisabled()) return;\n            let el = swiper.pagination.el;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>{\n                    subEl.classList.remove(params.hiddenClass);\n                    subEl.classList.remove(params.modifierClass + params.type);\n                    subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n                    if (params.clickable) subEl.removeEventListener(\"click\", onBulletClick);\n                });\n            }\n            if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl)=>subEl.classList.remove(...params.bulletActiveClass.split(\" \")));\n        }\n        on(\"changeDirection\", ()=>{\n            if (!swiper.pagination || !swiper.pagination.el) return;\n            const params = swiper.params.pagination;\n            let { el: el } = swiper.pagination;\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.classList.remove(params.horizontalClass, params.verticalClass);\n                subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            });\n        });\n        on(\"init\", ()=>{\n            if (swiper.params.pagination.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                render();\n                update();\n            }\n        });\n        on(\"activeIndexChange\", ()=>{\n            if (typeof swiper.snapIndex === \"undefined\") update();\n        });\n        on(\"snapIndexChange\", ()=>{\n            update();\n        });\n        on(\"snapGridLengthChange\", ()=>{\n            render();\n            update();\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        on(\"enable disable\", ()=>{\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.pagination.lockClass));\n            }\n        });\n        on(\"lock unlock\", ()=>{\n            update();\n        });\n        on(\"click\", (_s, e)=>{\n            const targetEl = e.target;\n            const el = makeElementsArray(swiper.pagination.el);\n            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n                const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n                if (isHidden === true) emit(\"paginationShow\");\n                else emit(\"paginationHide\");\n                el.forEach((subEl)=>subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n            }\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n            }\n            init();\n            render();\n            update();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n            let { el: el } = swiper.pagination;\n            if (el) {\n                el = makeElementsArray(el);\n                el.forEach((subEl)=>subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n            }\n            destroy();\n        };\n        Object.assign(swiper.pagination, {\n            enable: enable,\n            disable: disable,\n            render: render,\n            update: update,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function Scrollbar(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const document1 = getDocument();\n        let isTouched = false;\n        let timeout = null;\n        let dragTimeout = null;\n        let dragStartPos;\n        let dragSize;\n        let trackSize;\n        let divider;\n        extendParams({\n            scrollbar: {\n                el: null,\n                dragSize: \"auto\",\n                hide: false,\n                draggable: false,\n                snapOnRelease: true,\n                lockClass: \"swiper-scrollbar-lock\",\n                dragClass: \"swiper-scrollbar-drag\",\n                scrollbarDisabledClass: \"swiper-scrollbar-disabled\",\n                horizontalClass: `swiper-scrollbar-horizontal`,\n                verticalClass: `swiper-scrollbar-vertical`\n            }\n        });\n        swiper.scrollbar = {\n            el: null,\n            dragEl: null\n        };\n        function setTranslate() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            const { scrollbar: scrollbar, rtlTranslate: rtl } = swiper;\n            const { dragEl: dragEl, el: el } = scrollbar;\n            const params = swiper.params.scrollbar;\n            const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n            let newSize = dragSize;\n            let newPos = (trackSize - dragSize) * progress;\n            if (rtl) {\n                newPos = -newPos;\n                if (newPos > 0) {\n                    newSize = dragSize - newPos;\n                    newPos = 0;\n                } else if (-newPos + dragSize > trackSize) newSize = trackSize + newPos;\n            } else if (newPos < 0) {\n                newSize = dragSize + newPos;\n                newPos = 0;\n            } else if (newPos + dragSize > trackSize) newSize = trackSize - newPos;\n            if (swiper.isHorizontal()) {\n                dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n                dragEl.style.width = `${newSize}px`;\n            } else {\n                dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n                dragEl.style.height = `${newSize}px`;\n            }\n            if (params.hide) {\n                clearTimeout(timeout);\n                el.style.opacity = 1;\n                timeout = setTimeout(()=>{\n                    el.style.opacity = 0;\n                    el.style.transitionDuration = \"400ms\";\n                }, 1000);\n            }\n        }\n        function setTransition(duration) {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n        }\n        function updateSize() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            const { scrollbar: scrollbar } = swiper;\n            const { dragEl: dragEl, el: el } = scrollbar;\n            dragEl.style.width = \"\";\n            dragEl.style.height = \"\";\n            trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n            divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n            if (swiper.params.scrollbar.dragSize === \"auto\") dragSize = trackSize * divider;\n            else dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n            if (swiper.isHorizontal()) dragEl.style.width = `${dragSize}px`;\n            else dragEl.style.height = `${dragSize}px`;\n            if (divider >= 1) el.style.display = \"none\";\n            else el.style.display = \"\";\n            if (swiper.params.scrollbar.hide) el.style.opacity = 0;\n            if (swiper.params.watchOverflow && swiper.enabled) scrollbar.el.classList[swiper.isLocked ? \"add\" : \"remove\"](swiper.params.scrollbar.lockClass);\n        }\n        function getPointerPosition(e) {\n            return swiper.isHorizontal() ? e.clientX : e.clientY;\n        }\n        function setDragPosition(e) {\n            const { scrollbar: scrollbar, rtlTranslate: rtl } = swiper;\n            const { el: el } = scrollbar;\n            let positionRatio;\n            positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? \"left\" : \"top\"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n            positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n            if (rtl) positionRatio = 1 - positionRatio;\n            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n            swiper.updateProgress(position);\n            swiper.setTranslate(position);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        function onDragStart(e) {\n            const params = swiper.params.scrollbar;\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el, dragEl: dragEl } = scrollbar;\n            isTouched = true;\n            dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? \"left\" : \"top\"] : null;\n            e.preventDefault();\n            e.stopPropagation();\n            wrapperEl.style.transitionDuration = \"100ms\";\n            dragEl.style.transitionDuration = \"100ms\";\n            setDragPosition(e);\n            clearTimeout(dragTimeout);\n            el.style.transitionDuration = \"0ms\";\n            if (params.hide) el.style.opacity = 1;\n            if (swiper.params.cssMode) swiper.wrapperEl.style[\"scroll-snap-type\"] = \"none\";\n            emit(\"scrollbarDragStart\", e);\n        }\n        function onDragMove(e) {\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el, dragEl: dragEl } = scrollbar;\n            if (!isTouched) return;\n            if (e.preventDefault) e.preventDefault();\n            else e.returnValue = false;\n            setDragPosition(e);\n            wrapperEl.style.transitionDuration = \"0ms\";\n            el.style.transitionDuration = \"0ms\";\n            dragEl.style.transitionDuration = \"0ms\";\n            emit(\"scrollbarDragMove\", e);\n        }\n        function onDragEnd(e) {\n            const params = swiper.params.scrollbar;\n            const { scrollbar: scrollbar, wrapperEl: wrapperEl } = swiper;\n            const { el: el } = scrollbar;\n            if (!isTouched) return;\n            isTouched = false;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style[\"scroll-snap-type\"] = \"\";\n                wrapperEl.style.transitionDuration = \"\";\n            }\n            if (params.hide) {\n                clearTimeout(dragTimeout);\n                dragTimeout = nextTick(()=>{\n                    el.style.opacity = 0;\n                    el.style.transitionDuration = \"400ms\";\n                }, 1000);\n            }\n            emit(\"scrollbarDragEnd\", e);\n            if (params.snapOnRelease) swiper.slideToClosest();\n        }\n        function events(method) {\n            const { scrollbar: scrollbar, params: params } = swiper;\n            const el = scrollbar.el;\n            if (!el) return;\n            const target = el;\n            const activeListener = params.passiveListeners ? {\n                passive: false,\n                capture: false\n            } : false;\n            const passiveListener = params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            if (!target) return;\n            const eventMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n            target[eventMethod](\"pointerdown\", onDragStart, activeListener);\n            document1[eventMethod](\"pointermove\", onDragMove, activeListener);\n            document1[eventMethod](\"pointerup\", onDragEnd, passiveListener);\n        }\n        function enableDraggable() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            events(\"on\");\n        }\n        function disableDraggable() {\n            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n            events(\"off\");\n        }\n        function init() {\n            const { scrollbar: scrollbar, el: swiperEl } = swiper;\n            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n                el: \"swiper-scrollbar\"\n            });\n            const params = swiper.params.scrollbar;\n            if (!params.el) return;\n            let el;\n            if (typeof params.el === \"string\" && swiper.isElement) el = swiper.el.querySelector(params.el);\n            if (!el && typeof params.el === \"string\") el = document1.querySelectorAll(params.el);\n            else if (!el) el = params.el;\n            if (swiper.params.uniqueNavElements && typeof params.el === \"string\" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) el = swiperEl.querySelector(params.el);\n            if (el.length > 0) el = el[0];\n            el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            let dragEl;\n            if (el) {\n                dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n                if (!dragEl) {\n                    dragEl = createElement(\"div\", swiper.params.scrollbar.dragClass);\n                    el.append(dragEl);\n                }\n            }\n            Object.assign(scrollbar, {\n                el: el,\n                dragEl: dragEl\n            });\n            if (params.draggable) enableDraggable();\n            if (el) el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n        }\n        function destroy() {\n            const params = swiper.params.scrollbar;\n            const el = swiper.scrollbar.el;\n            if (el) el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n            disableDraggable();\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.scrollbar.enabled === false) // eslint-disable-next-line\n            disable();\n            else {\n                init();\n                updateSize();\n                setTranslate();\n            }\n        });\n        on(\"update resize observerUpdate lock unlock\", ()=>{\n            updateSize();\n        });\n        on(\"setTranslate\", ()=>{\n            setTranslate();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            setTransition(duration);\n        });\n        on(\"enable disable\", ()=>{\n            const { el: el } = swiper.scrollbar;\n            if (el) el.classList[swiper.enabled ? \"remove\" : \"add\"](swiper.params.scrollbar.lockClass);\n        });\n        on(\"destroy\", ()=>{\n            destroy();\n        });\n        const enable = ()=>{\n            swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n            if (swiper.scrollbar.el) swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n            init();\n            updateSize();\n            setTranslate();\n        };\n        const disable = ()=>{\n            swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n            if (swiper.scrollbar.el) swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n            destroy();\n        };\n        Object.assign(swiper.scrollbar, {\n            enable: enable,\n            disable: disable,\n            updateSize: updateSize,\n            setTranslate: setTranslate,\n            init: init,\n            destroy: destroy\n        });\n    }\n    function Parallax(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            parallax: {\n                enabled: false\n            }\n        });\n        const setTransform = (el, progress)=>{\n            const { rtl: rtl } = swiper;\n            const rtlFactor = rtl ? -1 : 1;\n            const p = el.getAttribute(\"data-swiper-parallax\") || \"0\";\n            let x = el.getAttribute(\"data-swiper-parallax-x\");\n            let y = el.getAttribute(\"data-swiper-parallax-y\");\n            const scale = el.getAttribute(\"data-swiper-parallax-scale\");\n            const opacity = el.getAttribute(\"data-swiper-parallax-opacity\");\n            const rotate = el.getAttribute(\"data-swiper-parallax-rotate\");\n            if (x || y) {\n                x = x || \"0\";\n                y = y || \"0\";\n            } else if (swiper.isHorizontal()) {\n                x = p;\n                y = \"0\";\n            } else {\n                y = p;\n                x = \"0\";\n            }\n            if (x.indexOf(\"%\") >= 0) x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n            else x = `${x * progress * rtlFactor}px`;\n            if (y.indexOf(\"%\") >= 0) y = `${parseInt(y, 10) * progress}%`;\n            else y = `${y * progress}px`;\n            if (typeof opacity !== \"undefined\" && opacity !== null) {\n                const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n                el.style.opacity = currentOpacity;\n            }\n            let transform = `translate3d(${x}, ${y}, 0px)`;\n            if (typeof scale !== \"undefined\" && scale !== null) {\n                const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n                transform += ` scale(${currentScale})`;\n            }\n            if (rotate && typeof rotate !== \"undefined\" && rotate !== null) {\n                const currentRotate = rotate * progress * -1;\n                transform += ` rotate(${currentRotate}deg)`;\n            }\n            el.style.transform = transform;\n        };\n        const setTranslate = ()=>{\n            const { el: el, slides: slides, progress: progress, snapGrid: snapGrid } = swiper;\n            elementChildren(el, \"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((subEl)=>{\n                setTransform(subEl, progress);\n            });\n            slides.forEach((slideEl, slideIndex)=>{\n                let slideProgress = slideEl.progress;\n                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== \"auto\") slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n                slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n                slideEl.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]\").forEach((subEl)=>{\n                    setTransform(subEl, slideProgress);\n                });\n            });\n        };\n        const setTransition = function(duration) {\n            if (duration === void 0) duration = swiper.params.speed;\n            const { el: el } = swiper;\n            el.querySelectorAll(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").forEach((parallaxEl)=>{\n                let parallaxDuration = parseInt(parallaxEl.getAttribute(\"data-swiper-parallax-duration\"), 10) || duration;\n                if (duration === 0) parallaxDuration = 0;\n                parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n            });\n        };\n        on(\"beforeInit\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            swiper.params.watchSlidesProgress = true;\n            swiper.originalParams.watchSlidesProgress = true;\n        });\n        on(\"init\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTranslate();\n        });\n        on(\"setTranslate\", ()=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTranslate();\n        });\n        on(\"setTransition\", (_swiper, duration)=>{\n            if (!swiper.params.parallax.enabled) return;\n            setTransition(duration);\n        });\n    }\n    function Zoom(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit } = _ref;\n        const window1 = getWindow();\n        extendParams({\n            zoom: {\n                enabled: false,\n                maxRatio: 3,\n                minRatio: 1,\n                toggle: true,\n                containerClass: \"swiper-zoom-container\",\n                zoomedSlideClass: \"swiper-slide-zoomed\"\n            }\n        });\n        swiper.zoom = {\n            enabled: false\n        };\n        let currentScale = 1;\n        let isScaling = false;\n        let fakeGestureTouched;\n        let fakeGestureMoved;\n        const evCache = [];\n        const gesture = {\n            originX: 0,\n            originY: 0,\n            slideEl: undefined,\n            slideWidth: undefined,\n            slideHeight: undefined,\n            imageEl: undefined,\n            imageWrapEl: undefined,\n            maxRatio: 3\n        };\n        const image = {\n            isTouched: undefined,\n            isMoved: undefined,\n            currentX: undefined,\n            currentY: undefined,\n            minX: undefined,\n            minY: undefined,\n            maxX: undefined,\n            maxY: undefined,\n            width: undefined,\n            height: undefined,\n            startX: undefined,\n            startY: undefined,\n            touchesStart: {},\n            touchesCurrent: {}\n        };\n        const velocity = {\n            x: undefined,\n            y: undefined,\n            prevPositionX: undefined,\n            prevPositionY: undefined,\n            prevTime: undefined\n        };\n        let scale = 1;\n        Object.defineProperty(swiper.zoom, \"scale\", {\n            get () {\n                return scale;\n            },\n            set (value) {\n                if (scale !== value) {\n                    const imageEl = gesture.imageEl;\n                    const slideEl = gesture.slideEl;\n                    emit(\"zoomChange\", value, imageEl, slideEl);\n                }\n                scale = value;\n            }\n        });\n        function getDistanceBetweenTouches() {\n            if (evCache.length < 2) return 1;\n            const x1 = evCache[0].pageX;\n            const y1 = evCache[0].pageY;\n            const x2 = evCache[1].pageX;\n            const y2 = evCache[1].pageY;\n            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n            return distance;\n        }\n        function getScaleOrigin() {\n            if (evCache.length < 2) return {\n                x: null,\n                y: null\n            };\n            const box = gesture.imageEl.getBoundingClientRect();\n            return [\n                (evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale,\n                (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale\n            ];\n        }\n        function getSlideSelector() {\n            return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n        }\n        function eventWithinSlide(e) {\n            const slideSelector = getSlideSelector();\n            if (e.target.matches(slideSelector)) return true;\n            if (swiper.slides.filter((slideEl)=>slideEl.contains(e.target)).length > 0) return true;\n            return false;\n        }\n        function eventWithinZoomContainer(e) {\n            const selector = `.${swiper.params.zoom.containerClass}`;\n            if (e.target.matches(selector)) return true;\n            if ([\n                ...swiper.hostEl.querySelectorAll(selector)\n            ].filter((containerEl)=>containerEl.contains(e.target)).length > 0) return true;\n            return false;\n        }\n        // Events\n        function onGestureStart(e) {\n            if (e.pointerType === \"mouse\") evCache.splice(0, evCache.length);\n            if (!eventWithinSlide(e)) return;\n            const params = swiper.params.zoom;\n            fakeGestureTouched = false;\n            fakeGestureMoved = false;\n            evCache.push(e);\n            if (evCache.length < 2) return;\n            fakeGestureTouched = true;\n            gesture.scaleStart = getDistanceBetweenTouches();\n            if (!gesture.slideEl) {\n                gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n                if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n                if (!gesture.imageWrapEl) {\n                    gesture.imageEl = undefined;\n                    return;\n                }\n                gesture.maxRatio = gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            }\n            if (gesture.imageEl) {\n                const [originX, originY] = getScaleOrigin();\n                gesture.originX = originX;\n                gesture.originY = originY;\n                gesture.imageEl.style.transitionDuration = \"0ms\";\n            }\n            isScaling = true;\n        }\n        function onGestureChange(e) {\n            if (!eventWithinSlide(e)) return;\n            const params = swiper.params.zoom;\n            const zoom = swiper.zoom;\n            const pointerIndex = evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n            if (pointerIndex >= 0) evCache[pointerIndex] = e;\n            if (evCache.length < 2) return;\n            fakeGestureMoved = true;\n            gesture.scaleMove = getDistanceBetweenTouches();\n            if (!gesture.imageEl) return;\n            zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n            if (zoom.scale > gesture.maxRatio) zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n            if (zoom.scale < params.minRatio) zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        }\n        function onGestureEnd(e) {\n            if (!eventWithinSlide(e)) return;\n            if (e.pointerType === \"mouse\" && e.type === \"pointerout\") return;\n            const params = swiper.params.zoom;\n            const zoom = swiper.zoom;\n            const pointerIndex = evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);\n            if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n            if (!fakeGestureTouched || !fakeGestureMoved) return;\n            fakeGestureTouched = false;\n            fakeGestureMoved = false;\n            if (!gesture.imageEl) return;\n            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n            gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n            currentScale = zoom.scale;\n            isScaling = false;\n            if (zoom.scale > 1 && gesture.slideEl) gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n            else if (zoom.scale <= 1 && gesture.slideEl) gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n            if (zoom.scale === 1) {\n                gesture.originX = 0;\n                gesture.originY = 0;\n                gesture.slideEl = undefined;\n            }\n        }\n        function onTouchStart(e) {\n            const device = swiper.device;\n            if (!gesture.imageEl) return;\n            if (image.isTouched) return;\n            if (device.android && e.cancelable) e.preventDefault();\n            image.isTouched = true;\n            const event1 = evCache.length > 0 ? evCache[0] : e;\n            image.touchesStart.x = event1.pageX;\n            image.touchesStart.y = event1.pageY;\n        }\n        function onTouchMove(e) {\n            if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n            const zoom = swiper.zoom;\n            if (!gesture.imageEl) return;\n            if (!image.isTouched || !gesture.slideEl) return;\n            if (!image.isMoved) {\n                image.width = gesture.imageEl.offsetWidth;\n                image.height = gesture.imageEl.offsetHeight;\n                image.startX = getTranslate(gesture.imageWrapEl, \"x\") || 0;\n                image.startY = getTranslate(gesture.imageWrapEl, \"y\") || 0;\n                gesture.slideWidth = gesture.slideEl.offsetWidth;\n                gesture.slideHeight = gesture.slideEl.offsetHeight;\n                gesture.imageWrapEl.style.transitionDuration = \"0ms\";\n            }\n            // Define if we need image drag\n            const scaledWidth = image.width * zoom.scale;\n            const scaledHeight = image.height * zoom.scale;\n            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n            image.maxX = -image.minX;\n            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n            image.maxY = -image.minY;\n            image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n            image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n            const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n            if (touchesDiff > 5) swiper.allowClick = false;\n            if (!image.isMoved && !isScaling) {\n                if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n                    image.isTouched = false;\n                    return;\n                }\n                if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n                    image.isTouched = false;\n                    return;\n                }\n            }\n            if (e.cancelable) e.preventDefault();\n            e.stopPropagation();\n            image.isMoved = true;\n            const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n            const { originX: originX, originY: originY } = gesture;\n            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n            if (image.currentX < image.minX) image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n            if (image.currentX > image.maxX) image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n            if (image.currentY < image.minY) image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n            if (image.currentY > image.maxY) image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n            // Velocity\n            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n            if (!velocity.prevTime) velocity.prevTime = Date.now();\n            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n            velocity.prevPositionX = image.touchesCurrent.x;\n            velocity.prevPositionY = image.touchesCurrent.y;\n            velocity.prevTime = Date.now();\n            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n        }\n        function onTouchEnd() {\n            const zoom = swiper.zoom;\n            if (!gesture.imageEl) return;\n            if (!image.isTouched || !image.isMoved) {\n                image.isTouched = false;\n                image.isMoved = false;\n                return;\n            }\n            image.isTouched = false;\n            image.isMoved = false;\n            let momentumDurationX = 300;\n            let momentumDurationY = 300;\n            const momentumDistanceX = velocity.x * momentumDurationX;\n            const newPositionX = image.currentX + momentumDistanceX;\n            const momentumDistanceY = velocity.y * momentumDurationY;\n            const newPositionY = image.currentY + momentumDistanceY;\n            // Fix duration\n            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n            image.currentX = newPositionX;\n            image.currentY = newPositionY;\n            // Define if we need image drag\n            const scaledWidth = image.width * zoom.scale;\n            const scaledHeight = image.height * zoom.scale;\n            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n            image.maxX = -image.minX;\n            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n            image.maxY = -image.minY;\n            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n            gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n            gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n        }\n        function onTransitionEnd() {\n            const zoom = swiper.zoom;\n            if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n                if (gesture.imageEl) gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n                if (gesture.imageWrapEl) gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n                gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n                zoom.scale = 1;\n                currentScale = 1;\n                gesture.slideEl = undefined;\n                gesture.imageEl = undefined;\n                gesture.imageWrapEl = undefined;\n                gesture.originX = 0;\n                gesture.originY = 0;\n            }\n        }\n        function zoomIn(e) {\n            const zoom = swiper.zoom;\n            const params = swiper.params.zoom;\n            if (!gesture.slideEl) {\n                if (e && e.target) gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n                if (!gesture.slideEl) {\n                    if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n                    else gesture.slideEl = swiper.slides[swiper.activeIndex];\n                }\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n            }\n            if (!gesture.imageEl || !gesture.imageWrapEl) return;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style.overflow = \"hidden\";\n                swiper.wrapperEl.style.touchAction = \"none\";\n            }\n            gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n            let touchX;\n            let touchY;\n            let offsetX;\n            let offsetY;\n            let diffX;\n            let diffY;\n            let translateX;\n            let translateY;\n            let imageWidth;\n            let imageHeight;\n            let scaledWidth;\n            let scaledHeight;\n            let translateMinX;\n            let translateMinY;\n            let translateMaxX;\n            let translateMaxY;\n            let slideWidth;\n            let slideHeight;\n            if (typeof image.touchesStart.x === \"undefined\" && e) {\n                touchX = e.pageX;\n                touchY = e.pageY;\n            } else {\n                touchX = image.touchesStart.x;\n                touchY = image.touchesStart.y;\n            }\n            const forceZoomRatio = typeof e === \"number\" ? e : null;\n            if (currentScale === 1 && forceZoomRatio) {\n                touchX = undefined;\n                touchY = undefined;\n            }\n            zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n            if (e && !(currentScale === 1 && forceZoomRatio)) {\n                slideWidth = gesture.slideEl.offsetWidth;\n                slideHeight = gesture.slideEl.offsetHeight;\n                offsetX = elementOffset(gesture.slideEl).left + window1.scrollX;\n                offsetY = elementOffset(gesture.slideEl).top + window1.scrollY;\n                diffX = offsetX + slideWidth / 2 - touchX;\n                diffY = offsetY + slideHeight / 2 - touchY;\n                imageWidth = gesture.imageEl.offsetWidth;\n                imageHeight = gesture.imageEl.offsetHeight;\n                scaledWidth = imageWidth * zoom.scale;\n                scaledHeight = imageHeight * zoom.scale;\n                translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n                translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n                translateMaxX = -translateMinX;\n                translateMaxY = -translateMinY;\n                translateX = diffX * zoom.scale;\n                translateY = diffY * zoom.scale;\n                if (translateX < translateMinX) translateX = translateMinX;\n                if (translateX > translateMaxX) translateX = translateMaxX;\n                if (translateY < translateMinY) translateY = translateMinY;\n                if (translateY > translateMaxY) translateY = translateMaxY;\n            } else {\n                translateX = 0;\n                translateY = 0;\n            }\n            if (forceZoomRatio && zoom.scale === 1) {\n                gesture.originX = 0;\n                gesture.originY = 0;\n            }\n            gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n            gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n            gesture.imageEl.style.transitionDuration = \"300ms\";\n            gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n        }\n        function zoomOut() {\n            const zoom = swiper.zoom;\n            const params = swiper.params.zoom;\n            if (!gesture.slideEl) {\n                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n                else gesture.slideEl = swiper.slides[swiper.activeIndex];\n                let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n                if (imageEl) imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n                gesture.imageEl = imageEl;\n                if (imageEl) gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n                else gesture.imageWrapEl = undefined;\n            }\n            if (!gesture.imageEl || !gesture.imageWrapEl) return;\n            if (swiper.params.cssMode) {\n                swiper.wrapperEl.style.overflow = \"\";\n                swiper.wrapperEl.style.touchAction = \"\";\n            }\n            zoom.scale = 1;\n            currentScale = 1;\n            gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n            gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n            gesture.imageEl.style.transitionDuration = \"300ms\";\n            gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n            gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n            gesture.slideEl = undefined;\n            gesture.originX = 0;\n            gesture.originY = 0;\n        }\n        // Toggle Zoom\n        function zoomToggle(e) {\n            const zoom = swiper.zoom;\n            if (zoom.scale && zoom.scale !== 1) // Zoom Out\n            zoomOut();\n            else // Zoom In\n            zoomIn(e);\n        }\n        function getListeners() {\n            const passiveListener = swiper.params.passiveListeners ? {\n                passive: true,\n                capture: false\n            } : false;\n            const activeListenerWithCapture = swiper.params.passiveListeners ? {\n                passive: false,\n                capture: true\n            } : true;\n            return {\n                passiveListener: passiveListener,\n                activeListenerWithCapture: activeListenerWithCapture\n            };\n        }\n        // Attach/Detach Events\n        function enable() {\n            const zoom = swiper.zoom;\n            if (zoom.enabled) return;\n            zoom.enabled = true;\n            const { passiveListener: passiveListener, activeListenerWithCapture: activeListenerWithCapture } = getListeners();\n            // Scale image\n            swiper.wrapperEl.addEventListener(\"pointerdown\", onGestureStart, passiveListener);\n            swiper.wrapperEl.addEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n            [\n                \"pointerup\",\n                \"pointercancel\",\n                \"pointerout\"\n            ].forEach((eventName)=>{\n                swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n            });\n            // Move image\n            swiper.wrapperEl.addEventListener(\"pointermove\", onTouchMove, activeListenerWithCapture);\n        }\n        function disable() {\n            const zoom = swiper.zoom;\n            if (!zoom.enabled) return;\n            zoom.enabled = false;\n            const { passiveListener: passiveListener, activeListenerWithCapture: activeListenerWithCapture } = getListeners();\n            // Scale image\n            swiper.wrapperEl.removeEventListener(\"pointerdown\", onGestureStart, passiveListener);\n            swiper.wrapperEl.removeEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n            [\n                \"pointerup\",\n                \"pointercancel\",\n                \"pointerout\"\n            ].forEach((eventName)=>{\n                swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n            });\n            // Move image\n            swiper.wrapperEl.removeEventListener(\"pointermove\", onTouchMove, activeListenerWithCapture);\n        }\n        on(\"init\", ()=>{\n            if (swiper.params.zoom.enabled) enable();\n        });\n        on(\"destroy\", ()=>{\n            disable();\n        });\n        on(\"touchStart\", (_s, e)=>{\n            if (!swiper.zoom.enabled) return;\n            onTouchStart(e);\n        });\n        on(\"touchEnd\", (_s, e)=>{\n            if (!swiper.zoom.enabled) return;\n            onTouchEnd();\n        });\n        on(\"doubleTap\", (_s, e)=>{\n            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) zoomToggle(e);\n        });\n        on(\"transitionEnd\", ()=>{\n            if (swiper.zoom.enabled && swiper.params.zoom.enabled) onTransitionEnd();\n        });\n        on(\"slideChange\", ()=>{\n            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) onTransitionEnd();\n        });\n        Object.assign(swiper.zoom, {\n            enable: enable,\n            disable: disable,\n            in: zoomIn,\n            out: zoomOut,\n            toggle: zoomToggle\n        });\n    }\n    /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */ function Controller(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            controller: {\n                control: undefined,\n                inverse: false,\n                by: \"slide\" // or 'container'\n            }\n        });\n        swiper.controller = {\n            control: undefined\n        };\n        function LinearSpline(x, y) {\n            const binarySearch = function search() {\n                let maxIndex;\n                let minIndex;\n                let guess;\n                return (array, val)=>{\n                    minIndex = -1;\n                    maxIndex = array.length;\n                    while(maxIndex - minIndex > 1){\n                        guess = maxIndex + minIndex >> 1;\n                        if (array[guess] <= val) minIndex = guess;\n                        else maxIndex = guess;\n                    }\n                    return maxIndex;\n                };\n            }();\n            this.x = x;\n            this.y = y;\n            this.lastIndex = x.length - 1;\n            // Given an x value (x2), return the expected y2 value:\n            // (x1,y1) is the known point before given value,\n            // (x3,y3) is the known point after given value.\n            let i1;\n            let i3;\n            this.interpolate = function interpolate(x2) {\n                if (!x2) return 0;\n                // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n                i3 = binarySearch(this.x, x2);\n                i1 = i3 - 1;\n                // We have our indexes i1 & i3, so we can calculate already:\n                // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n                return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n            };\n            return this;\n        }\n        function getInterpolateFunction(c) {\n            swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n        }\n        function setTranslate(_t, byController) {\n            const controlled = swiper.controller.control;\n            let multiplier;\n            let controlledTranslate;\n            const Swiper = swiper.constructor;\n            function setControlledTranslate(c) {\n                if (c.destroyed) return;\n                // this will create an Interpolate function based on the snapGrids\n                // x is the Grid of the scrolled scroller and y will be the controlled scroller\n                // it makes sense to create this only once and recall it for the interpolation\n                // the function does a lot of value caching for performance\n                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n                if (swiper.params.controller.by === \"slide\") {\n                    getInterpolateFunction(c);\n                    // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n                    // but it did not work out\n                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n                }\n                if (!controlledTranslate || swiper.params.controller.by === \"container\") {\n                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n                    if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) multiplier = 1;\n                    controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n                }\n                if (swiper.params.controller.inverse) controlledTranslate = c.maxTranslate() - controlledTranslate;\n                c.updateProgress(controlledTranslate);\n                c.setTranslate(controlledTranslate, swiper);\n                c.updateActiveIndex();\n                c.updateSlidesClasses();\n            }\n            if (Array.isArray(controlled)) {\n                for(let i = 0; i < controlled.length; i += 1)if (controlled[i] !== byController && controlled[i] instanceof Swiper) setControlledTranslate(controlled[i]);\n            } else if (controlled instanceof Swiper && byController !== controlled) setControlledTranslate(controlled);\n        }\n        function setTransition(duration, byController) {\n            const Swiper = swiper.constructor;\n            const controlled = swiper.controller.control;\n            let i;\n            function setControlledTransition(c) {\n                if (c.destroyed) return;\n                c.setTransition(duration, swiper);\n                if (duration !== 0) {\n                    c.transitionStart();\n                    if (c.params.autoHeight) nextTick(()=>{\n                        c.updateAutoHeight();\n                    });\n                    elementTransitionEnd(c.wrapperEl, ()=>{\n                        if (!controlled) return;\n                        c.transitionEnd();\n                    });\n                }\n            }\n            if (Array.isArray(controlled)) {\n                for(i = 0; i < controlled.length; i += 1)if (controlled[i] !== byController && controlled[i] instanceof Swiper) setControlledTransition(controlled[i]);\n            } else if (controlled instanceof Swiper && byController !== controlled) setControlledTransition(controlled);\n        }\n        function removeSpline() {\n            if (!swiper.controller.control) return;\n            if (swiper.controller.spline) {\n                swiper.controller.spline = undefined;\n                delete swiper.controller.spline;\n            }\n        }\n        on(\"beforeInit\", ()=>{\n            if (typeof window !== \"undefined\" && // eslint-disable-line\n            (typeof swiper.params.controller.control === \"string\" || swiper.params.controller.control instanceof HTMLElement)) {\n                const controlElement = document.querySelector(swiper.params.controller.control);\n                if (controlElement && controlElement.swiper) swiper.controller.control = controlElement.swiper;\n                else if (controlElement) {\n                    const onControllerSwiper = (e)=>{\n                        swiper.controller.control = e.detail[0];\n                        swiper.update();\n                        controlElement.removeEventListener(\"init\", onControllerSwiper);\n                    };\n                    controlElement.addEventListener(\"init\", onControllerSwiper);\n                }\n                return;\n            }\n            swiper.controller.control = swiper.params.controller.control;\n        });\n        on(\"update\", ()=>{\n            removeSpline();\n        });\n        on(\"resize\", ()=>{\n            removeSpline();\n        });\n        on(\"observerUpdate\", ()=>{\n            removeSpline();\n        });\n        on(\"setTranslate\", (_s, translate, byController)=>{\n            if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n            swiper.controller.setTranslate(translate, byController);\n        });\n        on(\"setTransition\", (_s, duration, byController)=>{\n            if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n            swiper.controller.setTransition(duration, byController);\n        });\n        Object.assign(swiper.controller, {\n            setTranslate: setTranslate,\n            setTransition: setTransition\n        });\n    }\n    function A11y(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            a11y: {\n                enabled: true,\n                notificationClass: \"swiper-notification\",\n                prevSlideMessage: \"Previous slide\",\n                nextSlideMessage: \"Next slide\",\n                firstSlideMessage: \"This is the first slide\",\n                lastSlideMessage: \"This is the last slide\",\n                paginationBulletMessage: \"Go to slide {{index}}\",\n                slideLabelMessage: \"{{index}} / {{slidesLength}}\",\n                containerMessage: null,\n                containerRoleDescriptionMessage: null,\n                itemRoleDescriptionMessage: null,\n                slideRole: \"group\",\n                id: null\n            }\n        });\n        swiper.a11y = {\n            clicked: false\n        };\n        let liveRegion = null;\n        function notify(message) {\n            const notification = liveRegion;\n            if (notification.length === 0) return;\n            notification.innerHTML = \"\";\n            notification.innerHTML = message;\n        }\n        const makeElementsArray = (el)=>(Array.isArray(el) ? el : [\n                el\n            ]).filter((e)=>!!e);\n        function getRandomNumber(size) {\n            if (size === void 0) size = 16;\n            const randomChar = ()=>Math.round(16 * Math.random()).toString(16);\n            return \"x\".repeat(size).replace(/x/g, randomChar);\n        }\n        function makeElFocusable(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"tabIndex\", \"0\");\n            });\n        }\n        function makeElNotFocusable(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"tabIndex\", \"-1\");\n            });\n        }\n        function addElRole(el, role) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"role\", role);\n            });\n        }\n        function addElRoleDescription(el, description) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-roledescription\", description);\n            });\n        }\n        function addElControls(el, controls) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-controls\", controls);\n            });\n        }\n        function addElLabel(el, label) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-label\", label);\n            });\n        }\n        function addElId(el, id) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"id\", id);\n            });\n        }\n        function addElLive(el, live) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-live\", live);\n            });\n        }\n        function disableEl(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-disabled\", true);\n            });\n        }\n        function enableEl(el) {\n            el = makeElementsArray(el);\n            el.forEach((subEl)=>{\n                subEl.setAttribute(\"aria-disabled\", false);\n            });\n        }\n        function onEnterOrSpaceKey(e) {\n            if (e.keyCode !== 13 && e.keyCode !== 32) return;\n            const params = swiper.params.a11y;\n            const targetEl = e.target;\n            if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n                if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n            }\n            if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n                if (!(swiper.isEnd && !swiper.params.loop)) swiper.slideNext();\n                if (swiper.isEnd) notify(params.lastSlideMessage);\n                else notify(params.nextSlideMessage);\n            }\n            if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n                if (!(swiper.isBeginning && !swiper.params.loop)) swiper.slidePrev();\n                if (swiper.isBeginning) notify(params.firstSlideMessage);\n                else notify(params.prevSlideMessage);\n            }\n            if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) targetEl.click();\n        }\n        function updateNavigation() {\n            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n            const { nextEl: nextEl, prevEl: prevEl } = swiper.navigation;\n            if (prevEl) {\n                if (swiper.isBeginning) {\n                    disableEl(prevEl);\n                    makeElNotFocusable(prevEl);\n                } else {\n                    enableEl(prevEl);\n                    makeElFocusable(prevEl);\n                }\n            }\n            if (nextEl) {\n                if (swiper.isEnd) {\n                    disableEl(nextEl);\n                    makeElNotFocusable(nextEl);\n                } else {\n                    enableEl(nextEl);\n                    makeElFocusable(nextEl);\n                }\n            }\n        }\n        function hasPagination() {\n            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n        }\n        function hasClickablePagination() {\n            return hasPagination() && swiper.params.pagination.clickable;\n        }\n        function updatePagination() {\n            const params = swiper.params.a11y;\n            if (!hasPagination()) return;\n            swiper.pagination.bullets.forEach((bulletEl)=>{\n                if (swiper.params.pagination.clickable) {\n                    makeElFocusable(bulletEl);\n                    if (!swiper.params.pagination.renderBullet) {\n                        addElRole(bulletEl, \"button\");\n                        addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n                    }\n                }\n                if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) bulletEl.setAttribute(\"aria-current\", \"true\");\n                else bulletEl.removeAttribute(\"aria-current\");\n            });\n        }\n        const initNavEl = (el, wrapperId, message)=>{\n            makeElFocusable(el);\n            if (el.tagName !== \"BUTTON\") {\n                addElRole(el, \"button\");\n                el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n            }\n            addElLabel(el, message);\n            addElControls(el, wrapperId);\n        };\n        const handlePointerDown = ()=>{\n            swiper.a11y.clicked = true;\n        };\n        const handlePointerUp = ()=>{\n            requestAnimationFrame(()=>{\n                requestAnimationFrame(()=>{\n                    if (!swiper.destroyed) swiper.a11y.clicked = false;\n                });\n            });\n        };\n        const handleFocus = (e)=>{\n            if (swiper.a11y.clicked) return;\n            const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n            if (!slideEl || !swiper.slides.includes(slideEl)) return;\n            const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n            const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n            if (isActive || isVisible) return;\n            if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n            if (swiper.isHorizontal()) swiper.el.scrollLeft = 0;\n            else swiper.el.scrollTop = 0;\n            swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n        };\n        const initSlides = ()=>{\n            const params = swiper.params.a11y;\n            if (params.itemRoleDescriptionMessage) addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n            if (params.slideRole) addElRole(swiper.slides, params.slideRole);\n            const slidesLength = swiper.slides.length;\n            if (params.slideLabelMessage) swiper.slides.forEach((slideEl, index)=>{\n                const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10) : index;\n                const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n                addElLabel(slideEl, ariaLabelMessage);\n            });\n        };\n        const init = ()=>{\n            const params = swiper.params.a11y;\n            swiper.el.append(liveRegion);\n            // Container\n            const containerEl = swiper.el;\n            if (params.containerRoleDescriptionMessage) addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n            if (params.containerMessage) addElLabel(containerEl, params.containerMessage);\n            // Wrapper\n            const wrapperEl = swiper.wrapperEl;\n            const wrapperId = params.id || wrapperEl.getAttribute(\"id\") || `swiper-wrapper-${getRandomNumber(16)}`;\n            const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? \"off\" : \"polite\";\n            addElId(wrapperEl, wrapperId);\n            addElLive(wrapperEl, live);\n            // Slide\n            initSlides();\n            // Navigation\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation ? swiper.navigation : {};\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (nextEl) nextEl.forEach((el)=>initNavEl(el, wrapperId, params.nextSlideMessage));\n            if (prevEl) prevEl.forEach((el)=>initNavEl(el, wrapperId, params.prevSlideMessage));\n            // Pagination\n            if (hasClickablePagination()) {\n                const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [\n                    swiper.pagination.el\n                ];\n                paginationEl.forEach((el)=>{\n                    el.addEventListener(\"keydown\", onEnterOrSpaceKey);\n                });\n            }\n            // Tab focus\n            swiper.el.addEventListener(\"focus\", handleFocus, true);\n            swiper.el.addEventListener(\"pointerdown\", handlePointerDown, true);\n            swiper.el.addEventListener(\"pointerup\", handlePointerUp, true);\n        };\n        function destroy() {\n            if (liveRegion) liveRegion.remove();\n            let { nextEl: nextEl, prevEl: prevEl } = swiper.navigation ? swiper.navigation : {};\n            nextEl = makeElementsArray(nextEl);\n            prevEl = makeElementsArray(prevEl);\n            if (nextEl) nextEl.forEach((el)=>el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n            if (prevEl) prevEl.forEach((el)=>el.removeEventListener(\"keydown\", onEnterOrSpaceKey));\n            // Pagination\n            if (hasClickablePagination()) {\n                const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [\n                    swiper.pagination.el\n                ];\n                paginationEl.forEach((el)=>{\n                    el.removeEventListener(\"keydown\", onEnterOrSpaceKey);\n                });\n            }\n            // Tab focus\n            swiper.el.removeEventListener(\"focus\", handleFocus, true);\n            swiper.el.removeEventListener(\"pointerdown\", handlePointerDown, true);\n            swiper.el.removeEventListener(\"pointerup\", handlePointerUp, true);\n        }\n        on(\"beforeInit\", ()=>{\n            liveRegion = createElement(\"span\", swiper.params.a11y.notificationClass);\n            liveRegion.setAttribute(\"aria-live\", \"assertive\");\n            liveRegion.setAttribute(\"aria-atomic\", \"true\");\n        });\n        on(\"afterInit\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            init();\n        });\n        on(\"slidesLengthChange snapGridLengthChange slidesGridLengthChange\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            initSlides();\n        });\n        on(\"fromEdge toEdge afterInit lock unlock\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            updateNavigation();\n        });\n        on(\"paginationUpdate\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            updatePagination();\n        });\n        on(\"destroy\", ()=>{\n            if (!swiper.params.a11y.enabled) return;\n            destroy();\n        });\n    }\n    function History(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            history: {\n                enabled: false,\n                root: \"\",\n                replaceState: false,\n                key: \"slides\",\n                keepQuery: false\n            }\n        });\n        let initialized = false;\n        let paths = {};\n        const slugify = (text)=>{\n            return text.toString().replace(/\\s+/g, \"-\").replace(/[^\\w-]+/g, \"\").replace(/--+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n        };\n        const getPathValues = (urlOverride)=>{\n            const window1 = getWindow();\n            let location;\n            if (urlOverride) location = new URL(urlOverride);\n            else location = window1.location;\n            const pathArray = location.pathname.slice(1).split(\"/\").filter((part)=>part !== \"\");\n            const total = pathArray.length;\n            const key = pathArray[total - 2];\n            const value = pathArray[total - 1];\n            return {\n                key: key,\n                value: value\n            };\n        };\n        const setHistory = (key, index)=>{\n            const window1 = getWindow();\n            if (!initialized || !swiper.params.history.enabled) return;\n            let location;\n            if (swiper.params.url) location = new URL(swiper.params.url);\n            else location = window1.location;\n            const slide = swiper.slides[index];\n            let value = slugify(slide.getAttribute(\"data-history\"));\n            if (swiper.params.history.root.length > 0) {\n                let root = swiper.params.history.root;\n                if (root[root.length - 1] === \"/\") root = root.slice(0, root.length - 1);\n                value = `${root}/${key ? `${key}/` : \"\"}${value}`;\n            } else if (!location.pathname.includes(key)) value = `${key ? `${key}/` : \"\"}${value}`;\n            if (swiper.params.history.keepQuery) value += location.search;\n            const currentState = window1.history.state;\n            if (currentState && currentState.value === value) return;\n            if (swiper.params.history.replaceState) window1.history.replaceState({\n                value: value\n            }, null, value);\n            else window1.history.pushState({\n                value: value\n            }, null, value);\n        };\n        const scrollToSlide = (speed, value, runCallbacks)=>{\n            if (value) for(let i = 0, length = swiper.slides.length; i < length; i += 1){\n                const slide = swiper.slides[i];\n                const slideHistory = slugify(slide.getAttribute(\"data-history\"));\n                if (slideHistory === value) {\n                    const index = swiper.getSlideIndex(slide);\n                    swiper.slideTo(index, speed, runCallbacks);\n                }\n            }\n            else swiper.slideTo(0, speed, runCallbacks);\n        };\n        const setHistoryPopState = ()=>{\n            paths = getPathValues(swiper.params.url);\n            scrollToSlide(swiper.params.speed, paths.value, false);\n        };\n        const init = ()=>{\n            const window1 = getWindow();\n            if (!swiper.params.history) return;\n            if (!window1.history || !window1.history.pushState) {\n                swiper.params.history.enabled = false;\n                swiper.params.hashNavigation.enabled = true;\n                return;\n            }\n            initialized = true;\n            paths = getPathValues(swiper.params.url);\n            if (!paths.key && !paths.value) {\n                if (!swiper.params.history.replaceState) window1.addEventListener(\"popstate\", setHistoryPopState);\n                return;\n            }\n            scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n            if (!swiper.params.history.replaceState) window1.addEventListener(\"popstate\", setHistoryPopState);\n        };\n        const destroy = ()=>{\n            const window1 = getWindow();\n            if (!swiper.params.history.replaceState) window1.removeEventListener(\"popstate\", setHistoryPopState);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.history.enabled) init();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.history.enabled) destroy();\n        });\n        on(\"transitionEnd _freeModeNoMomentumRelease\", ()=>{\n            if (initialized) setHistory(swiper.params.history.key, swiper.activeIndex);\n        });\n        on(\"slideChange\", ()=>{\n            if (initialized && swiper.params.cssMode) setHistory(swiper.params.history.key, swiper.activeIndex);\n        });\n    }\n    function HashNavigation(_ref) {\n        let { swiper: swiper, extendParams: extendParams, emit: emit, on: on } = _ref;\n        let initialized = false;\n        const document1 = getDocument();\n        const window1 = getWindow();\n        extendParams({\n            hashNavigation: {\n                enabled: false,\n                replaceState: false,\n                watchState: false,\n                getSlideIndex (_s, hash) {\n                    if (swiper.virtual && swiper.params.virtual.enabled) {\n                        const slideWithHash = swiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-hash\") === hash)[0];\n                        if (!slideWithHash) return 0;\n                        const index = parseInt(slideWithHash.getAttribute(\"data-swiper-slide-index\"), 10);\n                        return index;\n                    }\n                    return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n                }\n            }\n        });\n        const onHashChange = ()=>{\n            emit(\"hashChange\");\n            const newHash = document1.location.hash.replace(\"#\", \"\");\n            const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute(\"data-hash\") : \"\";\n            if (newHash !== activeSlideHash) {\n                const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n                if (typeof newIndex === \"undefined\" || Number.isNaN(newIndex)) return;\n                swiper.slideTo(newIndex);\n            }\n        };\n        const setHash = ()=>{\n            if (!initialized || !swiper.params.hashNavigation.enabled) return;\n            const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n            const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute(\"data-hash\") || activeSlideEl.getAttribute(\"data-history\") : \"\";\n            if (swiper.params.hashNavigation.replaceState && window1.history && window1.history.replaceState) {\n                window1.history.replaceState(null, null, `#${activeSlideHash}` || \"\");\n                emit(\"hashSet\");\n            } else {\n                document1.location.hash = activeSlideHash || \"\";\n                emit(\"hashSet\");\n            }\n        };\n        const init = ()=>{\n            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n            initialized = true;\n            const hash = document1.location.hash.replace(\"#\", \"\");\n            if (hash) {\n                const speed = 0;\n                const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n                swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n            }\n            if (swiper.params.hashNavigation.watchState) window1.addEventListener(\"hashchange\", onHashChange);\n        };\n        const destroy = ()=>{\n            if (swiper.params.hashNavigation.watchState) window1.removeEventListener(\"hashchange\", onHashChange);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.hashNavigation.enabled) init();\n        });\n        on(\"destroy\", ()=>{\n            if (swiper.params.hashNavigation.enabled) destroy();\n        });\n        on(\"transitionEnd _freeModeNoMomentumRelease\", ()=>{\n            if (initialized) setHash();\n        });\n        on(\"slideChange\", ()=>{\n            if (initialized && swiper.params.cssMode) setHash();\n        });\n    }\n    /* eslint no-underscore-dangle: \"off\" */ /* eslint no-use-before-define: \"off\" */ function Autoplay(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on, emit: emit, params: params } = _ref;\n        swiper.autoplay = {\n            running: false,\n            paused: false,\n            timeLeft: 0\n        };\n        extendParams({\n            autoplay: {\n                enabled: false,\n                delay: 3000,\n                waitForTransition: true,\n                disableOnInteraction: true,\n                stopOnLastSlide: false,\n                reverseDirection: false,\n                pauseOnMouseEnter: false\n            }\n        });\n        let timeout;\n        let raf;\n        let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n        let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n        let autoplayTimeLeft;\n        let autoplayStartTime = new Date().getTime;\n        let wasPaused;\n        let isTouched;\n        let pausedByTouch;\n        let touchStartTimeout;\n        let slideChanged;\n        let pausedByInteraction;\n        function onTransitionEnd(e) {\n            if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n            if (e.target !== swiper.wrapperEl) return;\n            swiper.wrapperEl.removeEventListener(\"transitionend\", onTransitionEnd);\n            resume();\n        }\n        const calcTimeLeft = ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (swiper.autoplay.paused) wasPaused = true;\n            else if (wasPaused) {\n                autoplayDelayCurrent = autoplayTimeLeft;\n                wasPaused = false;\n            }\n            const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n            swiper.autoplay.timeLeft = timeLeft;\n            emit(\"autoplayTimeLeft\", timeLeft, timeLeft / autoplayDelayTotal);\n            raf = requestAnimationFrame(()=>{\n                calcTimeLeft();\n            });\n        };\n        const getSlideDelay = ()=>{\n            let activeSlideEl;\n            if (swiper.virtual && swiper.params.virtual.enabled) activeSlideEl = swiper.slides.filter((slideEl)=>slideEl.classList.contains(\"swiper-slide-active\"))[0];\n            else activeSlideEl = swiper.slides[swiper.activeIndex];\n            if (!activeSlideEl) return undefined;\n            const currentSlideDelay = parseInt(activeSlideEl.getAttribute(\"data-swiper-autoplay\"), 10);\n            return currentSlideDelay;\n        };\n        const run = (delayForce)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            cancelAnimationFrame(raf);\n            calcTimeLeft();\n            let delay = typeof delayForce === \"undefined\" ? swiper.params.autoplay.delay : delayForce;\n            autoplayDelayTotal = swiper.params.autoplay.delay;\n            autoplayDelayCurrent = swiper.params.autoplay.delay;\n            const currentSlideDelay = getSlideDelay();\n            if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === \"undefined\") {\n                delay = currentSlideDelay;\n                autoplayDelayTotal = currentSlideDelay;\n                autoplayDelayCurrent = currentSlideDelay;\n            }\n            autoplayTimeLeft = delay;\n            const speed = swiper.params.speed;\n            const proceed = ()=>{\n                if (!swiper || swiper.destroyed) return;\n                if (swiper.params.autoplay.reverseDirection) {\n                    if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n                        swiper.slidePrev(speed, true, true);\n                        emit(\"autoplay\");\n                    } else if (!swiper.params.autoplay.stopOnLastSlide) {\n                        swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n                        emit(\"autoplay\");\n                    }\n                } else {\n                    if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n                        swiper.slideNext(speed, true, true);\n                        emit(\"autoplay\");\n                    } else if (!swiper.params.autoplay.stopOnLastSlide) {\n                        swiper.slideTo(0, speed, true, true);\n                        emit(\"autoplay\");\n                    }\n                }\n                if (swiper.params.cssMode) {\n                    autoplayStartTime = new Date().getTime();\n                    requestAnimationFrame(()=>{\n                        run();\n                    });\n                }\n            };\n            if (delay > 0) {\n                clearTimeout(timeout);\n                timeout = setTimeout(()=>{\n                    proceed();\n                }, delay);\n            } else requestAnimationFrame(()=>{\n                proceed();\n            });\n            // eslint-disable-next-line\n            return delay;\n        };\n        const start = ()=>{\n            swiper.autoplay.running = true;\n            run();\n            emit(\"autoplayStart\");\n        };\n        const stop = ()=>{\n            swiper.autoplay.running = false;\n            clearTimeout(timeout);\n            cancelAnimationFrame(raf);\n            emit(\"autoplayStop\");\n        };\n        const pause = (internal, reset)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            clearTimeout(timeout);\n            if (!internal) pausedByInteraction = true;\n            const proceed = ()=>{\n                emit(\"autoplayPause\");\n                if (swiper.params.autoplay.waitForTransition) swiper.wrapperEl.addEventListener(\"transitionend\", onTransitionEnd);\n                else resume();\n            };\n            swiper.autoplay.paused = true;\n            if (reset) {\n                if (slideChanged) autoplayTimeLeft = swiper.params.autoplay.delay;\n                slideChanged = false;\n                proceed();\n                return;\n            }\n            const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n            autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n            if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n            proceed();\n        };\n        const resume = ()=>{\n            if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n            autoplayStartTime = new Date().getTime();\n            if (pausedByInteraction) {\n                pausedByInteraction = false;\n                run(autoplayTimeLeft);\n            } else run();\n            swiper.autoplay.paused = false;\n            emit(\"autoplayResume\");\n        };\n        const onVisibilityChange = ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            const document1 = getDocument();\n            if (document1.visibilityState === \"hidden\") {\n                pausedByInteraction = true;\n                pause(true);\n            }\n            if (document1.visibilityState === \"visible\") resume();\n        };\n        const onPointerEnter = (e)=>{\n            if (e.pointerType !== \"mouse\") return;\n            pausedByInteraction = true;\n            pause(true);\n        };\n        const onPointerLeave = (e)=>{\n            if (e.pointerType !== \"mouse\") return;\n            if (swiper.autoplay.paused) resume();\n        };\n        const attachMouseEvents = ()=>{\n            if (swiper.params.autoplay.pauseOnMouseEnter) {\n                swiper.el.addEventListener(\"pointerenter\", onPointerEnter);\n                swiper.el.addEventListener(\"pointerleave\", onPointerLeave);\n            }\n        };\n        const detachMouseEvents = ()=>{\n            swiper.el.removeEventListener(\"pointerenter\", onPointerEnter);\n            swiper.el.removeEventListener(\"pointerleave\", onPointerLeave);\n        };\n        const attachDocumentEvents = ()=>{\n            const document1 = getDocument();\n            document1.addEventListener(\"visibilitychange\", onVisibilityChange);\n        };\n        const detachDocumentEvents = ()=>{\n            const document1 = getDocument();\n            document1.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        };\n        on(\"init\", ()=>{\n            if (swiper.params.autoplay.enabled) {\n                attachMouseEvents();\n                attachDocumentEvents();\n                autoplayStartTime = new Date().getTime();\n                start();\n            }\n        });\n        on(\"destroy\", ()=>{\n            detachMouseEvents();\n            detachDocumentEvents();\n            if (swiper.autoplay.running) stop();\n        });\n        on(\"beforeTransitionStart\", (_s, speed, internal)=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (internal || !swiper.params.autoplay.disableOnInteraction) pause(true, true);\n            else stop();\n        });\n        on(\"sliderFirstMove\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            if (swiper.params.autoplay.disableOnInteraction) {\n                stop();\n                return;\n            }\n            isTouched = true;\n            pausedByTouch = false;\n            pausedByInteraction = false;\n            touchStartTimeout = setTimeout(()=>{\n                pausedByInteraction = true;\n                pausedByTouch = true;\n                pause(true);\n            }, 200);\n        });\n        on(\"touchEnd\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n            clearTimeout(touchStartTimeout);\n            clearTimeout(timeout);\n            if (swiper.params.autoplay.disableOnInteraction) {\n                pausedByTouch = false;\n                isTouched = false;\n                return;\n            }\n            if (pausedByTouch && swiper.params.cssMode) resume();\n            pausedByTouch = false;\n            isTouched = false;\n        });\n        on(\"slideChange\", ()=>{\n            if (swiper.destroyed || !swiper.autoplay.running) return;\n            slideChanged = true;\n        });\n        Object.assign(swiper.autoplay, {\n            start: start,\n            stop: stop,\n            pause: pause,\n            resume: resume\n        });\n    }\n    function Thumb(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            thumbs: {\n                swiper: null,\n                multipleActiveThumbs: true,\n                autoScrollOffset: 0,\n                slideThumbActiveClass: \"swiper-slide-thumb-active\",\n                thumbsContainerClass: \"swiper-thumbs\"\n            }\n        });\n        let initialized = false;\n        let swiperCreated = false;\n        swiper.thumbs = {\n            swiper: null\n        };\n        function onThumbClick() {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            const clickedIndex = thumbsSwiper.clickedIndex;\n            const clickedSlide = thumbsSwiper.clickedSlide;\n            if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n            if (typeof clickedIndex === \"undefined\" || clickedIndex === null) return;\n            let slideToIndex;\n            if (thumbsSwiper.params.loop) slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n            else slideToIndex = clickedIndex;\n            if (swiper.params.loop) swiper.slideToLoop(slideToIndex);\n            else swiper.slideTo(slideToIndex);\n        }\n        function init() {\n            const { thumbs: thumbsParams } = swiper.params;\n            if (initialized) return false;\n            initialized = true;\n            const SwiperClass = swiper.constructor;\n            if (thumbsParams.swiper instanceof SwiperClass) {\n                swiper.thumbs.swiper = thumbsParams.swiper;\n                Object.assign(swiper.thumbs.swiper.originalParams, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                Object.assign(swiper.thumbs.swiper.params, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                swiper.thumbs.swiper.update();\n            } else if (isObject(thumbsParams.swiper)) {\n                const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n                Object.assign(thumbsSwiperParams, {\n                    watchSlidesProgress: true,\n                    slideToClickedSlide: false\n                });\n                swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n                swiperCreated = true;\n            }\n            swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n            swiper.thumbs.swiper.on(\"tap\", onThumbClick);\n            return true;\n        }\n        function update(initial) {\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            const slidesPerView = thumbsSwiper.params.slidesPerView === \"auto\" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n            // Activate thumbs\n            let thumbsToActivate = 1;\n            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) thumbsToActivate = swiper.params.slidesPerView;\n            if (!swiper.params.thumbs.multipleActiveThumbs) thumbsToActivate = 1;\n            thumbsToActivate = Math.floor(thumbsToActivate);\n            thumbsSwiper.slides.forEach((slideEl)=>slideEl.classList.remove(thumbActiveClass));\n            if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) for(let i = 0; i < thumbsToActivate; i += 1)elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach((slideEl)=>{\n                slideEl.classList.add(thumbActiveClass);\n            });\n            else {\n                for(let i = 0; i < thumbsToActivate; i += 1)if (thumbsSwiper.slides[swiper.realIndex + i]) thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n            }\n            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n            const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n                const currentThumbsIndex = thumbsSwiper.activeIndex;\n                let newThumbsIndex;\n                let direction;\n                if (thumbsSwiper.params.loop) {\n                    const newThumbsSlide = thumbsSwiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") === `${swiper.realIndex}`)[0];\n                    newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n                    direction = swiper.activeIndex > swiper.previousIndex ? \"next\" : \"prev\";\n                } else {\n                    newThumbsIndex = swiper.realIndex;\n                    direction = newThumbsIndex > swiper.previousIndex ? \"next\" : \"prev\";\n                }\n                if (useOffset) newThumbsIndex += direction === \"next\" ? autoScrollOffset : -1 * autoScrollOffset;\n                if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n                    if (thumbsSwiper.params.centeredSlides) {\n                        if (newThumbsIndex > currentThumbsIndex) newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n                        else newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n                    } else newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup;\n                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n                }\n            }\n        }\n        on(\"beforeInit\", ()=>{\n            const { thumbs: thumbs } = swiper.params;\n            if (!thumbs || !thumbs.swiper) return;\n            if (typeof thumbs.swiper === \"string\" || thumbs.swiper instanceof HTMLElement) {\n                const document1 = getDocument();\n                const getThumbsElementAndInit = ()=>{\n                    const thumbsElement = typeof thumbs.swiper === \"string\" ? document1.querySelector(thumbs.swiper) : thumbs.swiper;\n                    if (thumbsElement && thumbsElement.swiper) {\n                        thumbs.swiper = thumbsElement.swiper;\n                        init();\n                        update(true);\n                    } else if (thumbsElement) {\n                        const onThumbsSwiper = (e)=>{\n                            thumbs.swiper = e.detail[0];\n                            thumbsElement.removeEventListener(\"init\", onThumbsSwiper);\n                            init();\n                            update(true);\n                            thumbs.swiper.update();\n                            swiper.update();\n                        };\n                        thumbsElement.addEventListener(\"init\", onThumbsSwiper);\n                    }\n                    return thumbsElement;\n                };\n                const watchForThumbsToAppear = ()=>{\n                    if (swiper.destroyed) return;\n                    const thumbsElement = getThumbsElementAndInit();\n                    if (!thumbsElement) requestAnimationFrame(watchForThumbsToAppear);\n                };\n                requestAnimationFrame(watchForThumbsToAppear);\n            } else {\n                init();\n                update(true);\n            }\n        });\n        on(\"slideChange update resize observerUpdate\", ()=>{\n            update();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            thumbsSwiper.setTransition(duration);\n        });\n        on(\"beforeDestroy\", ()=>{\n            const thumbsSwiper = swiper.thumbs.swiper;\n            if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n            if (swiperCreated) thumbsSwiper.destroy();\n        });\n        Object.assign(swiper.thumbs, {\n            init: init,\n            update: update\n        });\n    }\n    function freeMode(_ref) {\n        let { swiper: swiper, extendParams: extendParams, emit: emit, once: once } = _ref;\n        extendParams({\n            freeMode: {\n                enabled: false,\n                momentum: true,\n                momentumRatio: 1,\n                momentumBounce: true,\n                momentumBounceRatio: 1,\n                momentumVelocityRatio: 1,\n                sticky: false,\n                minimumVelocity: 0.02\n            }\n        });\n        function onTouchStart() {\n            if (swiper.params.cssMode) return;\n            const translate = swiper.getTranslate();\n            swiper.setTranslate(translate);\n            swiper.setTransition(0);\n            swiper.touchEventsData.velocities.length = 0;\n            swiper.freeMode.onTouchEnd({\n                currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n            });\n        }\n        function onTouchMove() {\n            if (swiper.params.cssMode) return;\n            const { touchEventsData: data, touches: touches } = swiper;\n            // Velocity\n            if (data.velocities.length === 0) data.velocities.push({\n                position: touches[swiper.isHorizontal() ? \"startX\" : \"startY\"],\n                time: data.touchStartTime\n            });\n            data.velocities.push({\n                position: touches[swiper.isHorizontal() ? \"currentX\" : \"currentY\"],\n                time: now()\n            });\n        }\n        function onTouchEnd(_ref2) {\n            let { currentPos: currentPos } = _ref2;\n            if (swiper.params.cssMode) return;\n            const { params: params, wrapperEl: wrapperEl, rtlTranslate: rtl, snapGrid: snapGrid, touchEventsData: data } = swiper;\n            // Time diff\n            const touchEndTime = now();\n            const timeDiff = touchEndTime - data.touchStartTime;\n            if (currentPos < -swiper.minTranslate()) {\n                swiper.slideTo(swiper.activeIndex);\n                return;\n            }\n            if (currentPos > -swiper.maxTranslate()) {\n                if (swiper.slides.length < snapGrid.length) swiper.slideTo(snapGrid.length - 1);\n                else swiper.slideTo(swiper.slides.length - 1);\n                return;\n            }\n            if (params.freeMode.momentum) {\n                if (data.velocities.length > 1) {\n                    const lastMoveEvent = data.velocities.pop();\n                    const velocityEvent = data.velocities.pop();\n                    const distance = lastMoveEvent.position - velocityEvent.position;\n                    const time = lastMoveEvent.time - velocityEvent.time;\n                    swiper.velocity = distance / time;\n                    swiper.velocity /= 2;\n                    if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) swiper.velocity = 0;\n                    // this implies that the user stopped moving a finger then released.\n                    // There would be no events with distance zero, so the last event is stale.\n                    if (time > 150 || now() - lastMoveEvent.time > 300) swiper.velocity = 0;\n                } else swiper.velocity = 0;\n                swiper.velocity *= params.freeMode.momentumVelocityRatio;\n                data.velocities.length = 0;\n                let momentumDuration = 1000 * params.freeMode.momentumRatio;\n                const momentumDistance = swiper.velocity * momentumDuration;\n                let newPosition = swiper.translate + momentumDistance;\n                if (rtl) newPosition = -newPosition;\n                let doBounce = false;\n                let afterBouncePosition;\n                const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n                let needsLoopFix;\n                if (newPosition < swiper.maxTranslate()) {\n                    if (params.freeMode.momentumBounce) {\n                        if (newPosition + swiper.maxTranslate() < -bounceAmount) newPosition = swiper.maxTranslate() - bounceAmount;\n                        afterBouncePosition = swiper.maxTranslate();\n                        doBounce = true;\n                        data.allowMomentumBounce = true;\n                    } else newPosition = swiper.maxTranslate();\n                    if (params.loop && params.centeredSlides) needsLoopFix = true;\n                } else if (newPosition > swiper.minTranslate()) {\n                    if (params.freeMode.momentumBounce) {\n                        if (newPosition - swiper.minTranslate() > bounceAmount) newPosition = swiper.minTranslate() + bounceAmount;\n                        afterBouncePosition = swiper.minTranslate();\n                        doBounce = true;\n                        data.allowMomentumBounce = true;\n                    } else newPosition = swiper.minTranslate();\n                    if (params.loop && params.centeredSlides) needsLoopFix = true;\n                } else if (params.freeMode.sticky) {\n                    let nextSlide;\n                    for(let j = 0; j < snapGrid.length; j += 1)if (snapGrid[j] > -newPosition) {\n                        nextSlide = j;\n                        break;\n                    }\n                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === \"next\") newPosition = snapGrid[nextSlide];\n                    else newPosition = snapGrid[nextSlide - 1];\n                    newPosition = -newPosition;\n                }\n                if (needsLoopFix) once(\"transitionEnd\", ()=>{\n                    swiper.loopFix();\n                });\n                // Fix duration\n                if (swiper.velocity !== 0) {\n                    if (rtl) momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n                    else momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n                    if (params.freeMode.sticky) {\n                        // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n                        // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n                        // It's easy to see this when simulating touch with mouse events. To fix this,\n                        // limit single-slide swipes to the default slide duration. This also has the\n                        // nice side effect of matching slide speed if the user stopped moving before\n                        // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n                        // For faster swipes, also apply limits (albeit higher ones).\n                        const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n                        const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n                        if (moveDistance < currentSlideSize) momentumDuration = params.speed;\n                        else if (moveDistance < 2 * currentSlideSize) momentumDuration = params.speed * 1.5;\n                        else momentumDuration = params.speed * 2.5;\n                    }\n                } else if (params.freeMode.sticky) {\n                    swiper.slideToClosest();\n                    return;\n                }\n                if (params.freeMode.momentumBounce && doBounce) {\n                    swiper.updateProgress(afterBouncePosition);\n                    swiper.setTransition(momentumDuration);\n                    swiper.setTranslate(newPosition);\n                    swiper.transitionStart(true, swiper.swipeDirection);\n                    swiper.animating = true;\n                    elementTransitionEnd(wrapperEl, ()=>{\n                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n                        emit(\"momentumBounce\");\n                        swiper.setTransition(params.speed);\n                        setTimeout(()=>{\n                            swiper.setTranslate(afterBouncePosition);\n                            elementTransitionEnd(wrapperEl, ()=>{\n                                if (!swiper || swiper.destroyed) return;\n                                swiper.transitionEnd();\n                            });\n                        }, 0);\n                    });\n                } else if (swiper.velocity) {\n                    emit(\"_freeModeNoMomentumRelease\");\n                    swiper.updateProgress(newPosition);\n                    swiper.setTransition(momentumDuration);\n                    swiper.setTranslate(newPosition);\n                    swiper.transitionStart(true, swiper.swipeDirection);\n                    if (!swiper.animating) {\n                        swiper.animating = true;\n                        elementTransitionEnd(wrapperEl, ()=>{\n                            if (!swiper || swiper.destroyed) return;\n                            swiper.transitionEnd();\n                        });\n                    }\n                } else swiper.updateProgress(newPosition);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            } else if (params.freeMode.sticky) {\n                swiper.slideToClosest();\n                return;\n            } else if (params.freeMode) emit(\"_freeModeNoMomentumRelease\");\n            if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n                swiper.updateProgress();\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n        }\n        Object.assign(swiper, {\n            freeMode: {\n                onTouchStart: onTouchStart,\n                onTouchMove: onTouchMove,\n                onTouchEnd: onTouchEnd\n            }\n        });\n    }\n    function Grid(_ref) {\n        let { swiper: swiper, extendParams: extendParams } = _ref;\n        extendParams({\n            grid: {\n                rows: 1,\n                fill: \"column\"\n            }\n        });\n        let slidesNumberEvenToRows;\n        let slidesPerRow;\n        let numFullColumns;\n        const getSpaceBetween = ()=>{\n            let spaceBetween = swiper.params.spaceBetween;\n            if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n            else if (typeof spaceBetween === \"string\") spaceBetween = parseFloat(spaceBetween);\n            return spaceBetween;\n        };\n        const initSlides = (slidesLength)=>{\n            const { slidesPerView: slidesPerView } = swiper.params;\n            const { rows: rows, fill: fill } = swiper.params.grid;\n            numFullColumns = Math.floor(slidesLength / rows);\n            if (Math.floor(slidesLength / rows) === slidesLength / rows) slidesNumberEvenToRows = slidesLength;\n            else slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n            if (slidesPerView !== \"auto\" && fill === \"row\") slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n            slidesPerRow = slidesNumberEvenToRows / rows;\n        };\n        const updateSlide = (i, slide, slidesLength, getDirectionLabel)=>{\n            const { slidesPerGroup: slidesPerGroup } = swiper.params;\n            const spaceBetween = getSpaceBetween();\n            const { rows: rows, fill: fill } = swiper.params.grid;\n            // Set slides order\n            let newSlideOrderIndex;\n            let column;\n            let row;\n            if (fill === \"row\" && slidesPerGroup > 1) {\n                const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n                const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n                const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n                row = Math.floor(slideIndexInGroup / columnsInGroup);\n                column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n                newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n                slide.style.order = newSlideOrderIndex;\n            } else if (fill === \"column\") {\n                column = Math.floor(i / rows);\n                row = i - column * rows;\n                if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n                    row += 1;\n                    if (row >= rows) {\n                        row = 0;\n                        column += 1;\n                    }\n                }\n            } else {\n                row = Math.floor(i / slidesPerRow);\n                column = i - row * slidesPerRow;\n            }\n            slide.row = row;\n            slide.column = column;\n            slide.style[getDirectionLabel(\"margin-top\")] = row !== 0 ? spaceBetween && `${spaceBetween}px` : \"\";\n        };\n        const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel)=>{\n            const { centeredSlides: centeredSlides, roundLengths: roundLengths } = swiper.params;\n            const spaceBetween = getSpaceBetween();\n            const { rows: rows } = swiper.params.grid;\n            swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n            swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n            swiper.wrapperEl.style[getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n            if (centeredSlides) {\n                const newSlidesGrid = [];\n                for(let i = 0; i < snapGrid.length; i += 1){\n                    let slidesGridItem = snapGrid[i];\n                    if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n                    if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n                }\n                snapGrid.splice(0, snapGrid.length);\n                snapGrid.push(...newSlidesGrid);\n            }\n        };\n        swiper.grid = {\n            initSlides: initSlides,\n            updateSlide: updateSlide,\n            updateWrapperSize: updateWrapperSize\n        };\n    }\n    function appendSlide(slides) {\n        const swiper = this;\n        const { params: params, slidesEl: slidesEl } = swiper;\n        if (params.loop) swiper.loopDestroy();\n        const appendElement = (slideEl)=>{\n            if (typeof slideEl === \"string\") {\n                const tempDOM = document.createElement(\"div\");\n                tempDOM.innerHTML = slideEl;\n                slidesEl.append(tempDOM.children[0]);\n                tempDOM.innerHTML = \"\";\n            } else slidesEl.append(slideEl);\n        };\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) appendElement(slides[i]);\n        } else appendElement(slides);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n    }\n    function prependSlide(slides) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex, slidesEl: slidesEl } = swiper;\n        if (params.loop) swiper.loopDestroy();\n        let newActiveIndex = activeIndex + 1;\n        const prependElement = (slideEl)=>{\n            if (typeof slideEl === \"string\") {\n                const tempDOM = document.createElement(\"div\");\n                tempDOM.innerHTML = slideEl;\n                slidesEl.prepend(tempDOM.children[0]);\n                tempDOM.innerHTML = \"\";\n            } else slidesEl.prepend(slideEl);\n        };\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) prependElement(slides[i]);\n            newActiveIndex = activeIndex + slides.length;\n        } else prependElement(slides);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function addSlide(index, slides) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex, slidesEl: slidesEl } = swiper;\n        let activeIndexBuffer = activeIndex;\n        if (params.loop) {\n            activeIndexBuffer -= swiper.loopedSlides;\n            swiper.loopDestroy();\n            swiper.recalcSlides();\n        }\n        const baseLength = swiper.slides.length;\n        if (index <= 0) {\n            swiper.prependSlide(slides);\n            return;\n        }\n        if (index >= baseLength) {\n            swiper.appendSlide(slides);\n            return;\n        }\n        let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n        const slidesBuffer = [];\n        for(let i = baseLength - 1; i >= index; i -= 1){\n            const currentSlide = swiper.slides[i];\n            currentSlide.remove();\n            slidesBuffer.unshift(currentSlide);\n        }\n        if (typeof slides === \"object\" && \"length\" in slides) {\n            for(let i = 0; i < slides.length; i += 1)if (slides[i]) slidesEl.append(slides[i]);\n            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n        } else slidesEl.append(slides);\n        for(let i = 0; i < slidesBuffer.length; i += 1)slidesEl.append(slidesBuffer[i]);\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        if (params.loop) swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n        else swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function removeSlide(slidesIndexes) {\n        const swiper = this;\n        const { params: params, activeIndex: activeIndex } = swiper;\n        let activeIndexBuffer = activeIndex;\n        if (params.loop) {\n            activeIndexBuffer -= swiper.loopedSlides;\n            swiper.loopDestroy();\n        }\n        let newActiveIndex = activeIndexBuffer;\n        let indexToRemove;\n        if (typeof slidesIndexes === \"object\" && \"length\" in slidesIndexes) {\n            for(let i = 0; i < slidesIndexes.length; i += 1){\n                indexToRemove = slidesIndexes[i];\n                if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n                if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n            }\n            newActiveIndex = Math.max(newActiveIndex, 0);\n        } else {\n            indexToRemove = slidesIndexes;\n            if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n            newActiveIndex = Math.max(newActiveIndex, 0);\n        }\n        swiper.recalcSlides();\n        if (params.loop) swiper.loopCreate();\n        if (!params.observer || swiper.isElement) swiper.update();\n        if (params.loop) swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n        else swiper.slideTo(newActiveIndex, 0, false);\n    }\n    function removeAllSlides() {\n        const swiper = this;\n        const slidesIndexes = [];\n        for(let i = 0; i < swiper.slides.length; i += 1)slidesIndexes.push(i);\n        swiper.removeSlide(slidesIndexes);\n    }\n    function Manipulation(_ref) {\n        let { swiper: swiper } = _ref;\n        Object.assign(swiper, {\n            appendSlide: appendSlide.bind(swiper),\n            prependSlide: prependSlide.bind(swiper),\n            addSlide: addSlide.bind(swiper),\n            removeSlide: removeSlide.bind(swiper),\n            removeAllSlides: removeAllSlides.bind(swiper)\n        });\n    }\n    function effectInit(params) {\n        const { effect: effect, swiper: swiper, on: on, setTranslate: setTranslate, setTransition: setTransition, overwriteParams: overwriteParams, perspective: perspective, recreateShadows: recreateShadows, getEffectParams: getEffectParams } = params;\n        on(\"beforeInit\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n            if (perspective && perspective()) swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n            Object.assign(swiper.params, overwriteParamsResult);\n            Object.assign(swiper.originalParams, overwriteParamsResult);\n        });\n        on(\"setTranslate\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            setTranslate();\n        });\n        on(\"setTransition\", (_s, duration)=>{\n            if (swiper.params.effect !== effect) return;\n            setTransition(duration);\n        });\n        on(\"transitionEnd\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            if (recreateShadows) {\n                if (!getEffectParams || !getEffectParams().slideShadows) return;\n                // remove shadows\n                swiper.slides.forEach((slideEl)=>{\n                    slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>shadowEl.remove());\n                });\n                // create new one\n                recreateShadows();\n            }\n        });\n        let requireUpdateOnVirtual;\n        on(\"virtualUpdate\", ()=>{\n            if (swiper.params.effect !== effect) return;\n            if (!swiper.slides.length) requireUpdateOnVirtual = true;\n            requestAnimationFrame(()=>{\n                if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n                    setTranslate();\n                    requireUpdateOnVirtual = false;\n                }\n            });\n        });\n    }\n    function effectTarget(effectParams, slideEl) {\n        const transformEl = getSlideTransformEl(slideEl);\n        if (transformEl !== slideEl) {\n            transformEl.style.backfaceVisibility = \"hidden\";\n            transformEl.style[\"-webkit-backface-visibility\"] = \"hidden\";\n        }\n        return transformEl;\n    }\n    function effectVirtualTransitionEnd(_ref) {\n        let { swiper: swiper, duration: duration, transformElements: transformElements, allSlides: allSlides } = _ref;\n        const { activeIndex: activeIndex } = swiper;\n        const getSlide = (el)=>{\n            if (!el.parentElement) {\n                // assume shadow root\n                const slide = swiper.slides.filter((slideEl)=>slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];\n                return slide;\n            }\n            return el.parentElement;\n        };\n        if (swiper.params.virtualTranslate && duration !== 0) {\n            let eventTriggered = false;\n            let transitionEndTarget;\n            if (allSlides) transitionEndTarget = transformElements;\n            else transitionEndTarget = transformElements.filter((transformEl)=>{\n                const el = transformEl.classList.contains(\"swiper-slide-transform\") ? getSlide(transformEl) : transformEl;\n                return swiper.getSlideIndex(el) === activeIndex;\n            });\n            transitionEndTarget.forEach((el)=>{\n                elementTransitionEnd(el, ()=>{\n                    if (eventTriggered) return;\n                    if (!swiper || swiper.destroyed) return;\n                    eventTriggered = true;\n                    swiper.animating = false;\n                    const evt = new window.CustomEvent(\"transitionend\", {\n                        bubbles: true,\n                        cancelable: true\n                    });\n                    swiper.wrapperEl.dispatchEvent(evt);\n                });\n            });\n        }\n    }\n    function EffectFade(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            fadeEffect: {\n                crossFade: false\n            }\n        });\n        const setTranslate = ()=>{\n            const { slides: slides } = swiper;\n            const params = swiper.params.fadeEffect;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = swiper.slides[i];\n                const offset = slideEl.swiperSlideOffset;\n                let tx = -offset;\n                if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n                let ty = 0;\n                if (!swiper.isHorizontal()) {\n                    ty = tx;\n                    tx = 0;\n                }\n                const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.opacity = slideOpacity;\n                targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements,\n                allSlides: true\n            });\n        };\n        effectInit({\n            effect: \"fade\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    spaceBetween: 0,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCube(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            cubeEffect: {\n                slideShadows: true,\n                shadow: true,\n                shadowOffset: 20,\n                shadowScale: 0.94\n            }\n        });\n        const createSlideShadows = (slideEl, progress, isHorizontal)=>{\n            let shadowBefore = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n            let shadowAfter = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n            if (!shadowBefore) {\n                shadowBefore = createElement(\"div\", `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? \"left\" : \"top\"}`.split(\" \"));\n                slideEl.append(shadowBefore);\n            }\n            if (!shadowAfter) {\n                shadowAfter = createElement(\"div\", `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? \"right\" : \"bottom\"}`.split(\" \"));\n                slideEl.append(shadowAfter);\n            }\n            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n        };\n        const recreateShadows = ()=>{\n            // create new ones\n            const isHorizontal = swiper.isHorizontal();\n            swiper.slides.forEach((slideEl)=>{\n                const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                createSlideShadows(slideEl, progress, isHorizontal);\n            });\n        };\n        const setTranslate = ()=>{\n            const { el: el, wrapperEl: wrapperEl, slides: slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize, browser: browser } = swiper;\n            const params = swiper.params.cubeEffect;\n            const isHorizontal = swiper.isHorizontal();\n            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n            let wrapperRotate = 0;\n            let cubeShadowEl;\n            if (params.shadow) {\n                if (isHorizontal) {\n                    cubeShadowEl = swiper.wrapperEl.querySelector(\".swiper-cube-shadow\");\n                    if (!cubeShadowEl) {\n                        cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n                        swiper.wrapperEl.append(cubeShadowEl);\n                    }\n                    cubeShadowEl.style.height = `${swiperWidth}px`;\n                } else {\n                    cubeShadowEl = el.querySelector(\".swiper-cube-shadow\");\n                    if (!cubeShadowEl) {\n                        cubeShadowEl = createElement(\"div\", \"swiper-cube-shadow\");\n                        el.append(cubeShadowEl);\n                    }\n                }\n            }\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                let slideIndex = i;\n                if (isVirtual) slideIndex = parseInt(slideEl.getAttribute(\"data-swiper-slide-index\"), 10);\n                let slideAngle = slideIndex * 90;\n                let round = Math.floor(slideAngle / 360);\n                if (rtl) {\n                    slideAngle = -slideAngle;\n                    round = Math.floor(-slideAngle / 360);\n                }\n                const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                let tx = 0;\n                let ty = 0;\n                let tz = 0;\n                if (slideIndex % 4 === 0) {\n                    tx = -round * 4 * swiperSize;\n                    tz = 0;\n                } else if ((slideIndex - 1) % 4 === 0) {\n                    tx = 0;\n                    tz = -round * 4 * swiperSize;\n                } else if ((slideIndex - 2) % 4 === 0) {\n                    tx = swiperSize + round * 4 * swiperSize;\n                    tz = swiperSize;\n                } else if ((slideIndex - 3) % 4 === 0) {\n                    tx = -swiperSize;\n                    tz = 3 * swiperSize + swiperSize * 4 * round;\n                }\n                if (rtl) tx = -tx;\n                if (!isHorizontal) {\n                    ty = tx;\n                    tx = 0;\n                }\n                const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n                if (progress <= 1 && progress > -1) {\n                    wrapperRotate = slideIndex * 90 + progress * 90;\n                    if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n                }\n                slideEl.style.transform = transform;\n                if (params.slideShadows) createSlideShadows(slideEl, progress, isHorizontal);\n            }\n            wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n            wrapperEl.style[\"-webkit-transform-origin\"] = `50% 50% -${swiperSize / 2}px`;\n            if (params.shadow) {\n                if (isHorizontal) cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n                else {\n                    const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n                    const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n                    const scale1 = params.shadowScale;\n                    const scale2 = params.shadowScale / multiplier;\n                    const offset = params.shadowOffset;\n                    cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n                }\n            }\n            const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n            wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n            wrapperEl.style.setProperty(\"--swiper-cube-translate-z\", `${zFactor}px`);\n        };\n        const setTransition = (duration)=>{\n            const { el: el, slides: slides } = swiper;\n            slides.forEach((slideEl)=>{\n                slideEl.style.transitionDuration = `${duration}ms`;\n                slideEl.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((subEl)=>{\n                    subEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n                const shadowEl = el.querySelector(\".swiper-cube-shadow\");\n                if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n            }\n        };\n        effectInit({\n            effect: \"cube\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            recreateShadows: recreateShadows,\n            getEffectParams: ()=>swiper.params.cubeEffect,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    resistanceRatio: 0,\n                    spaceBetween: 0,\n                    centeredSlides: false,\n                    virtualTranslate: true\n                })\n        });\n    }\n    function createShadow(suffix, slideEl, side) {\n        const shadowClass = `swiper-slide-shadow${side ? `-${side}` : \"\"}${suffix ? ` swiper-slide-shadow-${suffix}` : \"\"}`;\n        const shadowContainer = getSlideTransformEl(slideEl);\n        let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(\" \").join(\".\")}`);\n        if (!shadowEl) {\n            shadowEl = createElement(\"div\", shadowClass.split(\" \"));\n            shadowContainer.append(shadowEl);\n        }\n        return shadowEl;\n    }\n    function EffectFlip(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            flipEffect: {\n                slideShadows: true,\n                limitRotation: true\n            }\n        });\n        const createSlideShadows = (slideEl, progress)=>{\n            let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n            let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n            if (!shadowBefore) shadowBefore = createShadow(\"flip\", slideEl, swiper.isHorizontal() ? \"left\" : \"top\");\n            if (!shadowAfter) shadowAfter = createShadow(\"flip\", slideEl, swiper.isHorizontal() ? \"right\" : \"bottom\");\n            if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n            if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n        };\n        const recreateShadows = ()=>{\n            // Set shadows\n            swiper.params.flipEffect;\n            swiper.slides.forEach((slideEl)=>{\n                let progress = slideEl.progress;\n                if (swiper.params.flipEffect.limitRotation) progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                createSlideShadows(slideEl, progress);\n            });\n        };\n        const setTranslate = ()=>{\n            const { slides: slides, rtlTranslate: rtl } = swiper;\n            const params = swiper.params.flipEffect;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                let progress = slideEl.progress;\n                if (swiper.params.flipEffect.limitRotation) progress = Math.max(Math.min(slideEl.progress, 1), -1);\n                const offset = slideEl.swiperSlideOffset;\n                const rotate = -180 * progress;\n                let rotateY = rotate;\n                let rotateX = 0;\n                let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n                let ty = 0;\n                if (!swiper.isHorizontal()) {\n                    ty = tx;\n                    tx = 0;\n                    rotateX = -rotateY;\n                    rotateY = 0;\n                } else if (rtl) rotateY = -rotateY;\n                slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n                if (params.slideShadows) createSlideShadows(slideEl, progress);\n                const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements\n            });\n        };\n        effectInit({\n            effect: \"flip\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            recreateShadows: recreateShadows,\n            getEffectParams: ()=>swiper.params.flipEffect,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    slidesPerView: 1,\n                    slidesPerGroup: 1,\n                    watchSlidesProgress: true,\n                    spaceBetween: 0,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCoverflow(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            coverflowEffect: {\n                rotate: 50,\n                stretch: 0,\n                depth: 100,\n                scale: 1,\n                modifier: 1,\n                slideShadows: true\n            }\n        });\n        const setTranslate = ()=>{\n            const { width: swiperWidth, height: swiperHeight, slides: slides, slidesSizesGrid: slidesSizesGrid } = swiper;\n            const params = swiper.params.coverflowEffect;\n            const isHorizontal = swiper.isHorizontal();\n            const transform = swiper.translate;\n            const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n            const rotate = isHorizontal ? params.rotate : -params.rotate;\n            const translate = params.depth;\n            // Each slide offset from center\n            for(let i = 0, length = slides.length; i < length; i += 1){\n                const slideEl = slides[i];\n                const slideSize = slidesSizesGrid[i];\n                const slideOffset = slideEl.swiperSlideOffset;\n                const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n                const offsetMultiplier = typeof params.modifier === \"function\" ? params.modifier(centerOffset) : centerOffset * params.modifier;\n                let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n                let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n                // var rotateZ = 0\n                let translateZ = -translate * Math.abs(offsetMultiplier);\n                let stretch = params.stretch;\n                // Allow percentage to make a relative stretch for responsive sliders\n                if (typeof stretch === \"string\" && stretch.indexOf(\"%\") !== -1) stretch = parseFloat(params.stretch) / 100 * slideSize;\n                let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n                let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n                let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n                // Fix for ultra small values\n                if (Math.abs(translateX) < 0.001) translateX = 0;\n                if (Math.abs(translateY) < 0.001) translateY = 0;\n                if (Math.abs(translateZ) < 0.001) translateZ = 0;\n                if (Math.abs(rotateY) < 0.001) rotateY = 0;\n                if (Math.abs(rotateX) < 0.001) rotateX = 0;\n                if (Math.abs(scale) < 0.001) scale = 0;\n                const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = slideTransform;\n                slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n                if (params.slideShadows) {\n                    // Set shadows\n                    let shadowBeforeEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-left\") : slideEl.querySelector(\".swiper-slide-shadow-top\");\n                    let shadowAfterEl = isHorizontal ? slideEl.querySelector(\".swiper-slide-shadow-right\") : slideEl.querySelector(\".swiper-slide-shadow-bottom\");\n                    if (!shadowBeforeEl) shadowBeforeEl = createShadow(\"coverflow\", slideEl, isHorizontal ? \"left\" : \"top\");\n                    if (!shadowAfterEl) shadowAfterEl = createShadow(\"coverflow\", slideEl, isHorizontal ? \"right\" : \"bottom\");\n                    if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n                    if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n                }\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n        };\n        effectInit({\n            effect: \"coverflow\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true\n                })\n        });\n    }\n    function EffectCreative(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            creativeEffect: {\n                limitProgress: 1,\n                shadowPerProgress: false,\n                progressMultiplier: 1,\n                perspective: true,\n                prev: {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    opacity: 1,\n                    scale: 1\n                },\n                next: {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    opacity: 1,\n                    scale: 1\n                }\n            }\n        });\n        const getTranslateValue = (value)=>{\n            if (typeof value === \"string\") return value;\n            return `${value}px`;\n        };\n        const setTranslate = ()=>{\n            const { slides: slides, wrapperEl: wrapperEl, slidesSizesGrid: slidesSizesGrid } = swiper;\n            const params = swiper.params.creativeEffect;\n            const { progressMultiplier: multiplier } = params;\n            const isCenteredSlides = swiper.params.centeredSlides;\n            if (isCenteredSlides) {\n                const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n                wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n            }\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                const slideProgress = slideEl.progress;\n                const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n                let originalProgress = progress;\n                if (!isCenteredSlides) originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n                const offset = slideEl.swiperSlideOffset;\n                const t = [\n                    swiper.params.cssMode ? -offset - swiper.translate : -offset,\n                    0,\n                    0\n                ];\n                const r = [\n                    0,\n                    0,\n                    0\n                ];\n                let custom = false;\n                if (!swiper.isHorizontal()) {\n                    t[1] = t[0];\n                    t[0] = 0;\n                }\n                let data = {\n                    translate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    rotate: [\n                        0,\n                        0,\n                        0\n                    ],\n                    scale: 1,\n                    opacity: 1\n                };\n                if (progress < 0) {\n                    data = params.next;\n                    custom = true;\n                } else if (progress > 0) {\n                    data = params.prev;\n                    custom = true;\n                }\n                // set translate\n                t.forEach((value, index)=>{\n                    t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n                });\n                // set rotates\n                r.forEach((value, index)=>{\n                    r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n                });\n                slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n                const translateString = t.join(\", \");\n                const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n                const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n                const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n                const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n                // Set shadows\n                if (custom && data.shadow || !custom) {\n                    let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n                    if (!shadowEl && data.shadow) shadowEl = createShadow(\"creative\", slideEl);\n                    if (shadowEl) {\n                        const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n                        shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n                    }\n                }\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n                targetEl.style.opacity = opacityString;\n                if (data.origin) targetEl.style.transformOrigin = data.origin;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements,\n                allSlides: true\n            });\n        };\n        effectInit({\n            effect: \"creative\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>swiper.params.creativeEffect.perspective,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    function EffectCards(_ref) {\n        let { swiper: swiper, extendParams: extendParams, on: on } = _ref;\n        extendParams({\n            cardsEffect: {\n                slideShadows: true,\n                rotate: true,\n                perSlideRotate: 2,\n                perSlideOffset: 8\n            }\n        });\n        const setTranslate = ()=>{\n            const { slides: slides, activeIndex: activeIndex, rtlTranslate: rtl } = swiper;\n            const params = swiper.params.cardsEffect;\n            const { startTranslate: startTranslate, isTouched: isTouched } = swiper.touchEventsData;\n            const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n            for(let i = 0; i < slides.length; i += 1){\n                const slideEl = slides[i];\n                const slideProgress = slideEl.progress;\n                const progress = Math.min(Math.max(slideProgress, -4), 4);\n                let offset = slideEl.swiperSlideOffset;\n                if (swiper.params.centeredSlides && !swiper.params.cssMode) swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n                if (swiper.params.centeredSlides && swiper.params.cssMode) offset -= slides[0].swiperSlideOffset;\n                let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n                let tY = 0;\n                const tZ = -100 * Math.abs(progress);\n                let scale = 1;\n                let rotate = -params.perSlideRotate * progress;\n                let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n                const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n                const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n                const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n                if (isSwipeToNext || isSwipeToPrev) {\n                    const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n                    rotate += -28 * progress * subProgress;\n                    scale += -0.5 * subProgress;\n                    tXAdd += 96 * subProgress;\n                    tY = `${-25 * subProgress * Math.abs(progress)}%`;\n                }\n                if (progress < 0) // next\n                tX = `calc(${tX}px ${rtl ? \"-\" : \"+\"} (${tXAdd * Math.abs(progress)}%))`;\n                else if (progress > 0) // prev\n                tX = `calc(${tX}px ${rtl ? \"-\" : \"+\"} (-${tXAdd * Math.abs(progress)}%))`;\n                else tX = `${tX}px`;\n                if (!swiper.isHorizontal()) {\n                    const prevY = tY;\n                    tY = tX;\n                    tX = prevY;\n                }\n                const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n                /* eslint-disable */ const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n                /* eslint-enable */ if (params.slideShadows) {\n                    // Set shadows\n                    let shadowEl = slideEl.querySelector(\".swiper-slide-shadow\");\n                    if (!shadowEl) shadowEl = createShadow(\"cards\", slideEl);\n                    if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n                }\n                slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n                const targetEl = effectTarget(params, slideEl);\n                targetEl.style.transform = transform;\n            }\n        };\n        const setTransition = (duration)=>{\n            const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));\n            transformElements.forEach((el)=>{\n                el.style.transitionDuration = `${duration}ms`;\n                el.querySelectorAll(\".swiper-slide-shadow\").forEach((shadowEl)=>{\n                    shadowEl.style.transitionDuration = `${duration}ms`;\n                });\n            });\n            effectVirtualTransitionEnd({\n                swiper: swiper,\n                duration: duration,\n                transformElements: transformElements\n            });\n        };\n        effectInit({\n            effect: \"cards\",\n            swiper: swiper,\n            on: on,\n            setTranslate: setTranslate,\n            setTransition: setTransition,\n            perspective: ()=>true,\n            overwriteParams: ()=>({\n                    watchSlidesProgress: true,\n                    virtualTranslate: !swiper.params.cssMode\n                })\n        });\n    }\n    /**\n   * Swiper 10.1.0\n   * Most modern mobile touch slider and framework with hardware accelerated transitions\n   * https://swiperjs.com\n   *\n   * Copyright 2014-2023 Vladimir Kharlampidi\n   *\n   * Released under the MIT License\n   *\n   * Released on: August 1, 2023\n   */ // Swiper Class\n    const modules = [\n        Virtual,\n        Keyboard,\n        Mousewheel,\n        Navigation,\n        Pagination,\n        Scrollbar,\n        Parallax,\n        Zoom,\n        Controller,\n        A11y,\n        History,\n        HashNavigation,\n        Autoplay,\n        Thumb,\n        freeMode,\n        Grid,\n        Manipulation,\n        EffectFade,\n        EffectCube,\n        EffectFlip,\n        EffectCoverflow,\n        EffectCreative,\n        EffectCards\n    ];\n    Swiper.use(modules);\n    return Swiper;\n}();\n\n});\n\n\nparcelRequire.register(\"758Z4\", function(module, exports) {\n\n$parcel$export(module.exports, \"renderHeroSlider\", function () { return $527ff81843881d46$export$f841641769cf6254; });\n\nvar $RX4Re = parcelRequire(\"RX4Re\");\nfunction $527ff81843881d46$var$crateSlideMarkup(backdrop_path, title, overview, vote_average, id, name) {\n    return `\n<div\n  style=\"background-image: url('https://image.tmdb.org/t/p/original${backdrop_path}');\"\n  class=\"swiper-slide hero-img\">\n <div class=\"hero-gradient\">\n  <div class=\"hero-title-wrap\" data-swiper-parallax=\"-300\">\n    <h1 class=\"hero-title\">${title || name}</h1>\n  </div>\n  <div class=\"hero-description-wrap\" data-swiper-parallax=\"-400\">\n    <p class=\"hero-description\">${overview}</p>\n  </div>\n  <div class=\"hero-btn-wrap\" data-swiper-parallax=\"-450\" data-id=\"${id}\">\n  <button type=\"button\" class=\"hero-btn hero-btn-trailer\" id=\"hero-btn-trailer\" data-id=\"${id}\">\n    Watch trailer\n  </button>\n  <button type=\"button\" class=\"hero-btn hero-btn-more is-id\" id=\"hero-btn-more\"  data-modal-open data-id=\"${id}\" >\n    More details\n  </button></div>\n  </div>\n  </div>`;\n}\nfunction $527ff81843881d46$var$createMarkup(arr) {\n    return arr.map(({ backdrop_path: backdrop_path, title: title, overview: overview, vote_average: vote_average, id: id, name: name })=>{\n        return $527ff81843881d46$var$crateSlideMarkup(backdrop_path, title, overview, vote_average, id, name);\n    }).join(\" \");\n}\nfunction $527ff81843881d46$export$f841641769cf6254(arr) {\n    (0, $RX4Re.renderSwiper)();\n    const markup = $527ff81843881d46$var$createMarkup(arr);\n    document.querySelector(\".swiper-wrapper\").innerHTML = markup;\n    (0, $RX4Re.swiperInit)();\n}\n\n});\n\nparcelRequire.register(\"cxvFw\", function(module, exports) {\n\n$parcel$export(module.exports, \"onWatchTrailer\", function () { return $921121d4eacbf085$export$8b0b07c04ee595a3; });\nparcelRequire(\"6JpON\");\nparcelRequire(\"RX4Re\");\n\nvar $b7ONl = parcelRequire(\"b7ONl\");\n//!const trailerErrorKey = 'DB68T2s7gfI';\nconst $921121d4eacbf085$var$trailerRefs = {\n    erMod: document.querySelector(\".backdrop-oops\"),\n    erBtn: document.querySelector(\".close-modal-oops\"),\n    backDropRef: document.querySelector(\".trailer-backdrop\"),\n    trailerRef: document.querySelector(\".trailer-container\"),\n    trailerImg: document.querySelector(\"#trailer-img-err\")\n};\nfunction $921121d4eacbf085$export$8b0b07c04ee595a3(e) {\n    if (e.target.classList.contains(\"hero-btn-trailer\")) {\n        const dataId = e.target.dataset.id;\n        $921121d4eacbf085$export$a408a7ab7d56d7a7(dataId);\n    }\n}\nasync function $921121d4eacbf085$export$a408a7ab7d56d7a7(id) {\n    try {\n        const movieData = await (0, $b7ONl.getMovie)(id);\n        const trailerKey = movieData.results[0].key;\n        $921121d4eacbf085$export$76326022edea6404(trailerKey);\n    } catch (err) {\n        $921121d4eacbf085$var$trailerRefs.erMod.classList.remove(\"is-hidden\");\n        $921121d4eacbf085$var$addEventErr();\n    //! renderTrailer(trailerErrorKey);\n    //! Notify.warning(\n    //!   'OOPS... We are very sorry! But we couldn’t find the trailer.'\n    //! );\n    }\n}\nfunction $921121d4eacbf085$export$76326022edea6404(movieKey) {\n    document.body.classList.add(\"is-scroll-block\");\n    $921121d4eacbf085$var$trailerRefs.backDropRef.classList.remove(\"is-trailer-hidden\");\n    $921121d4eacbf085$var$trailerRefs.trailerRef.innerHTML = `<iframe class=\"trailer-iframe\" src='https://www.youtube.com/embed/${movieKey}\n  'frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n  <p>Oops! Trailer not found...</p>`;\n    $921121d4eacbf085$var$trailerRefs.backDropRef.addEventListener(\"click\", $921121d4eacbf085$var$listenBackdropClick);\n    document.body.addEventListener(\"keydown\", $921121d4eacbf085$var$listenKeyDawn);\n}\nconst $921121d4eacbf085$var$listenBackdropClick = (event)=>{\n    if (event.target.classList.contains(\"trailer-backdrop\")) $921121d4eacbf085$var$closeTrailer();\n};\nconst $921121d4eacbf085$var$listenKeyDawn = (event)=>{\n    if (event.key === \"Escape\" || event.keyCode === 27) $921121d4eacbf085$var$closeTrailer();\n};\nconst $921121d4eacbf085$var$closeTrailer = ()=>{\n    document.body.classList.remove(\"is-scroll-block\");\n    $921121d4eacbf085$var$trailerRefs.backDropRef.classList.add(\"is-trailer-hidden\");\n    $921121d4eacbf085$var$trailerRefs.trailerRef.innerHTML = \"\";\n    if (!window.location.href.includes(\"/my-lib-page.html\")) document.body.removeEventListener(\"keydown\", $921121d4eacbf085$var$listenKeyDawn);\n    $921121d4eacbf085$var$trailerRefs.backDropRef.removeEventListener(\"click\", $921121d4eacbf085$var$listenBackdropClick);\n};\n//?======\nfunction $921121d4eacbf085$var$addEventErr() {\n    $921121d4eacbf085$var$trailerRefs.erMod.addEventListener(\"click\", $921121d4eacbf085$var$onBackdropClick);\n    $921121d4eacbf085$var$trailerRefs.erBtn.addEventListener(\"click\", $921121d4eacbf085$var$clsModal);\n    document.addEventListener(\"keydown\", $921121d4eacbf085$var$keyBoardPress);\n}\nfunction $921121d4eacbf085$var$onBackdropClick(event) {\n    if (event.target === event.currentTarget) {\n        $921121d4eacbf085$var$trailerRefs.erMod.classList.add(\"is-hidden\");\n        $921121d4eacbf085$var$removeEventErr();\n    }\n}\nfunction $921121d4eacbf085$var$keyBoardPress(event) {\n    if (event.key === \"Escape\") {\n        $921121d4eacbf085$var$trailerRefs.erMod.classList.add(\"is-hidden\");\n        $921121d4eacbf085$var$removeEventErr();\n    }\n}\nfunction $921121d4eacbf085$var$removeEventErr() {\n    $921121d4eacbf085$var$trailerRefs.erMod.removeEventListener(\"click\", $921121d4eacbf085$var$onBackdropClick);\n    document.removeEventListener(\"keydown\", $921121d4eacbf085$var$keyBoardPress);\n    $921121d4eacbf085$var$trailerRefs.erBtn.removeEventListener(\"click\", $921121d4eacbf085$var$clsModal);\n}\nfunction $921121d4eacbf085$var$clsModal(event) {\n    $921121d4eacbf085$var$trailerRefs.erMod.classList.add(\"is-hidden\");\n    $921121d4eacbf085$var$removeEventErr();\n}\n\n});\nparcelRequire.register(\"b7ONl\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTrending\", function () { return $8197bff4c39d585a$export$998f00da2813713d; });\n$parcel$export(module.exports, \"getMovie\", function () { return $8197bff4c39d585a$export$bdba5afeee6501b; });\n\nvar $dIxxU = parcelRequire(\"dIxxU\");\n\nvar $kvC6y = parcelRequire(\"kvC6y\");\nconst $8197bff4c39d585a$var$BASE_URL = \"https://api.themoviedb.org/3\";\nconst $8197bff4c39d585a$var$API_KEY = \"5e0b2043a7bdefdf129debb784bbe1f7\";\nasync function $8197bff4c39d585a$var$fetchData(url) {\n    try {\n        (0, $kvC6y.onLoader)();\n        const response = await (0, $dIxxU.default).get(url);\n        (0, $kvC6y.removeLoader)();\n        return response.data;\n    } catch (error) {\n        (0, $kvC6y.removeLoader)();\n        return null;\n    }\n}\nasync function $8197bff4c39d585a$export$998f00da2813713d(page = 1) {\n    const url = `${$8197bff4c39d585a$var$BASE_URL}/trending/all/day?api_key=${$8197bff4c39d585a$var$API_KEY}&language=en-US&page=${page}`;\n    return await $8197bff4c39d585a$var$fetchData(url);\n}\nasync function $8197bff4c39d585a$export$c87dc303de80050b(page, query, date) {\n    const url = `${$8197bff4c39d585a$var$BASE_URL}/search/movie?api_key=${$8197bff4c39d585a$var$API_KEY}&query=${query}&page=${page}&language=en-US${date ? `&primary_release_year=${date}` : \"\"}`;\n    return await $8197bff4c39d585a$var$fetchData(url);\n}\nasync function $8197bff4c39d585a$export$2fe5122c268c835a(movie_id) {\n    const url = `${$8197bff4c39d585a$var$BASE_URL}/movie/${movie_id}?api_key=${$8197bff4c39d585a$var$API_KEY}&language=en-US`;\n    return await $8197bff4c39d585a$var$fetchData(url);\n}\nasync function $8197bff4c39d585a$export$bdba5afeee6501b(movie_id) {\n    const url = `${$8197bff4c39d585a$var$BASE_URL}/movie/${movie_id}/videos?api_key=${$8197bff4c39d585a$var$API_KEY}&language=en-US`;\n    return await $8197bff4c39d585a$var$fetchData(url);\n}\nasync function $8197bff4c39d585a$export$309cdc8140b34cc6(arr) {\n    const promises = arr.map(async (movie_id)=>{\n        const url = `${$8197bff4c39d585a$var$BASE_URL}/movie/${movie_id}?api_key=${$8197bff4c39d585a$var$API_KEY}&language=en-US`;\n        return $8197bff4c39d585a$var$fetchData(url);\n    });\n    return await Promise.all(promises);\n}\n// ================== add =============\nasync function $8197bff4c39d585a$export$ee110806344d6b64(page = 1) {\n    const url = `${$8197bff4c39d585a$var$BASE_URL}/trending/all/day?api_key=${$8197bff4c39d585a$var$API_KEY}&language=en-US&page=${page}`;\n    return await $8197bff4c39d585a$var$fetchData(url);\n}\nasync function $8197bff4c39d585a$export$2cb6491f12c0db0a(formattedStartDate, formattedEndDate) {\n    const url = `${$8197bff4c39d585a$var$BASE_URL}/discover/movie?api_key=${$8197bff4c39d585a$var$API_KEY}&&primary_release_date.gte=${formattedStartDate}&primary_release_date.lte=${formattedEndDate}`;\n    return await $8197bff4c39d585a$var$fetchData(url);\n}\nasync function $8197bff4c39d585a$export$11ff5302ebb1cd30() {\n    const url = `${$8197bff4c39d585a$var$BASE_URL}/genre/movie/list?api_key=${$8197bff4c39d585a$var$API_KEY}&language=en-USs`;\n    return await $8197bff4c39d585a$var$fetchData(url);\n}\n\n});\nparcelRequire.register(\"kvC6y\", function(module, exports) {\n\n$parcel$export(module.exports, \"onLoader\", function () { return $03da642c15b09e5e$export$bb9bc927e7d77389; });\n$parcel$export(module.exports, \"removeLoader\", function () { return $03da642c15b09e5e$export$5303cf8b8f096deb; });\n\nvar $7rQOT = parcelRequire(\"7rQOT\");\nfunction $03da642c15b09e5e$export$bb9bc927e7d77389() {\n    (0, $7rQOT.Loading).dots({\n        svgColor: \"orange\",\n        svgSize: \"100px\",\n        messageFontSize: \"25px\",\n        clickToClose: true\n    });\n}\nfunction $03da642c15b09e5e$export$5303cf8b8f096deb() {\n    (0, $7rQOT.Loading).remove();\n}\n\n});\nparcelRequire.register(\"7rQOT\", function(module, exports) {\n/*\n* Notiflix Loading AIO (https://notiflix.github.io)\n* Description: This file has been created automatically that using \"notiflix.js\", and \"notiflix.css\" files.\n* Version: 3.2.6\n* Author: Furkan (https://github.com/furcan)\n* Copyright 2019 - 2023 Notiflix, MIT Licence (https://opensource.org/licenses/MIT)\n*/ /* global define */ (function(root, factory) {\n    if (typeof define === \"function\" && define.amd) define([], function() {\n        return factory(root);\n    });\n    else if (typeof module.exports === \"object\") module.exports = factory(root);\n    else root.Notiflix = factory(root);\n})(typeof $parcel$global !== \"undefined\" ? $parcel$global : typeof window !== \"undefined\" ? window : module.exports, function(window1) {\n    \"use strict\";\n    // COMMON: SSR check: begin\n    if (typeof window1 === \"undefined\" && typeof window1.document === \"undefined\") return false;\n    // COMMON: SSR check: end\n    // COMMON: Variables: begin\n    var notiflixNamespace = \"Notiflix\";\n    var notiflixConsoleDocs = \"\\n\\nVisit documentation page to learn more: https://notiflix.github.io/documentation\";\n    var defaultFontFamily = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif';\n    // COMMON: Variables: end\n    // LOADING: Default Settings: begin\n    var typesLoading = {\n        Standard: \"Standard\",\n        Hourglass: \"Hourglass\",\n        Circle: \"Circle\",\n        Arrows: \"Arrows\",\n        Dots: \"Dots\",\n        Pulse: \"Pulse\",\n        Custom: \"Custom\",\n        Notiflix: \"Notiflix\"\n    };\n    var newLoadingSettings;\n    var loadingSettings = {\n        ID: \"NotiflixLoadingWrap\",\n        className: \"notiflix-loading\",\n        zindex: 4000,\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        rtl: false,\n        fontFamily: \"Quicksand\",\n        cssAnimation: true,\n        cssAnimationDuration: 400,\n        clickToClose: false,\n        customSvgUrl: null,\n        customSvgCode: null,\n        svgSize: \"80px\",\n        svgColor: \"#32c682\",\n        messageID: \"NotiflixLoadingMessage\",\n        messageFontSize: \"15px\",\n        messageMaxLength: 34,\n        messageColor: \"#dcdcdc\"\n    };\n    // LOADING: Default Settings: end\n    // COMMON: Console Error: begin\n    var commonConsoleError = function(message) {\n        return console.error(\"%c \" + notiflixNamespace + \" Error \", \"padding:2px;border-radius:20px;color:#fff;background:#ff5549\", \"\\n\" + message + notiflixConsoleDocs);\n    };\n    // COMMON: Console Error: end\n    // COMMON: Check Head or Body: begin\n    var commonCheckHeadOrBody = function(element) {\n        if (!element) element = \"head\";\n        if (window1.document[element] === null) {\n            commonConsoleError('\\nNotiflix needs to be appended to the \"<' + element + '>\" element, but you called it before the \"<' + element + '>\" element has been created.');\n            return false;\n        }\n        return true;\n    };\n    // COMMON: Check Head or Body: end\n    // COMMON: Set Internal CSS Codes: begin\n    var commonSetInternalCSSCodes = function(getInternalCSSCodes, styleElementId) {\n        // check doc head\n        if (!commonCheckHeadOrBody(\"head\")) return false;\n        // internal css\n        if (getInternalCSSCodes() !== null && !window1.document.getElementById(styleElementId)) {\n            var internalCSS = window1.document.createElement(\"style\");\n            internalCSS.id = styleElementId;\n            internalCSS.innerHTML = getInternalCSSCodes();\n            window1.document.head.appendChild(internalCSS);\n        }\n    };\n    // COMMON: Set Internal CSS Codes: end\n    // COMMON: Extend Options: begin\n    var commonExtendOptions = function() {\n        // variables\n        var extended = {};\n        var deep = false;\n        var i = 0;\n        // check if a deep merge\n        if (Object.prototype.toString.call(arguments[0]) === \"[object Boolean]\") {\n            deep = arguments[0];\n            i++;\n        }\n        // merge the object into the extended object\n        var merge = function(obj) {\n            for(var prop in obj)if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                // if property is an object, merge properties\n                if (deep && Object.prototype.toString.call(obj[prop]) === \"[object Object]\") extended[prop] = commonExtendOptions(extended[prop], obj[prop]);\n                else extended[prop] = obj[prop];\n            }\n        };\n        // loop through each object and conduct a merge\n        for(; i < arguments.length; i++)merge(arguments[i]);\n        return extended;\n    };\n    // COMMON: Extend Options: end\n    // COMMON: Get Plaintext: begin\n    var commonGetPlaintext = function(html) {\n        var htmlPool = window1.document.createElement(\"div\");\n        htmlPool.innerHTML = html;\n        return htmlPool.textContent || htmlPool.innerText || \"\";\n    };\n    // COMMON: Get Plaintext: end\n    // LOADING && BLOCK: SVG Icon Standard: begin\n    var loadingAndBlockSvgIconStandard = function(width, color) {\n        if (!width) width = \"60px\";\n        if (!color) color = \"#32c682\";\n        var standard = '<svg xmlns=\"http://www.w3.org/2000/svg\" stroke=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" transform=\"scale(.8)\" viewBox=\"0 0 38 38\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\" transform=\"translate(1 1)\"><circle cx=\"18\" cy=\"18\" r=\"18\" stroke-opacity=\".25\"/><path d=\"M36 18c0-9.94-8.06-18-18-18\"><animateTransform attributeName=\"transform\" dur=\"1s\" from=\"0 18 18\" repeatCount=\"indefinite\" to=\"360 18 18\" type=\"rotate\"/></path></g></svg>';\n        return standard;\n    };\n    // LOADING && BLOCK: SVG Icon Standard: end\n    // LOADING && BLOCK: SVG Icon Hourglass: begin\n    var loadingAndBlockSvgIconHourglass = function(width, color) {\n        if (!width) width = \"60px\";\n        if (!color) color = \"#32c682\";\n        var hourglass = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXLoadingHourglass\" fill=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 200 200\"><style>@-webkit-keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@-webkit-keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}@keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}#NXLoadingHourglass *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g data-animator-group=\"true\" data-animator-type=\"1\" style=\"-webkit-animation-name:NXhourglass1-animation;animation-name:NXhourglass1-animation;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transform-box:fill-box\"><g id=\"NXhourglass2\" fill=\"inherit\"><g data-animator-group=\"true\" data-animator-type=\"2\" style=\"-webkit-animation-name:NXhourglass3-animation;animation-name:NXhourglass3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\" opacity=\".4\"><path id=\"NXhourglass4\" d=\"M100 100l-34.38 32.08v31.14h68.76v-31.14z\"/></g><g data-animator-group=\"true\" data-animator-type=\"2\" style=\"-webkit-animation-name:NXhourglass5-animation;animation-name:NXhourglass5-animation;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\" opacity=\".4\"><path id=\"NXhourglass6\" d=\"M100 100L65.62 67.92V36.78h68.76v31.14z\"/></g><path d=\"M51.14 38.89h8.33v14.93c0 15.1 8.29 28.99 23.34 39.1 1.88 1.25 3.04 3.97 3.04 7.08s-1.16 5.83-3.04 7.09c-15.05 10.1-23.34 23.99-23.34 39.09v14.93h-8.33a4.859 4.859 0 1 0 0 9.72h97.72a4.859 4.859 0 1 0 0-9.72h-8.33v-14.93c0-15.1-8.29-28.99-23.34-39.09-1.88-1.26-3.04-3.98-3.04-7.09s1.16-5.83 3.04-7.08c15.05-10.11 23.34-24 23.34-39.1V38.89h8.33a4.859 4.859 0 1 0 0-9.72H51.14a4.859 4.859 0 1 0 0 9.72zm79.67 14.93c0 15.87-11.93 26.25-19.04 31.03-4.6 3.08-7.34 8.75-7.34 15.15 0 6.41 2.74 12.07 7.34 15.15 7.11 4.78 19.04 15.16 19.04 31.03v14.93H69.19v-14.93c0-15.87 11.93-26.25 19.04-31.02 4.6-3.09 7.34-8.75 7.34-15.16 0-6.4-2.74-12.07-7.34-15.15-7.11-4.78-19.04-15.16-19.04-31.03V38.89h61.62v14.93z\"/></g></g></svg>';\n        return hourglass;\n    };\n    // LOADING && BLOCK: SVG Icon Hourglass: end\n    // LOADING && BLOCK: SVG Icon Circle: begin\n    var loadingAndBlockSvgIconCircle = function(width, color) {\n        if (!width) width = \"60px\";\n        if (!color) color = \"#32c682\";\n        var circle = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"25 25 50 50\" style=\"-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite;height:' + width + \";-webkit-transform-origin:center center;-ms-transform-origin:center center;transform-origin:center center;width:\" + width + ';position:absolute;top:0;left:0;margin:auto\"><style>@-webkit-keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}@keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}</style><circle cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke=\"' + color + '\" stroke-width=\"2\" style=\"-webkit-animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite\" stroke-dasharray=\"150 200\" stroke-dashoffset=\"-10\" stroke-linecap=\"round\"/></svg>';\n        return circle;\n    };\n    // LOADING && BLOCK: SVG Icon Circle: end\n    // LOADING && BLOCK: SVG Icon Arrows: begin\n    var loadingAndBlockSvgIconArrows = function(width, color) {\n        if (!width) width = \"60px\";\n        if (!color) color = \"#32c682\";\n        var arrows = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 128 128\"><g><path fill=\"inherit\" d=\"M109.25 55.5h-36l12-12a29.54 29.54 0 0 0-49.53 12H18.75A46.04 46.04 0 0 1 96.9 31.84l12.35-12.34v36zm-90.5 17h36l-12 12a29.54 29.54 0 0 0 49.53-12h16.97A46.04 46.04 0 0 1 31.1 96.16L18.74 108.5v-36z\"/><animateTransform attributeName=\"transform\" dur=\"1.5s\" from=\"0 64 64\" repeatCount=\"indefinite\" to=\"360 64 64\" type=\"rotate\"/></g></svg>';\n        return arrows;\n    };\n    // LOADING && BLOCK: SVG Icon Arrows: end\n    // LOADING && BLOCK: SVG Icon Dots: begin\n    var loadingAndBlockSvgIconDots = function(width, color) {\n        if (!width) width = \"60px\";\n        if (!color) color = \"#32c682\";\n        var dots = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 100 100\"><g transform=\"translate(25 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.239)\"><animateTransform attributeName=\"transform\" begin=\"-0.266s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g><g transform=\"translate(50 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.00152)\"><animateTransform attributeName=\"transform\" begin=\"-0.133s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g><g transform=\"translate(75 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.299)\"><animateTransform attributeName=\"transform\" begin=\"0s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g></svg>';\n        return dots;\n    };\n    // LOADING && BLOCK: SVG Icon Dots: end\n    // LOADING && BLOCK: SVG Icon Pulse: begin\n    var loadingAndBlockSvgIconPulse = function(width, color) {\n        if (!width) width = \"60px\";\n        if (!color) color = \"#32c682\";\n        var pulse = '<svg xmlns=\"http://www.w3.org/2000/svg\" stroke=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 44 44\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\"><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle></g></svg>';\n        return pulse;\n    };\n    // LOADING && BLOCK: SVG Icon Pulse: end\n    // LOADING && BLOCK: SVG Icon Notiflix: begin\n    var loadingAndBlockSvgIconNotiflix = function(width, white, green) {\n        if (!width) width = \"60px\";\n        if (!white) white = \"#f8f8f8\";\n        if (!green) green = \"#32c682\";\n        var notiflixIcon = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXLoadingNotiflixLib\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 200 200\"><defs><style>@keyframes notiflix-n{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-x{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-dot{0%,to{stroke-width:0}50%{stroke-width:12}}.nx-icon-line{stroke:' + white + ';stroke-width:12;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:22;fill:none}</style></defs><path d=\"M47.97 135.05a6.5 6.5 0 1 1 0 13 6.5 6.5 0 0 1 0-13z\" style=\"animation-name:notiflix-dot;animation-timing-function:ease-in-out;animation-duration:1.25s;animation-iteration-count:infinite;animation-direction:normal\" fill=\"' + green + '\" stroke=\"' + green + '\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"22\" stroke-width=\"12\"/><path class=\"nx-icon-line\" d=\"M10.14 144.76V87.55c0-5.68-4.54-41.36 37.83-41.36 42.36 0 37.82 35.68 37.82 41.36v57.21\" style=\"animation-name:notiflix-n;animation-timing-function:linear;animation-duration:2.5s;animation-delay:0s;animation-iteration-count:infinite;animation-direction:normal\" stroke-dasharray=\"500\"/><path class=\"nx-icon-line\" d=\"M115.06 144.49c24.98-32.68 49.96-65.35 74.94-98.03M114.89 46.6c25.09 32.58 50.19 65.17 75.29 97.75\" style=\"animation-name:notiflix-x;animation-timing-function:linear;animation-duration:2.5s;animation-delay:.2s;animation-iteration-count:infinite;animation-direction:normal\" stroke-dasharray=\"500\"/></svg>';\n        return notiflixIcon;\n    };\n    // LOADING && BLOCK: SVG Icon Notiflix: end\n    // LOADING: Get Internal CSS Codes: begin\n    var loadingGetInternalCSSCodes = function() {\n        var loadingCSS = '[id^=NotiflixLoadingWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:fixed;z-index:4000;width:100%;height:100%;left:0;top:0;right:0;bottom:0;margin:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;background:rgba(0,0,0,.8);font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif}[id^=NotiflixLoadingWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixLoadingWrap].nx-loading-click-to-close{cursor:pointer}[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"]{width:60px;height:60px;position:relative;-webkit-transition:top .2s ease-in-out;-o-transition:top .2s ease-in-out;transition:top .2s ease-in-out;margin:0 auto}[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"] img,[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"] svg{max-width:unset;max-height:unset;width:100%;height:auto;position:absolute;left:0;top:0}[id^=NotiflixLoadingWrap]>p{position:relative;margin:10px auto 0;font-family:inherit!important;font-weight:normal;font-size:15px;line-height:1.4;padding:0 10px;width:100%;text-align:center}[id^=NotiflixLoadingWrap].nx-with-animation{-webkit-animation:loading-animation-fade .3s ease-in-out 0s normal;animation:loading-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixLoadingWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:loading-animation-fade-remove .3s ease-in-out 0s normal;animation:loading-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixLoadingWrap]>p.nx-loading-message-new{-webkit-animation:loading-new-message-fade .3s ease-in-out 0s normal;animation:loading-new-message-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}';\n        return loadingCSS || null;\n    };\n    // LOADING: Get Internal CSS Codes: end\n    // LOADING: Create: begin\n    var loadingCreate = function(loadingType, messageOrOptions, options, display, delay) {\n        // check doc body\n        if (!commonCheckHeadOrBody(\"body\")) return false;\n        // if not initialized pretend like init\n        if (!newLoadingSettings) Notiflix.Loading.init({});\n        // create a backup for new settings\n        var newLoadingSettingsBackup = commonExtendOptions(true, newLoadingSettings, {});\n        // check \"messageOrOptions\" and \"options\": begin\n        if (typeof messageOrOptions === \"object\" && !Array.isArray(messageOrOptions) || typeof options === \"object\" && !Array.isArray(options)) {\n            // new options\n            var newOptions = {};\n            if (typeof messageOrOptions === \"object\") newOptions = messageOrOptions;\n            else if (typeof options === \"object\") newOptions = options;\n            // extend new settings with the new options\n            newLoadingSettings = commonExtendOptions(true, newLoadingSettings, newOptions);\n        }\n        // check \"messageOrOptions\" and \"options\": end\n        // check the message\n        var message = \"\";\n        if (typeof messageOrOptions === \"string\" && messageOrOptions.length > 0) message = messageOrOptions;\n        // show loading\n        if (display) {\n            // if message settings: begin\n            if (message.length > newLoadingSettings.messageMaxLength) message = commonGetPlaintext(message).toString().substring(0, newLoadingSettings.messageMaxLength) + \"...\";\n            else message = commonGetPlaintext(message).toString();\n            var messageHTML = \"\";\n            if (message.length > 0) messageHTML = '<p id=\"' + newLoadingSettings.messageID + '\" class=\"nx-loading-message\" style=\"color:' + newLoadingSettings.messageColor + \";font-size:\" + newLoadingSettings.messageFontSize + ';\">' + message + \"</p>\";\n            // if message settings: end\n            // if cssAnimaion is false => duration: begin\n            if (!newLoadingSettings.cssAnimation) newLoadingSettings.cssAnimationDuration = 0;\n            // if cssAnimaion is false => duration: end\n            // svgIcon: begin\n            var svgIcon = \"\";\n            if (loadingType === typesLoading.Standard) svgIcon = loadingAndBlockSvgIconStandard(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n            else if (loadingType === typesLoading.Hourglass) svgIcon = loadingAndBlockSvgIconHourglass(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n            else if (loadingType === typesLoading.Circle) svgIcon = loadingAndBlockSvgIconCircle(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n            else if (loadingType === typesLoading.Arrows) svgIcon = loadingAndBlockSvgIconArrows(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n            else if (loadingType === typesLoading.Dots) svgIcon = loadingAndBlockSvgIconDots(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n            else if (loadingType === typesLoading.Pulse) svgIcon = loadingAndBlockSvgIconPulse(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n            else if (loadingType === typesLoading.Custom && newLoadingSettings.customSvgCode !== null && newLoadingSettings.customSvgUrl === null) svgIcon = newLoadingSettings.customSvgCode || \"\";\n            else if (loadingType === typesLoading.Custom && newLoadingSettings.customSvgUrl !== null && newLoadingSettings.customSvgCode === null) svgIcon = '<img class=\"nx-custom-loading-icon\" width=\"' + newLoadingSettings.svgSize + '\" height=\"' + newLoadingSettings.svgSize + '\" src=\"' + newLoadingSettings.customSvgUrl + '\" alt=\"Notiflix\">';\n            else if (loadingType === typesLoading.Custom && (newLoadingSettings.customSvgUrl === null || newLoadingSettings.customSvgCode === null)) {\n                commonConsoleError('You have to set a static SVG url to \"customSvgUrl\" option to use Loading Custom.');\n                return false;\n            } else svgIcon = loadingAndBlockSvgIconNotiflix(newLoadingSettings.svgSize, \"#f8f8f8\", \"#32c682\");\n            var svgSizeAsDigit = parseInt((newLoadingSettings.svgSize || \"\").replace(/[^0-9]/g, \"\"));\n            var winWidth = window1.innerWidth;\n            var maxSvgWidthPx = svgSizeAsDigit >= winWidth ? winWidth - 40 + \"px\" : svgSizeAsDigit + \"px\";\n            var svgIconHTML = '<div style=\"width:' + maxSvgWidthPx + \"; height:\" + maxSvgWidthPx + ';\" class=\"' + newLoadingSettings.className + \"-icon\" + (message.length > 0 ? \" nx-with-message\" : \"\") + '\">' + svgIcon + \"</div>\";\n            // svgIcon: end\n            // loading wrap: begin\n            var ntflxLoadingWrap = window1.document.createElement(\"div\");\n            ntflxLoadingWrap.id = loadingSettings.ID;\n            ntflxLoadingWrap.className = newLoadingSettings.className + (newLoadingSettings.cssAnimation ? \" nx-with-animation\" : \"\") + (newLoadingSettings.clickToClose ? \" nx-loading-click-to-close\" : \"\");\n            ntflxLoadingWrap.style.zIndex = newLoadingSettings.zindex;\n            ntflxLoadingWrap.style.background = newLoadingSettings.backgroundColor;\n            ntflxLoadingWrap.style.animationDuration = newLoadingSettings.cssAnimationDuration + \"ms\";\n            ntflxLoadingWrap.style.fontFamily = '\"' + newLoadingSettings.fontFamily + '\", ' + defaultFontFamily;\n            ntflxLoadingWrap.style.display = \"flex\";\n            ntflxLoadingWrap.style.flexWrap = \"wrap\";\n            ntflxLoadingWrap.style.flexDirection = \"column\";\n            ntflxLoadingWrap.style.alignItems = \"center\";\n            ntflxLoadingWrap.style.justifyContent = \"center\";\n            // rtl: begin\n            if (newLoadingSettings.rtl) {\n                ntflxLoadingWrap.setAttribute(\"dir\", \"rtl\");\n                ntflxLoadingWrap.classList.add(\"nx-rtl-on\");\n            }\n            // rtl: end\n            // append: begin\n            ntflxLoadingWrap.innerHTML = svgIconHTML + messageHTML;\n            // if there is no loading element\n            if (!window1.document.getElementById(ntflxLoadingWrap.id)) {\n                // append\n                window1.document.body.appendChild(ntflxLoadingWrap);\n                // if click to close\n                if (newLoadingSettings.clickToClose) {\n                    var loadingWrapElm = window1.document.getElementById(ntflxLoadingWrap.id);\n                    loadingWrapElm.addEventListener(\"click\", function() {\n                        ntflxLoadingWrap.classList.add(\"nx-remove\");\n                        var timeout = setTimeout(function() {\n                            if (ntflxLoadingWrap.parentNode !== null) {\n                                ntflxLoadingWrap.parentNode.removeChild(ntflxLoadingWrap);\n                                clearTimeout(timeout);\n                            }\n                        }, newLoadingSettings.cssAnimationDuration);\n                    });\n                }\n            }\n        // append: end\n        } else // if there is a loading element\n        if (window1.document.getElementById(loadingSettings.ID)) {\n            var loadingElm = window1.document.getElementById(loadingSettings.ID);\n            var timeout = setTimeout(function() {\n                loadingElm.classList.add(\"nx-remove\");\n                var timeout2 = setTimeout(function() {\n                    if (loadingElm.parentNode !== null) {\n                        loadingElm.parentNode.removeChild(loadingElm);\n                        clearTimeout(timeout2);\n                    }\n                }, newLoadingSettings.cssAnimationDuration);\n                clearTimeout(timeout);\n            }, delay);\n        }\n        // extend new settings with the backup settings\n        newLoadingSettings = commonExtendOptions(true, newLoadingSettings, newLoadingSettingsBackup);\n    };\n    // LOADING: Create: end\n    // LOADING: Change Message: begin\n    var loadingChangeMessage = function(newMessage) {\n        // check the new message\n        if (typeof newMessage !== \"string\") newMessage = \"\";\n        // if has any loading\n        var messageWrap = window1.document.getElementById(loadingSettings.ID);\n        if (messageWrap) {\n            // if there is a new message\n            if (newMessage.length > 0) {\n                // max length: begin\n                if (newMessage.length > newLoadingSettings.messageMaxLength) newMessage = commonGetPlaintext(newMessage).substring(0, newLoadingSettings.messageMaxLength) + \"...\";\n                else newMessage = commonGetPlaintext(newMessage);\n                // max length: end\n                // there is a message element\n                var oldMessageElm = messageWrap.getElementsByTagName(\"p\")[0];\n                if (oldMessageElm) oldMessageElm.innerHTML = newMessage; // change the message\n                else {\n                    // create a new message element: begin\n                    var newMessageHTML = window1.document.createElement(\"p\");\n                    newMessageHTML.id = newLoadingSettings.messageID;\n                    newMessageHTML.className = \"nx-loading-message nx-loading-message-new\";\n                    newMessageHTML.style.color = newLoadingSettings.messageColor;\n                    newMessageHTML.style.fontSize = newLoadingSettings.messageFontSize;\n                    newMessageHTML.innerHTML = newMessage;\n                    messageWrap.appendChild(newMessageHTML);\n                // create a new message element: end\n                }\n            } else commonConsoleError(\"Where is the new message?\");\n        }\n    };\n    // LOADING: Change Message: end\n    var Notiflix = {\n        Loading: {\n            // Init\n            init: function(userLoadingOptions) {\n                // extend options\n                newLoadingSettings = commonExtendOptions(true, loadingSettings, userLoadingOptions);\n                // internal css if exist\n                commonSetInternalCSSCodes(loadingGetInternalCSSCodes, \"NotiflixLoadingInternalCSS\");\n            },\n            // Merge First Init\n            merge: function(userLoadingExtendOptions) {\n                // if initialized already\n                if (newLoadingSettings) newLoadingSettings = commonExtendOptions(true, newLoadingSettings, userLoadingExtendOptions);\n                else {\n                    commonConsoleError(\"You have to initialize the Loading module before call Merge function.\");\n                    return false;\n                }\n            },\n            // Standard\n            standard: function(messageOrOptions, options) {\n                loadingCreate(typesLoading.Standard, messageOrOptions, options, true, 0); // true => show && 0 => delay\n            },\n            // Hourglass\n            hourglass: function(messageOrOptions, options) {\n                loadingCreate(typesLoading.Hourglass, messageOrOptions, options, true, 0); // true => show && 0 => delay\n            },\n            // Circle\n            circle: function(messageOrOptions, options) {\n                loadingCreate(typesLoading.Circle, messageOrOptions, options, true, 0); // true => show && 0 => delay\n            },\n            // Arrows\n            arrows: function(messageOrOptions, options) {\n                loadingCreate(typesLoading.Arrows, messageOrOptions, options, true, 0); // true => show && 0 => delay\n            },\n            // Dots\n            dots: function(messageOrOptions, options) {\n                loadingCreate(typesLoading.Dots, messageOrOptions, options, true, 0); // true => show && 0 => delay\n            },\n            // Pulse\n            pulse: function(messageOrOptions, options) {\n                loadingCreate(typesLoading.Pulse, messageOrOptions, options, true, 0); // true => show && 0 => delay\n            },\n            // Custom\n            custom: function(messageOrOptions, options) {\n                loadingCreate(typesLoading.Custom, messageOrOptions, options, true, 0); // true => show && 0 => delay\n            },\n            // Notiflix\n            notiflix: function(messageOrOptions, options) {\n                loadingCreate(typesLoading.Notiflix, messageOrOptions, options, true, 0); // true => show && 0 => delay\n            },\n            // Remove\n            remove: function(delay) {\n                if (typeof delay !== \"number\") delay = 0;\n                loadingCreate(null, null, null, false, delay); // false => hide/remove\n            },\n            // Change The Message\n            change: function(newMessage) {\n                loadingChangeMessage(newMessage);\n            }\n        }\n    };\n    if (typeof window1.Notiflix === \"object\") return commonExtendOptions(true, window1.Notiflix, {\n        Loading: Notiflix.Loading\n    });\n    else return {\n        Loading: Notiflix.Loading\n    };\n});\n\n});\n\n\n\n\n\n})();\n//# sourceMappingURL=catalog.b216e0c8.js.map\n","import { swiper } from './swiper';\nimport { renderHeroSlider } from './heroUi';\nimport { onWatchTrailer } from './trailer-modal';\nimport { getTrending } from './api';\nimport { Notify } from 'notiflix';\n\nconst heroRefs = {\n  hero: document.querySelector('.hero'),\n  backDropRef: document.querySelector('.hero-trailer-backdrop'),\n  trailerRef: document.querySelector('.trailer-container'),\n  trailerBtn: document.querySelector('.modal-trailer-btn'),\n  heroBtn: document.querySelector('.hero-btn'),\n  heroImgRef: document.querySelector('.hero-img'),\n};\n\nheroHandler();\n\nasync function heroHandler() {\n  if (window.location.href.includes('/my-lib-page.html')) {\n    heroRefs.heroImgRef.classList.add('hero-lib');\n    heroRefs.heroBtn.style.display = 'none';\n    return;\n  }\n  try {\n    const movieArr = await getTopMoviesArr(1);\n    if (movieArr.length === 0) return;\n    renderHeroSlider(movieArr);\n  } catch (error) {\n    heroRefs.heroImgRef.classList.add('hero-main');\n  }\n}\n\nasync function getTopMoviesArr(numberOfMovies) {\n  try {\n    const data = await getTrending();\n    const moviesArr = data.results;\n    return createRandomMoviesArr(moviesArr, numberOfMovies);\n  } catch (error) {\n    Notify.warning('OOPS... Something go wrong, please try again.');\n  }\n}\n\nfunction createRandomMoviesArr(moviesArr, numberOfMovies) {\n  let randomMoviesArr = [];\n  for (let i = 0; i < numberOfMovies; i++) {\n    let randomIndex = Math.floor(Math.random() * moviesArr.length);\n    randomMoviesArr.push(moviesArr.splice(randomIndex, 1)[0]);\n  }\n  return randomMoviesArr;\n}\n\ndocument.addEventListener('click', onWatchTrailer);\n\nexport { heroRefs };\nexport { swiper };\n","import Swiper from 'swiper/swiper-bundle';\nimport 'swiper/swiper-bundle.css';\nimport { heroRefs } from './hero';\n\nlet swiper = null;\n\nfunction swiperInit() {\n  swiper = new Swiper('.swiper', {\n    direction: 'horizontal',\n    loop: true,\n    speed: 2000,\n    parallax: true,\n    spaceBetween: 0,\n    autoplay: {\n      delay: 5000,\n      disableOnInteraction: false,\n    },\n  });\n}\n\nfunction renderSwiper() {\n  const markup = `<div class=\"swiper container\">\n  <div class=\"swiper-wrapper\"></div>`;\n\n  heroRefs.hero.innerHTML = markup;\n}\n\nexport { swiper, swiperInit, renderSwiper };\n","/**\n * Swiper 10.1.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: August 1, 2023\n */\n\nvar Swiper = (function () {\n  'use strict';\n\n  /**\n   * SSR Window 4.0.2\n   * Better handling for window object in SSR environment\n   * https://github.com/nolimits4web/ssr-window\n   *\n   * Copyright 2021, Vladimir Kharlampidi\n   *\n   * Licensed under MIT\n   *\n   * Released on: December 13, 2021\n   */\n  /* eslint-disable no-param-reassign */\n  function isObject$1(obj) {\n    return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n  }\n  function extend$1(target, src) {\n    if (target === void 0) {\n      target = {};\n    }\n    if (src === void 0) {\n      src = {};\n    }\n    Object.keys(src).forEach(key => {\n      if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n        extend$1(target[key], src[key]);\n      }\n    });\n  }\n  const ssrDocument = {\n    body: {},\n    addEventListener() {},\n    removeEventListener() {},\n    activeElement: {\n      blur() {},\n      nodeName: ''\n    },\n    querySelector() {\n      return null;\n    },\n    querySelectorAll() {\n      return [];\n    },\n    getElementById() {\n      return null;\n    },\n    createEvent() {\n      return {\n        initEvent() {}\n      };\n    },\n    createElement() {\n      return {\n        children: [],\n        childNodes: [],\n        style: {},\n        setAttribute() {},\n        getElementsByTagName() {\n          return [];\n        }\n      };\n    },\n    createElementNS() {\n      return {};\n    },\n    importNode() {\n      return null;\n    },\n    location: {\n      hash: '',\n      host: '',\n      hostname: '',\n      href: '',\n      origin: '',\n      pathname: '',\n      protocol: '',\n      search: ''\n    }\n  };\n  function getDocument() {\n    const doc = typeof document !== 'undefined' ? document : {};\n    extend$1(doc, ssrDocument);\n    return doc;\n  }\n  const ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n      userAgent: ''\n    },\n    location: {\n      hash: '',\n      host: '',\n      hostname: '',\n      href: '',\n      origin: '',\n      pathname: '',\n      protocol: '',\n      search: ''\n    },\n    history: {\n      replaceState() {},\n      pushState() {},\n      go() {},\n      back() {}\n    },\n    CustomEvent: function CustomEvent() {\n      return this;\n    },\n    addEventListener() {},\n    removeEventListener() {},\n    getComputedStyle() {\n      return {\n        getPropertyValue() {\n          return '';\n        }\n      };\n    },\n    Image() {},\n    Date() {},\n    screen: {},\n    setTimeout() {},\n    clearTimeout() {},\n    matchMedia() {\n      return {};\n    },\n    requestAnimationFrame(callback) {\n      if (typeof setTimeout === 'undefined') {\n        callback();\n        return null;\n      }\n      return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame(id) {\n      if (typeof setTimeout === 'undefined') {\n        return;\n      }\n      clearTimeout(id);\n    }\n  };\n  function getWindow() {\n    const win = typeof window !== 'undefined' ? window : {};\n    extend$1(win, ssrWindow);\n    return win;\n  }\n\n  function deleteProps(obj) {\n    const object = obj;\n    Object.keys(object).forEach(key => {\n      try {\n        object[key] = null;\n      } catch (e) {\n        // no getter for object\n      }\n      try {\n        delete object[key];\n      } catch (e) {\n        // something got wrong\n      }\n    });\n  }\n  function nextTick(callback, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    return setTimeout(callback, delay);\n  }\n  function now() {\n    return Date.now();\n  }\n  function getComputedStyle$1(el) {\n    const window = getWindow();\n    let style;\n    if (window.getComputedStyle) {\n      style = window.getComputedStyle(el, null);\n    }\n    if (!style && el.currentStyle) {\n      style = el.currentStyle;\n    }\n    if (!style) {\n      style = el.style;\n    }\n    return style;\n  }\n  function getTranslate(el, axis) {\n    if (axis === void 0) {\n      axis = 'x';\n    }\n    const window = getWindow();\n    let matrix;\n    let curTransform;\n    let transformMatrix;\n    const curStyle = getComputedStyle$1(el);\n    if (window.WebKitCSSMatrix) {\n      curTransform = curStyle.transform || curStyle.webkitTransform;\n      if (curTransform.split(',').length > 6) {\n        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n      }\n      // Some old versions of Webkit choke when 'none' is passed; pass\n      // empty string instead in this case\n      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n    } else {\n      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n      matrix = transformMatrix.toString().split(',');\n    }\n    if (axis === 'x') {\n      // Latest Chrome and webkits Fix\n      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[4]);\n    }\n    if (axis === 'y') {\n      // Latest Chrome and webkits Fix\n      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[5]);\n    }\n    return curTransform || 0;\n  }\n  function isObject(o) {\n    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n  }\n  function isNode(node) {\n    // eslint-disable-next-line\n    if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n      return node instanceof HTMLElement;\n    }\n    return node && (node.nodeType === 1 || node.nodeType === 11);\n  }\n  function extend() {\n    const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n    const noExtend = ['__proto__', 'constructor', 'prototype'];\n    for (let i = 1; i < arguments.length; i += 1) {\n      const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n        const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n          const nextKey = keysArray[nextIndex];\n          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined && desc.enumerable) {\n            if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n              if (nextSource[nextKey].__swiper__) {\n                to[nextKey] = nextSource[nextKey];\n              } else {\n                extend(to[nextKey], nextSource[nextKey]);\n              }\n            } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n              to[nextKey] = {};\n              if (nextSource[nextKey].__swiper__) {\n                to[nextKey] = nextSource[nextKey];\n              } else {\n                extend(to[nextKey], nextSource[nextKey]);\n              }\n            } else {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n    }\n    return to;\n  }\n  function setCSSProperty(el, varName, varValue) {\n    el.style.setProperty(varName, varValue);\n  }\n  function animateCSSModeScroll(_ref) {\n    let {\n      swiper,\n      targetPosition,\n      side\n    } = _ref;\n    const window = getWindow();\n    const startPosition = -swiper.translate;\n    let startTime = null;\n    let time;\n    const duration = swiper.params.speed;\n    swiper.wrapperEl.style.scrollSnapType = 'none';\n    window.cancelAnimationFrame(swiper.cssModeFrameID);\n    const dir = targetPosition > startPosition ? 'next' : 'prev';\n    const isOutOfBound = (current, target) => {\n      return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n    };\n    const animate = () => {\n      time = new Date().getTime();\n      if (startTime === null) {\n        startTime = time;\n      }\n      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n      if (isOutOfBound(currentPosition, targetPosition)) {\n        currentPosition = targetPosition;\n      }\n      swiper.wrapperEl.scrollTo({\n        [side]: currentPosition\n      });\n      if (isOutOfBound(currentPosition, targetPosition)) {\n        swiper.wrapperEl.style.overflow = 'hidden';\n        swiper.wrapperEl.style.scrollSnapType = '';\n        setTimeout(() => {\n          swiper.wrapperEl.style.overflow = '';\n          swiper.wrapperEl.scrollTo({\n            [side]: currentPosition\n          });\n        });\n        window.cancelAnimationFrame(swiper.cssModeFrameID);\n        return;\n      }\n      swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n    };\n    animate();\n  }\n  function getSlideTransformEl(slideEl) {\n    return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n  }\n  function elementChildren(element, selector) {\n    if (selector === void 0) {\n      selector = '';\n    }\n    return [...element.children].filter(el => el.matches(selector));\n  }\n  function createElement(tag, classes) {\n    if (classes === void 0) {\n      classes = [];\n    }\n    const el = document.createElement(tag);\n    el.classList.add(...(Array.isArray(classes) ? classes : [classes]));\n    return el;\n  }\n  function elementOffset(el) {\n    const window = getWindow();\n    const document = getDocument();\n    const box = el.getBoundingClientRect();\n    const body = document.body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === window ? window.scrollY : el.scrollTop;\n    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n    return {\n      top: box.top + scrollTop - clientTop,\n      left: box.left + scrollLeft - clientLeft\n    };\n  }\n  function elementPrevAll(el, selector) {\n    const prevEls = [];\n    while (el.previousElementSibling) {\n      const prev = el.previousElementSibling; // eslint-disable-line\n      if (selector) {\n        if (prev.matches(selector)) prevEls.push(prev);\n      } else prevEls.push(prev);\n      el = prev;\n    }\n    return prevEls;\n  }\n  function elementNextAll(el, selector) {\n    const nextEls = [];\n    while (el.nextElementSibling) {\n      const next = el.nextElementSibling; // eslint-disable-line\n      if (selector) {\n        if (next.matches(selector)) nextEls.push(next);\n      } else nextEls.push(next);\n      el = next;\n    }\n    return nextEls;\n  }\n  function elementStyle(el, prop) {\n    const window = getWindow();\n    return window.getComputedStyle(el, null).getPropertyValue(prop);\n  }\n  function elementIndex(el) {\n    let child = el;\n    let i;\n    if (child) {\n      i = 0;\n      // eslint-disable-next-line\n      while ((child = child.previousSibling) !== null) {\n        if (child.nodeType === 1) i += 1;\n      }\n      return i;\n    }\n    return undefined;\n  }\n  function elementParents(el, selector) {\n    const parents = []; // eslint-disable-line\n    let parent = el.parentElement; // eslint-disable-line\n    while (parent) {\n      if (selector) {\n        if (parent.matches(selector)) parents.push(parent);\n      } else {\n        parents.push(parent);\n      }\n      parent = parent.parentElement;\n    }\n    return parents;\n  }\n  function elementTransitionEnd(el, callback) {\n    function fireCallBack(e) {\n      if (e.target !== el) return;\n      callback.call(el, e);\n      el.removeEventListener('transitionend', fireCallBack);\n    }\n    if (callback) {\n      el.addEventListener('transitionend', fireCallBack);\n    }\n  }\n  function elementOuterSize(el, size, includeMargins) {\n    const window = getWindow();\n    if (includeMargins) {\n      return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n    }\n    return el.offsetWidth;\n  }\n\n  let support;\n  function calcSupport() {\n    const window = getWindow();\n    const document = getDocument();\n    return {\n      smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n      touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n    };\n  }\n  function getSupport() {\n    if (!support) {\n      support = calcSupport();\n    }\n    return support;\n  }\n\n  let deviceCached;\n  function calcDevice(_temp) {\n    let {\n      userAgent\n    } = _temp === void 0 ? {} : _temp;\n    const support = getSupport();\n    const window = getWindow();\n    const platform = window.navigator.platform;\n    const ua = userAgent || window.navigator.userAgent;\n    const device = {\n      ios: false,\n      android: false\n    };\n    const screenWidth = window.screen.width;\n    const screenHeight = window.screen.height;\n    const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n    let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n    const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n    const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n    const windows = platform === 'Win32';\n    let macos = platform === 'MacIntel';\n\n    // iPadOs 13 fix\n    const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n      ipad = ua.match(/(Version)\\/([\\d.]+)/);\n      if (!ipad) ipad = [0, 1, '13_0_0'];\n      macos = false;\n    }\n\n    // Android\n    if (android && !windows) {\n      device.os = 'android';\n      device.android = true;\n    }\n    if (ipad || iphone || ipod) {\n      device.os = 'ios';\n      device.ios = true;\n    }\n\n    // Export object\n    return device;\n  }\n  function getDevice(overrides) {\n    if (overrides === void 0) {\n      overrides = {};\n    }\n    if (!deviceCached) {\n      deviceCached = calcDevice(overrides);\n    }\n    return deviceCached;\n  }\n\n  let browser;\n  function calcBrowser() {\n    const window = getWindow();\n    let needPerspectiveFix = false;\n    function isSafari() {\n      const ua = window.navigator.userAgent.toLowerCase();\n      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n    }\n    if (isSafari()) {\n      const ua = String(window.navigator.userAgent);\n      if (ua.includes('Version/')) {\n        const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n        needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n      }\n    }\n    return {\n      isSafari: needPerspectiveFix || isSafari(),\n      needPerspectiveFix,\n      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\n    };\n  }\n  function getBrowser() {\n    if (!browser) {\n      browser = calcBrowser();\n    }\n    return browser;\n  }\n\n  function Resize(_ref) {\n    let {\n      swiper,\n      on,\n      emit\n    } = _ref;\n    const window = getWindow();\n    let observer = null;\n    let animationFrame = null;\n    const resizeHandler = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      emit('beforeResize');\n      emit('resize');\n    };\n    const createObserver = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      observer = new ResizeObserver(entries => {\n        animationFrame = window.requestAnimationFrame(() => {\n          const {\n            width,\n            height\n          } = swiper;\n          let newWidth = width;\n          let newHeight = height;\n          entries.forEach(_ref2 => {\n            let {\n              contentBoxSize,\n              contentRect,\n              target\n            } = _ref2;\n            if (target && target !== swiper.el) return;\n            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n          });\n          if (newWidth !== width || newHeight !== height) {\n            resizeHandler();\n          }\n        });\n      });\n      observer.observe(swiper.el);\n    };\n    const removeObserver = () => {\n      if (animationFrame) {\n        window.cancelAnimationFrame(animationFrame);\n      }\n      if (observer && observer.unobserve && swiper.el) {\n        observer.unobserve(swiper.el);\n        observer = null;\n      }\n    };\n    const orientationChangeHandler = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      emit('orientationchange');\n    };\n    on('init', () => {\n      if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n        createObserver();\n        return;\n      }\n      window.addEventListener('resize', resizeHandler);\n      window.addEventListener('orientationchange', orientationChangeHandler);\n    });\n    on('destroy', () => {\n      removeObserver();\n      window.removeEventListener('resize', resizeHandler);\n      window.removeEventListener('orientationchange', orientationChangeHandler);\n    });\n  }\n\n  function Observer(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const observers = [];\n    const window = getWindow();\n    const attach = function (target, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n      const observer = new ObserverFunc(mutations => {\n        // The observerUpdate event should only be triggered\n        // once despite the number of mutations.  Additional\n        // triggers are redundant and are very costly\n        if (swiper.__preventObserver__) return;\n        if (mutations.length === 1) {\n          emit('observerUpdate', mutations[0]);\n          return;\n        }\n        const observerUpdate = function observerUpdate() {\n          emit('observerUpdate', mutations[0]);\n        };\n        if (window.requestAnimationFrame) {\n          window.requestAnimationFrame(observerUpdate);\n        } else {\n          window.setTimeout(observerUpdate, 0);\n        }\n      });\n      observer.observe(target, {\n        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n        childList: typeof options.childList === 'undefined' ? true : options.childList,\n        characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n      });\n      observers.push(observer);\n    };\n    const init = () => {\n      if (!swiper.params.observer) return;\n      if (swiper.params.observeParents) {\n        const containerParents = elementParents(swiper.hostEl);\n        for (let i = 0; i < containerParents.length; i += 1) {\n          attach(containerParents[i]);\n        }\n      }\n      // Observe container\n      attach(swiper.hostEl, {\n        childList: swiper.params.observeSlideChildren\n      });\n\n      // Observe wrapper\n      attach(swiper.wrapperEl, {\n        attributes: false\n      });\n    };\n    const destroy = () => {\n      observers.forEach(observer => {\n        observer.disconnect();\n      });\n      observers.splice(0, observers.length);\n    };\n    extendParams({\n      observer: false,\n      observeParents: false,\n      observeSlideChildren: false\n    });\n    on('init', init);\n    on('destroy', destroy);\n  }\n\n  /* eslint-disable no-underscore-dangle */\n\n  var eventsEmitter = {\n    on(events, handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n      const method = priority ? 'unshift' : 'push';\n      events.split(' ').forEach(event => {\n        if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n        self.eventsListeners[event][method](handler);\n      });\n      return self;\n    },\n    once(events, handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n      function onceHandler() {\n        self.off(events, onceHandler);\n        if (onceHandler.__emitterProxy) {\n          delete onceHandler.__emitterProxy;\n        }\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        handler.apply(self, args);\n      }\n      onceHandler.__emitterProxy = handler;\n      return self.on(events, onceHandler, priority);\n    },\n    onAny(handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n      const method = priority ? 'unshift' : 'push';\n      if (self.eventsAnyListeners.indexOf(handler) < 0) {\n        self.eventsAnyListeners[method](handler);\n      }\n      return self;\n    },\n    offAny(handler) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsAnyListeners) return self;\n      const index = self.eventsAnyListeners.indexOf(handler);\n      if (index >= 0) {\n        self.eventsAnyListeners.splice(index, 1);\n      }\n      return self;\n    },\n    off(events, handler) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsListeners) return self;\n      events.split(' ').forEach(event => {\n        if (typeof handler === 'undefined') {\n          self.eventsListeners[event] = [];\n        } else if (self.eventsListeners[event]) {\n          self.eventsListeners[event].forEach((eventHandler, index) => {\n            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n              self.eventsListeners[event].splice(index, 1);\n            }\n          });\n        }\n      });\n      return self;\n    },\n    emit() {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsListeners) return self;\n      let events;\n      let data;\n      let context;\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n        events = args[0];\n        data = args.slice(1, args.length);\n        context = self;\n      } else {\n        events = args[0].events;\n        data = args[0].data;\n        context = args[0].context || self;\n      }\n      data.unshift(context);\n      const eventsArray = Array.isArray(events) ? events : events.split(' ');\n      eventsArray.forEach(event => {\n        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n          self.eventsAnyListeners.forEach(eventHandler => {\n            eventHandler.apply(context, [event, ...data]);\n          });\n        }\n        if (self.eventsListeners && self.eventsListeners[event]) {\n          self.eventsListeners[event].forEach(eventHandler => {\n            eventHandler.apply(context, data);\n          });\n        }\n      });\n      return self;\n    }\n  };\n\n  function updateSize() {\n    const swiper = this;\n    let width;\n    let height;\n    const el = swiper.el;\n    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n      width = swiper.params.width;\n    } else {\n      width = el.clientWidth;\n    }\n    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n      height = swiper.params.height;\n    } else {\n      height = el.clientHeight;\n    }\n    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n      return;\n    }\n\n    // Subtract paddings\n    width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n    height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n    if (Number.isNaN(width)) width = 0;\n    if (Number.isNaN(height)) height = 0;\n    Object.assign(swiper, {\n      width,\n      height,\n      size: swiper.isHorizontal() ? width : height\n    });\n  }\n\n  function updateSlides() {\n    const swiper = this;\n    function getDirectionLabel(property) {\n      if (swiper.isHorizontal()) {\n        return property;\n      }\n      // prettier-ignore\n      return {\n        'width': 'height',\n        'margin-top': 'margin-left',\n        'margin-bottom ': 'margin-right',\n        'margin-left': 'margin-top',\n        'margin-right': 'margin-bottom',\n        'padding-left': 'padding-top',\n        'padding-right': 'padding-bottom',\n        'marginRight': 'marginBottom'\n      }[property];\n    }\n    function getDirectionPropertyValue(node, label) {\n      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n    }\n    const params = swiper.params;\n    const {\n      wrapperEl,\n      slidesEl,\n      size: swiperSize,\n      rtlTranslate: rtl,\n      wrongRTL\n    } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n    let snapGrid = [];\n    const slidesGrid = [];\n    const slidesSizesGrid = [];\n    let offsetBefore = params.slidesOffsetBefore;\n    if (typeof offsetBefore === 'function') {\n      offsetBefore = params.slidesOffsetBefore.call(swiper);\n    }\n    let offsetAfter = params.slidesOffsetAfter;\n    if (typeof offsetAfter === 'function') {\n      offsetAfter = params.slidesOffsetAfter.call(swiper);\n    }\n    const previousSnapGridLength = swiper.snapGrid.length;\n    const previousSlidesGridLength = swiper.slidesGrid.length;\n    let spaceBetween = params.spaceBetween;\n    let slidePosition = -offsetBefore;\n    let prevSlideSize = 0;\n    let index = 0;\n    if (typeof swiperSize === 'undefined') {\n      return;\n    }\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n    } else if (typeof spaceBetween === 'string') {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    swiper.virtualSize = -spaceBetween;\n\n    // reset margins\n    slides.forEach(slideEl => {\n      if (rtl) {\n        slideEl.style.marginLeft = '';\n      } else {\n        slideEl.style.marginRight = '';\n      }\n      slideEl.style.marginBottom = '';\n      slideEl.style.marginTop = '';\n    });\n\n    // reset cssMode offsets\n    if (params.centeredSlides && params.cssMode) {\n      setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n      setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n    }\n    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n    if (gridEnabled) {\n      swiper.grid.initSlides(slidesLength);\n    }\n\n    // Calc slides\n    let slideSize;\n    const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n      return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n    }).length > 0;\n    for (let i = 0; i < slidesLength; i += 1) {\n      slideSize = 0;\n      let slide;\n      if (slides[i]) slide = slides[i];\n      if (gridEnabled) {\n        swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n      }\n      if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n      if (params.slidesPerView === 'auto') {\n        if (shouldResetSlideSize) {\n          slides[i].style[getDirectionLabel('width')] = ``;\n        }\n        const slideStyles = getComputedStyle(slide);\n        const currentTransform = slide.style.transform;\n        const currentWebKitTransform = slide.style.webkitTransform;\n        if (currentTransform) {\n          slide.style.transform = 'none';\n        }\n        if (currentWebKitTransform) {\n          slide.style.webkitTransform = 'none';\n        }\n        if (params.roundLengths) {\n          slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n        } else {\n          // eslint-disable-next-line\n          const width = getDirectionPropertyValue(slideStyles, 'width');\n          const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n          const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n          const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n          const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = width + marginLeft + marginRight;\n          } else {\n            const {\n              clientWidth,\n              offsetWidth\n            } = slide;\n            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n          }\n        }\n        if (currentTransform) {\n          slide.style.transform = currentTransform;\n        }\n        if (currentWebKitTransform) {\n          slide.style.webkitTransform = currentWebKitTransform;\n        }\n        if (params.roundLengths) slideSize = Math.floor(slideSize);\n      } else {\n        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n        if (params.roundLengths) slideSize = Math.floor(slideSize);\n        if (slides[i]) {\n          slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n        }\n      }\n      if (slides[i]) {\n        slides[i].swiperSlideSize = slideSize;\n      }\n      slidesSizesGrid.push(slideSize);\n      if (params.centeredSlides) {\n        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n        if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n        if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n        if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n        slidesGrid.push(slidePosition);\n      } else {\n        if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n        slidesGrid.push(slidePosition);\n        slidePosition = slidePosition + slideSize + spaceBetween;\n      }\n      swiper.virtualSize += slideSize + spaceBetween;\n      prevSlideSize = slideSize;\n      index += 1;\n    }\n    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n      wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (params.setWrapperSize) {\n      wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (gridEnabled) {\n      swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n    }\n\n    // Remove last grid elements depending on width\n    if (!params.centeredSlides) {\n      const newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n          newSlidesGrid.push(slidesGridItem);\n        }\n      }\n      snapGrid = newSlidesGrid;\n      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n        snapGrid.push(swiper.virtualSize - swiperSize);\n      }\n    }\n    if (isVirtual && params.loop) {\n      const size = slidesSizesGrid[0] + spaceBetween;\n      if (params.slidesPerGroup > 1) {\n        const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n        const groupSize = size * params.slidesPerGroup;\n        for (let i = 0; i < groups; i += 1) {\n          snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n        }\n      }\n      for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n        if (params.slidesPerGroup === 1) {\n          snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n        }\n        slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n        swiper.virtualSize += size;\n      }\n    }\n    if (snapGrid.length === 0) snapGrid = [0];\n    if (spaceBetween !== 0) {\n      const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n      slides.filter((_, slideIndex) => {\n        if (!params.cssMode || params.loop) return true;\n        if (slideIndex === slides.length - 1) {\n          return false;\n        }\n        return true;\n      }).forEach(slideEl => {\n        slideEl.style[key] = `${spaceBetween}px`;\n      });\n    }\n    if (params.centeredSlides && params.centeredSlidesBounds) {\n      let allSlidesSize = 0;\n      slidesSizesGrid.forEach(slideSizeValue => {\n        allSlidesSize += slideSizeValue + (spaceBetween || 0);\n      });\n      allSlidesSize -= spaceBetween;\n      const maxSnap = allSlidesSize - swiperSize;\n      snapGrid = snapGrid.map(snap => {\n        if (snap <= 0) return -offsetBefore;\n        if (snap > maxSnap) return maxSnap + offsetAfter;\n        return snap;\n      });\n    }\n    if (params.centerInsufficientSlides) {\n      let allSlidesSize = 0;\n      slidesSizesGrid.forEach(slideSizeValue => {\n        allSlidesSize += slideSizeValue + (spaceBetween || 0);\n      });\n      allSlidesSize -= spaceBetween;\n      if (allSlidesSize < swiperSize) {\n        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n        snapGrid.forEach((snap, snapIndex) => {\n          snapGrid[snapIndex] = snap - allSlidesOffset;\n        });\n        slidesGrid.forEach((snap, snapIndex) => {\n          slidesGrid[snapIndex] = snap + allSlidesOffset;\n        });\n      }\n    }\n    Object.assign(swiper, {\n      slides,\n      snapGrid,\n      slidesGrid,\n      slidesSizesGrid\n    });\n    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n      setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n      setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n      const addToSnapGrid = -swiper.snapGrid[0];\n      const addToSlidesGrid = -swiper.slidesGrid[0];\n      swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n      swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n    }\n    if (slidesLength !== previousSlidesLength) {\n      swiper.emit('slidesLengthChange');\n    }\n    if (snapGrid.length !== previousSnapGridLength) {\n      if (swiper.params.watchOverflow) swiper.checkOverflow();\n      swiper.emit('snapGridLengthChange');\n    }\n    if (slidesGrid.length !== previousSlidesGridLength) {\n      swiper.emit('slidesGridLengthChange');\n    }\n    if (params.watchSlidesProgress) {\n      swiper.updateSlidesOffset();\n    }\n    if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n      const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n      if (slidesLength <= params.maxBackfaceHiddenSlides) {\n        if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n      } else if (hasClassBackfaceClassAdded) {\n        swiper.el.classList.remove(backFaceHiddenClass);\n      }\n    }\n  }\n\n  function updateAutoHeight(speed) {\n    const swiper = this;\n    const activeSlides = [];\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let newHeight = 0;\n    let i;\n    if (typeof speed === 'number') {\n      swiper.setTransition(speed);\n    } else if (speed === true) {\n      swiper.setTransition(swiper.params.speed);\n    }\n    const getSlideByIndex = index => {\n      if (isVirtual) {\n        return swiper.slides[swiper.getSlideIndexByData(index)];\n      }\n      return swiper.slides[index];\n    };\n    // Find slides currently in view\n    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n      if (swiper.params.centeredSlides) {\n        (swiper.visibleSlides || []).forEach(slide => {\n          activeSlides.push(slide);\n        });\n      } else {\n        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n          const index = swiper.activeIndex + i;\n          if (index > swiper.slides.length && !isVirtual) break;\n          activeSlides.push(getSlideByIndex(index));\n        }\n      }\n    } else {\n      activeSlides.push(getSlideByIndex(swiper.activeIndex));\n    }\n\n    // Find new height from highest slide in view\n    for (i = 0; i < activeSlides.length; i += 1) {\n      if (typeof activeSlides[i] !== 'undefined') {\n        const height = activeSlides[i].offsetHeight;\n        newHeight = height > newHeight ? height : newHeight;\n      }\n    }\n\n    // Update Height\n    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n  }\n\n  function updateSlidesOffset() {\n    const swiper = this;\n    const slides = swiper.slides;\n    // eslint-disable-next-line\n    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n    for (let i = 0; i < slides.length; i += 1) {\n      slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n    }\n  }\n\n  function updateSlidesProgress(translate) {\n    if (translate === void 0) {\n      translate = this && this.translate || 0;\n    }\n    const swiper = this;\n    const params = swiper.params;\n    const {\n      slides,\n      rtlTranslate: rtl,\n      snapGrid\n    } = swiper;\n    if (slides.length === 0) return;\n    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n    let offsetCenter = -translate;\n    if (rtl) offsetCenter = translate;\n\n    // Visible Slides\n    slides.forEach(slideEl => {\n      slideEl.classList.remove(params.slideVisibleClass);\n    });\n    swiper.visibleSlidesIndexes = [];\n    swiper.visibleSlides = [];\n    let spaceBetween = params.spaceBetween;\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n    } else if (typeof spaceBetween === 'string') {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slide = slides[i];\n      let slideOffset = slide.swiperSlideOffset;\n      if (params.cssMode && params.centeredSlides) {\n        slideOffset -= slides[0].swiperSlideOffset;\n      }\n      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n      const slideBefore = -(offsetCenter - slideOffset);\n      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n      if (isVisible) {\n        swiper.visibleSlides.push(slide);\n        swiper.visibleSlidesIndexes.push(i);\n        slides[i].classList.add(params.slideVisibleClass);\n      }\n      slide.progress = rtl ? -slideProgress : slideProgress;\n      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n    }\n  }\n\n  function updateProgress(translate) {\n    const swiper = this;\n    if (typeof translate === 'undefined') {\n      const multiplier = swiper.rtlTranslate ? -1 : 1;\n      // eslint-disable-next-line\n      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n    }\n    const params = swiper.params;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    let {\n      progress,\n      isBeginning,\n      isEnd,\n      progressLoop\n    } = swiper;\n    const wasBeginning = isBeginning;\n    const wasEnd = isEnd;\n    if (translatesDiff === 0) {\n      progress = 0;\n      isBeginning = true;\n      isEnd = true;\n    } else {\n      progress = (translate - swiper.minTranslate()) / translatesDiff;\n      const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n      const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n      isBeginning = isBeginningRounded || progress <= 0;\n      isEnd = isEndRounded || progress >= 1;\n      if (isBeginningRounded) progress = 0;\n      if (isEndRounded) progress = 1;\n    }\n    if (params.loop) {\n      const firstSlideIndex = swiper.getSlideIndexByData(0);\n      const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n      const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n      const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n      const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n      const translateAbs = Math.abs(translate);\n      if (translateAbs >= firstSlideTranslate) {\n        progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n      } else {\n        progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n      }\n      if (progressLoop > 1) progressLoop -= 1;\n    }\n    Object.assign(swiper, {\n      progress,\n      progressLoop,\n      isBeginning,\n      isEnd\n    });\n    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n    if (isBeginning && !wasBeginning) {\n      swiper.emit('reachBeginning toEdge');\n    }\n    if (isEnd && !wasEnd) {\n      swiper.emit('reachEnd toEdge');\n    }\n    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n      swiper.emit('fromEdge');\n    }\n    swiper.emit('progress', progress);\n  }\n\n  function updateSlidesClasses() {\n    const swiper = this;\n    const {\n      slides,\n      params,\n      slidesEl,\n      activeIndex\n    } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const getFilteredSlide = selector => {\n      return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n    };\n    slides.forEach(slideEl => {\n      slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n    });\n    let activeSlide;\n    if (isVirtual) {\n      if (params.loop) {\n        let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n        if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n        if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n        activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n      } else {\n        activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n      }\n    } else {\n      activeSlide = slides[activeIndex];\n    }\n    if (activeSlide) {\n      // Active classes\n      activeSlide.classList.add(params.slideActiveClass);\n\n      // Next Slide\n      let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !nextSlide) {\n        nextSlide = slides[0];\n      }\n      if (nextSlide) {\n        nextSlide.classList.add(params.slideNextClass);\n      }\n      // Prev Slide\n      let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !prevSlide === 0) {\n        prevSlide = slides[slides.length - 1];\n      }\n      if (prevSlide) {\n        prevSlide.classList.add(params.slidePrevClass);\n      }\n    }\n    swiper.emitSlidesClasses();\n  }\n\n  const processLazyPreloader = (swiper, imageEl) => {\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n    const slideEl = imageEl.closest(slideSelector());\n    if (slideEl) {\n      const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n      if (lazyEl) lazyEl.remove();\n    }\n  };\n  const unlazy = (swiper, index) => {\n    if (!swiper.slides[index]) return;\n    const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n    if (imageEl) imageEl.removeAttribute('loading');\n  };\n  const preload = swiper => {\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    let amount = swiper.params.lazyPreloadPrevNext;\n    const len = swiper.slides.length;\n    if (!len || !amount || amount < 0) return;\n    amount = Math.min(amount, len);\n    const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n    const activeIndex = swiper.activeIndex;\n    if (swiper.params.grid && swiper.params.grid.rows > 1) {\n      const activeColumn = activeIndex;\n      const preloadColumns = [activeColumn - amount];\n      preloadColumns.push(...Array.from({\n        length: amount\n      }).map((_, i) => {\n        return activeColumn + slidesPerView + i;\n      }));\n      swiper.slides.forEach((slideEl, i) => {\n        if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n      });\n      return;\n    }\n    const slideIndexLastInView = activeIndex + slidesPerView - 1;\n    if (swiper.params.rewind || swiper.params.loop) {\n      for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n        const realIndex = (i % len + len) % len;\n        if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n      }\n    } else {\n      for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n        if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n          unlazy(swiper, i);\n        }\n      }\n    }\n  };\n\n  function getActiveIndexByTranslate(swiper) {\n    const {\n      slidesGrid,\n      params\n    } = swiper;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    let activeIndex;\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n          activeIndex = i;\n        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n    }\n    return activeIndex;\n  }\n  function updateActiveIndex(newActiveIndex) {\n    const swiper = this;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    const {\n      snapGrid,\n      params,\n      activeIndex: previousIndex,\n      realIndex: previousRealIndex,\n      snapIndex: previousSnapIndex\n    } = swiper;\n    let activeIndex = newActiveIndex;\n    let snapIndex;\n    const getVirtualRealIndex = aIndex => {\n      let realIndex = aIndex - swiper.virtual.slidesBefore;\n      if (realIndex < 0) {\n        realIndex = swiper.virtual.slides.length + realIndex;\n      }\n      if (realIndex >= swiper.virtual.slides.length) {\n        realIndex -= swiper.virtual.slides.length;\n      }\n      return realIndex;\n    };\n    if (typeof activeIndex === 'undefined') {\n      activeIndex = getActiveIndexByTranslate(swiper);\n    }\n    if (snapGrid.indexOf(translate) >= 0) {\n      snapIndex = snapGrid.indexOf(translate);\n    } else {\n      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n    }\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    if (activeIndex === previousIndex) {\n      if (snapIndex !== previousSnapIndex) {\n        swiper.snapIndex = snapIndex;\n        swiper.emit('snapIndexChange');\n      }\n      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.realIndex = getVirtualRealIndex(activeIndex);\n      }\n      return;\n    }\n    // Get real index\n    let realIndex;\n    if (swiper.virtual && params.virtual.enabled && params.loop) {\n      realIndex = getVirtualRealIndex(activeIndex);\n    } else if (swiper.slides[activeIndex]) {\n      realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);\n    } else {\n      realIndex = activeIndex;\n    }\n    Object.assign(swiper, {\n      previousSnapIndex,\n      snapIndex,\n      previousRealIndex,\n      realIndex,\n      previousIndex,\n      activeIndex\n    });\n    if (swiper.initialized) {\n      preload(swiper);\n    }\n    swiper.emit('activeIndexChange');\n    swiper.emit('snapIndexChange');\n    if (previousRealIndex !== realIndex) {\n      swiper.emit('realIndexChange');\n    }\n    if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n      swiper.emit('slideChange');\n    }\n  }\n\n  function updateClickedSlide(e) {\n    const swiper = this;\n    const params = swiper.params;\n    const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n    let slideFound = false;\n    let slideIndex;\n    if (slide) {\n      for (let i = 0; i < swiper.slides.length; i += 1) {\n        if (swiper.slides[i] === slide) {\n          slideFound = true;\n          slideIndex = i;\n          break;\n        }\n      }\n    }\n    if (slide && slideFound) {\n      swiper.clickedSlide = slide;\n      if (swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n      } else {\n        swiper.clickedIndex = slideIndex;\n      }\n    } else {\n      swiper.clickedSlide = undefined;\n      swiper.clickedIndex = undefined;\n      return;\n    }\n    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n      swiper.slideToClickedSlide();\n    }\n  }\n\n  var update = {\n    updateSize,\n    updateSlides,\n    updateAutoHeight,\n    updateSlidesOffset,\n    updateSlidesProgress,\n    updateProgress,\n    updateSlidesClasses,\n    updateActiveIndex,\n    updateClickedSlide\n  };\n\n  function getSwiperTranslate(axis) {\n    if (axis === void 0) {\n      axis = this.isHorizontal() ? 'x' : 'y';\n    }\n    const swiper = this;\n    const {\n      params,\n      rtlTranslate: rtl,\n      translate,\n      wrapperEl\n    } = swiper;\n    if (params.virtualTranslate) {\n      return rtl ? -translate : translate;\n    }\n    if (params.cssMode) {\n      return translate;\n    }\n    let currentTranslate = getTranslate(wrapperEl, axis);\n    currentTranslate += swiper.cssOverflowAdjustment();\n    if (rtl) currentTranslate = -currentTranslate;\n    return currentTranslate || 0;\n  }\n\n  function setTranslate(translate, byController) {\n    const swiper = this;\n    const {\n      rtlTranslate: rtl,\n      params,\n      wrapperEl,\n      progress\n    } = swiper;\n    let x = 0;\n    let y = 0;\n    const z = 0;\n    if (swiper.isHorizontal()) {\n      x = rtl ? -translate : translate;\n    } else {\n      y = translate;\n    }\n    if (params.roundLengths) {\n      x = Math.floor(x);\n      y = Math.floor(y);\n    }\n    swiper.previousTranslate = swiper.translate;\n    swiper.translate = swiper.isHorizontal() ? x : y;\n    if (params.cssMode) {\n      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n    } else if (!params.virtualTranslate) {\n      if (swiper.isHorizontal()) {\n        x -= swiper.cssOverflowAdjustment();\n      } else {\n        y -= swiper.cssOverflowAdjustment();\n      }\n      wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n    }\n\n    // Check if we need to update progress\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n      newProgress = 0;\n    } else {\n      newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== progress) {\n      swiper.updateProgress(translate);\n    }\n    swiper.emit('setTranslate', swiper.translate, byController);\n  }\n\n  function minTranslate() {\n    return -this.snapGrid[0];\n  }\n\n  function maxTranslate() {\n    return -this.snapGrid[this.snapGrid.length - 1];\n  }\n\n  function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n    if (translate === void 0) {\n      translate = 0;\n    }\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    if (translateBounds === void 0) {\n      translateBounds = true;\n    }\n    const swiper = this;\n    const {\n      params,\n      wrapperEl\n    } = swiper;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n      return false;\n    }\n    const minTranslate = swiper.minTranslate();\n    const maxTranslate = swiper.maxTranslate();\n    let newTranslate;\n    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;\n\n    // Update progress\n    swiper.updateProgress(newTranslate);\n    if (params.cssMode) {\n      const isH = swiper.isHorizontal();\n      if (speed === 0) {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n      } else {\n        if (!swiper.support.smoothScroll) {\n          animateCSSModeScroll({\n            swiper,\n            targetPosition: -newTranslate,\n            side: isH ? 'left' : 'top'\n          });\n          return true;\n        }\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: -newTranslate,\n          behavior: 'smooth'\n        });\n      }\n      return true;\n    }\n    if (speed === 0) {\n      swiper.setTransition(0);\n      swiper.setTranslate(newTranslate);\n      if (runCallbacks) {\n        swiper.emit('beforeTransitionStart', speed, internal);\n        swiper.emit('transitionEnd');\n      }\n    } else {\n      swiper.setTransition(speed);\n      swiper.setTranslate(newTranslate);\n      if (runCallbacks) {\n        swiper.emit('beforeTransitionStart', speed, internal);\n        swiper.emit('transitionStart');\n      }\n      if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onTranslateToWrapperTransitionEnd) {\n          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n            if (!swiper || swiper.destroyed) return;\n            if (e.target !== this) return;\n            swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n            swiper.onTranslateToWrapperTransitionEnd = null;\n            delete swiper.onTranslateToWrapperTransitionEnd;\n            if (runCallbacks) {\n              swiper.emit('transitionEnd');\n            }\n          };\n        }\n        swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n      }\n    }\n    return true;\n  }\n\n  var translate = {\n    getTranslate: getSwiperTranslate,\n    setTranslate,\n    minTranslate,\n    maxTranslate,\n    translateTo\n  };\n\n  function setTransition(duration, byController) {\n    const swiper = this;\n    if (!swiper.params.cssMode) {\n      swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n    }\n    swiper.emit('setTransition', duration, byController);\n  }\n\n  function transitionEmit(_ref) {\n    let {\n      swiper,\n      runCallbacks,\n      direction,\n      step\n    } = _ref;\n    const {\n      activeIndex,\n      previousIndex\n    } = swiper;\n    let dir = direction;\n    if (!dir) {\n      if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n    }\n    swiper.emit(`transition${step}`);\n    if (runCallbacks && activeIndex !== previousIndex) {\n      if (dir === 'reset') {\n        swiper.emit(`slideResetTransition${step}`);\n        return;\n      }\n      swiper.emit(`slideChangeTransition${step}`);\n      if (dir === 'next') {\n        swiper.emit(`slideNextTransition${step}`);\n      } else {\n        swiper.emit(`slidePrevTransition${step}`);\n      }\n    }\n  }\n\n  function transitionStart(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    const {\n      params\n    } = swiper;\n    if (params.cssMode) return;\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    transitionEmit({\n      swiper,\n      runCallbacks,\n      direction,\n      step: 'Start'\n    });\n  }\n\n  function transitionEnd(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    const {\n      params\n    } = swiper;\n    swiper.animating = false;\n    if (params.cssMode) return;\n    swiper.setTransition(0);\n    transitionEmit({\n      swiper,\n      runCallbacks,\n      direction,\n      step: 'End'\n    });\n  }\n\n  var transition = {\n    setTransition,\n    transitionStart,\n    transitionEnd\n  };\n\n  function slideTo(index, speed, runCallbacks, internal, initial) {\n    if (index === void 0) {\n      index = 0;\n    }\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    if (typeof index === 'string') {\n      index = parseInt(index, 10);\n    }\n    const swiper = this;\n    let slideIndex = index;\n    if (slideIndex < 0) slideIndex = 0;\n    const {\n      params,\n      snapGrid,\n      slidesGrid,\n      previousIndex,\n      activeIndex,\n      rtlTranslate: rtl,\n      wrapperEl,\n      enabled\n    } = swiper;\n    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n      return false;\n    }\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    const translate = -snapGrid[snapIndex];\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      for (let i = 0; i < slidesGrid.length; i += 1) {\n        const normalizedTranslate = -Math.floor(translate * 100);\n        const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\n          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n            slideIndex = i;\n          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n            slideIndex = i + 1;\n          }\n        } else if (normalizedTranslate >= normalizedGrid) {\n          slideIndex = i;\n        }\n      }\n    }\n    // Directions locks\n    if (swiper.initialized && slideIndex !== activeIndex) {\n      if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n        return false;\n      }\n      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n        if ((activeIndex || 0) !== slideIndex) {\n          return false;\n        }\n      }\n    }\n    if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n      swiper.emit('beforeSlideChangeStart');\n    }\n\n    // Update progress\n    swiper.updateProgress(translate);\n    let direction;\n    if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n    // Update Index\n    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n      swiper.updateActiveIndex(slideIndex);\n      // Update Height\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n      swiper.updateSlidesClasses();\n      if (params.effect !== 'slide') {\n        swiper.setTranslate(translate);\n      }\n      if (direction !== 'reset') {\n        swiper.transitionStart(runCallbacks, direction);\n        swiper.transitionEnd(runCallbacks, direction);\n      }\n      return false;\n    }\n    if (params.cssMode) {\n      const isH = swiper.isHorizontal();\n      const t = rtl ? translate : -translate;\n      if (speed === 0) {\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        if (isVirtual) {\n          swiper.wrapperEl.style.scrollSnapType = 'none';\n          swiper._immediateVirtual = true;\n        }\n        if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n          swiper._cssModeVirtualInitialSet = true;\n          requestAnimationFrame(() => {\n            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n          });\n        } else {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        }\n        if (isVirtual) {\n          requestAnimationFrame(() => {\n            swiper.wrapperEl.style.scrollSnapType = '';\n            swiper._immediateVirtual = false;\n          });\n        }\n      } else {\n        if (!swiper.support.smoothScroll) {\n          animateCSSModeScroll({\n            swiper,\n            targetPosition: t,\n            side: isH ? 'left' : 'top'\n          });\n          return true;\n        }\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: t,\n          behavior: 'smooth'\n        });\n      }\n      return true;\n    }\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (speed === 0) {\n      swiper.transitionEnd(runCallbacks, direction);\n    } else if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n      swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n    }\n    return true;\n  }\n\n  function slideToLoop(index, speed, runCallbacks, internal) {\n    if (index === void 0) {\n      index = 0;\n    }\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    if (typeof index === 'string') {\n      const indexAsNumber = parseInt(index, 10);\n      index = indexAsNumber;\n    }\n    const swiper = this;\n    let newIndex = index;\n    if (swiper.params.loop) {\n      if (swiper.virtual && swiper.params.virtual.enabled) {\n        // eslint-disable-next-line\n        newIndex = newIndex + swiper.virtual.slidesBefore;\n      } else {\n        newIndex = swiper.getSlideIndexByData(newIndex);\n      }\n    }\n    return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideNext(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    const {\n      enabled,\n      params,\n      animating\n    } = swiper;\n    if (!enabled) return swiper;\n    let perGroup = params.slidesPerGroup;\n    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n    }\n    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n      if (animating && !isVirtual && params.loopPreventsSliding) return false;\n      swiper.loopFix({\n        direction: 'next'\n      });\n      // eslint-disable-next-line\n      swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    }\n    if (params.rewind && swiper.isEnd) {\n      return swiper.slideTo(0, speed, runCallbacks, internal);\n    }\n    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slidePrev(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    const {\n      params,\n      snapGrid,\n      slidesGrid,\n      rtlTranslate,\n      enabled,\n      animating\n    } = swiper;\n    if (!enabled) return swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n      if (animating && !isVirtual && params.loopPreventsSliding) return false;\n      swiper.loopFix({\n        direction: 'prev'\n      });\n      // eslint-disable-next-line\n      swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    }\n    const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n    function normalize(val) {\n      if (val < 0) return -Math.floor(Math.abs(val));\n      return Math.floor(val);\n    }\n    const normalizedTranslate = normalize(translate);\n    const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n    if (typeof prevSnap === 'undefined' && params.cssMode) {\n      let prevSnapIndex;\n      snapGrid.forEach((snap, snapIndex) => {\n        if (normalizedTranslate >= snap) {\n          // prevSnap = snap;\n          prevSnapIndex = snapIndex;\n        }\n      });\n      if (typeof prevSnapIndex !== 'undefined') {\n        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n      }\n    }\n    let prevIndex = 0;\n    if (typeof prevSnap !== 'undefined') {\n      prevIndex = slidesGrid.indexOf(prevSnap);\n      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n        prevIndex = Math.max(prevIndex, 0);\n      }\n    }\n    if (params.rewind && swiper.isBeginning) {\n      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n    }\n    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideReset(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideToClosest(speed, runCallbacks, internal, threshold) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    if (threshold === void 0) {\n      threshold = 0.5;\n    }\n    const swiper = this;\n    let index = swiper.activeIndex;\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    if (translate >= swiper.snapGrid[snapIndex]) {\n      // The current translate is on or after the current snap index, so the choice\n      // is between the current index and the one after it.\n      const currentSnap = swiper.snapGrid[snapIndex];\n      const nextSnap = swiper.snapGrid[snapIndex + 1];\n      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n        index += swiper.params.slidesPerGroup;\n      }\n    } else {\n      // The current translate is before the current snap index, so the choice\n      // is between the current index and the one before it.\n      const prevSnap = swiper.snapGrid[snapIndex - 1];\n      const currentSnap = swiper.snapGrid[snapIndex];\n      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n        index -= swiper.params.slidesPerGroup;\n      }\n    }\n    index = Math.max(index, 0);\n    index = Math.min(index, swiper.slidesGrid.length - 1);\n    return swiper.slideTo(index, speed, runCallbacks, internal);\n  }\n\n  function slideToClickedSlide() {\n    const swiper = this;\n    const {\n      params,\n      slidesEl\n    } = swiper;\n    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n    let slideToIndex = swiper.clickedIndex;\n    let realIndex;\n    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n    if (params.loop) {\n      if (swiper.animating) return;\n      realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n      if (params.centeredSlides) {\n        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n          swiper.loopFix();\n          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n          nextTick(() => {\n            swiper.slideTo(slideToIndex);\n          });\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n        swiper.loopFix();\n        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  }\n\n  var slide = {\n    slideTo,\n    slideToLoop,\n    slideNext,\n    slidePrev,\n    slideReset,\n    slideToClosest,\n    slideToClickedSlide\n  };\n\n  function loopCreate(slideRealIndex) {\n    const swiper = this;\n    const {\n      params,\n      slidesEl\n    } = swiper;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    slides.forEach((el, index) => {\n      el.setAttribute('data-swiper-slide-index', index);\n    });\n    swiper.loopFix({\n      slideRealIndex,\n      direction: params.centeredSlides ? undefined : 'next'\n    });\n  }\n\n  function loopFix(_temp) {\n    let {\n      slideRealIndex,\n      slideTo = true,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController,\n      byMousewheel\n    } = _temp === void 0 ? {} : _temp;\n    const swiper = this;\n    if (!swiper.params.loop) return;\n    swiper.emit('beforeLoopFix');\n    const {\n      slides,\n      allowSlidePrev,\n      allowSlideNext,\n      slidesEl,\n      params\n    } = swiper;\n    swiper.allowSlidePrev = true;\n    swiper.allowSlideNext = true;\n    if (swiper.virtual && params.virtual.enabled) {\n      if (slideTo) {\n        if (!params.centeredSlides && swiper.snapIndex === 0) {\n          swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n        } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n          swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n        } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n          swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n        }\n      }\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      swiper.emit('loopFix');\n      return;\n    }\n    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n    let loopedSlides = params.loopedSlides || slidesPerView;\n    if (loopedSlides % params.slidesPerGroup !== 0) {\n      loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n    }\n    swiper.loopedSlides = loopedSlides;\n    const prependSlidesIndexes = [];\n    const appendSlidesIndexes = [];\n    let activeIndex = swiper.activeIndex;\n    if (typeof activeSlideIndex === 'undefined') {\n      activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n    } else {\n      activeIndex = activeSlideIndex;\n    }\n    const isNext = direction === 'next' || !direction;\n    const isPrev = direction === 'prev' || !direction;\n    let slidesPrepended = 0;\n    let slidesAppended = 0;\n    // prepend last slides before start\n    if (activeSlideIndex < loopedSlides) {\n      slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n      for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n        const index = i - Math.floor(i / slides.length) * slides.length;\n        prependSlidesIndexes.push(slides.length - index - 1);\n      }\n    } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n      slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n      for (let i = 0; i < slidesAppended; i += 1) {\n        const index = i - Math.floor(i / slides.length) * slides.length;\n        appendSlidesIndexes.push(index);\n      }\n    }\n    if (isPrev) {\n      prependSlidesIndexes.forEach(index => {\n        swiper.slides[index].swiperLoopMoveDOM = true;\n        slidesEl.prepend(swiper.slides[index]);\n        swiper.slides[index].swiperLoopMoveDOM = false;\n      });\n    }\n    if (isNext) {\n      appendSlidesIndexes.forEach(index => {\n        swiper.slides[index].swiperLoopMoveDOM = true;\n        slidesEl.append(swiper.slides[index]);\n        swiper.slides[index].swiperLoopMoveDOM = false;\n      });\n    }\n    swiper.recalcSlides();\n    if (params.slidesPerView === 'auto') {\n      swiper.updateSlides();\n    }\n    if (params.watchSlidesProgress) {\n      swiper.updateSlidesOffset();\n    }\n    if (slideTo) {\n      if (prependSlidesIndexes.length > 0 && isPrev) {\n        if (typeof slideRealIndex === 'undefined') {\n          const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n          const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n          const diff = newSlideTranslate - currentSlideTranslate;\n          if (byMousewheel) {\n            swiper.setTranslate(swiper.translate - diff);\n          } else {\n            swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n            if (setTranslate) {\n              swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n              swiper.touchEventsData.currentTranslate = swiper.translate;\n            }\n          }\n        } else {\n          if (setTranslate) {\n            swiper.slideToLoop(slideRealIndex, 0, false, true);\n            swiper.touchEventsData.currentTranslate = swiper.translate;\n          }\n        }\n      } else if (appendSlidesIndexes.length > 0 && isNext) {\n        if (typeof slideRealIndex === 'undefined') {\n          const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n          const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n          const diff = newSlideTranslate - currentSlideTranslate;\n          if (byMousewheel) {\n            swiper.setTranslate(swiper.translate - diff);\n          } else {\n            swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n            if (setTranslate) {\n              swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n              swiper.touchEventsData.currentTranslate = swiper.translate;\n            }\n          }\n        } else {\n          swiper.slideToLoop(slideRealIndex, 0, false, true);\n        }\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.controller && swiper.controller.control && !byController) {\n      const loopParams = {\n        slideRealIndex,\n        slideTo: false,\n        direction,\n        setTranslate,\n        activeSlideIndex,\n        byController: true\n      };\n      if (Array.isArray(swiper.controller.control)) {\n        swiper.controller.control.forEach(c => {\n          if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n        });\n      } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n        swiper.controller.control.loopFix(loopParams);\n      }\n    }\n    swiper.emit('loopFix');\n  }\n\n  function loopDestroy() {\n    const swiper = this;\n    const {\n      params,\n      slidesEl\n    } = swiper;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    swiper.recalcSlides();\n    const newSlidesOrder = [];\n    swiper.slides.forEach(slideEl => {\n      const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n      newSlidesOrder[index] = slideEl;\n    });\n    swiper.slides.forEach(slideEl => {\n      slideEl.removeAttribute('data-swiper-slide-index');\n    });\n    newSlidesOrder.forEach(slideEl => {\n      slidesEl.append(slideEl);\n    });\n    swiper.recalcSlides();\n    swiper.slideTo(swiper.realIndex, 0);\n  }\n\n  var loop = {\n    loopCreate,\n    loopFix,\n    loopDestroy\n  };\n\n  function setGrabCursor(moving) {\n    const swiper = this;\n    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n    const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n    if (swiper.isElement) {\n      swiper.__preventObserver__ = true;\n    }\n    el.style.cursor = 'move';\n    el.style.cursor = moving ? 'grabbing' : 'grab';\n    if (swiper.isElement) {\n      requestAnimationFrame(() => {\n        swiper.__preventObserver__ = false;\n      });\n    }\n  }\n\n  function unsetGrabCursor() {\n    const swiper = this;\n    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n      return;\n    }\n    if (swiper.isElement) {\n      swiper.__preventObserver__ = true;\n    }\n    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n    if (swiper.isElement) {\n      requestAnimationFrame(() => {\n        swiper.__preventObserver__ = false;\n      });\n    }\n  }\n\n  var grabCursor = {\n    setGrabCursor,\n    unsetGrabCursor\n  };\n\n  // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n  function closestElement(selector, base) {\n    if (base === void 0) {\n      base = this;\n    }\n    function __closestFrom(el) {\n      if (!el || el === getDocument() || el === getWindow()) return null;\n      if (el.assignedSlot) el = el.assignedSlot;\n      const found = el.closest(selector);\n      if (!found && !el.getRootNode) {\n        return null;\n      }\n      return found || __closestFrom(el.getRootNode().host);\n    }\n    return __closestFrom(base);\n  }\n  function onTouchStart(event) {\n    const swiper = this;\n    const document = getDocument();\n    const window = getWindow();\n    const data = swiper.touchEventsData;\n    data.evCache.push(event);\n    const {\n      params,\n      touches,\n      enabled\n    } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === 'mouse') return;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n      return;\n    }\n    if (!swiper.animating && params.cssMode && params.loop) {\n      swiper.loopFix();\n    }\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    let targetEl = e.target;\n    if (params.touchEventsTarget === 'wrapper') {\n      if (!swiper.wrapperEl.contains(targetEl)) return;\n    }\n    if ('which' in e && e.which === 3) return;\n    if ('button' in e && e.button > 0) return;\n    if (data.isTouched && data.isMoved) return;\n\n    // change target el for shadow root component\n    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n    // eslint-disable-next-line\n    const eventPath = event.composedPath ? event.composedPath() : event.path;\n    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n      targetEl = eventPath[0];\n    }\n    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n    const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n    // use closestElement for shadow root element to get the actual closest for nested shadow root element\n    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n      swiper.allowClick = true;\n      return;\n    }\n    if (params.swipeHandler) {\n      if (!targetEl.closest(params.swipeHandler)) return;\n    }\n    touches.currentX = e.pageX;\n    touches.currentY = e.pageY;\n    const startX = touches.currentX;\n    const startY = touches.currentY;\n\n    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n      if (edgeSwipeDetection === 'prevent') {\n        event.preventDefault();\n      } else {\n        return;\n      }\n    }\n    Object.assign(data, {\n      isTouched: true,\n      isMoved: false,\n      allowTouchCallbacks: true,\n      isScrolling: undefined,\n      startMoving: undefined\n    });\n    touches.startX = startX;\n    touches.startY = startY;\n    data.touchStartTime = now();\n    swiper.allowClick = true;\n    swiper.updateSize();\n    swiper.swipeDirection = undefined;\n    if (params.threshold > 0) data.allowThresholdMove = false;\n    let preventDefault = true;\n    if (targetEl.matches(data.focusableElements)) {\n      preventDefault = false;\n      if (targetEl.nodeName === 'SELECT') {\n        data.isTouched = false;\n      }\n    }\n    if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n      document.activeElement.blur();\n    }\n    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n      e.preventDefault();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n      swiper.freeMode.onTouchStart();\n    }\n    swiper.emit('touchStart', e);\n  }\n\n  function onTouchMove(event) {\n    const document = getDocument();\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    const {\n      params,\n      touches,\n      rtlTranslate: rtl,\n      enabled\n    } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === 'mouse') return;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    if (!data.isTouched) {\n      if (data.startMoving && data.isScrolling) {\n        swiper.emit('touchMoveOpposite', e);\n      }\n      return;\n    }\n    const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n    const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n    const pageX = targetTouch.pageX;\n    const pageY = targetTouch.pageY;\n    if (e.preventedByNestedSwiper) {\n      touches.startX = pageX;\n      touches.startY = pageY;\n      return;\n    }\n    if (!swiper.allowTouchMove) {\n      if (!e.target.matches(data.focusableElements)) {\n        swiper.allowClick = false;\n      }\n      if (data.isTouched) {\n        Object.assign(touches, {\n          startX: pageX,\n          startY: pageY,\n          prevX: swiper.touches.currentX,\n          prevY: swiper.touches.currentY,\n          currentX: pageX,\n          currentY: pageY\n        });\n        data.touchStartTime = now();\n      }\n      return;\n    }\n    if (params.touchReleaseOnEdges && !params.loop) {\n      if (swiper.isVertical()) {\n        // Vertical\n        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n          data.isTouched = false;\n          data.isMoved = false;\n          return;\n        }\n      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n        return;\n      }\n    }\n    if (document.activeElement) {\n      if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n        data.isMoved = true;\n        swiper.allowClick = false;\n        return;\n      }\n    }\n    if (data.allowTouchCallbacks) {\n      swiper.emit('touchMove', e);\n    }\n    if (e.targetTouches && e.targetTouches.length > 1) return;\n    touches.currentX = pageX;\n    touches.currentY = pageY;\n    const diffX = touches.currentX - touches.startX;\n    const diffY = touches.currentY - touches.startY;\n    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n    if (typeof data.isScrolling === 'undefined') {\n      let touchAngle;\n      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n        data.isScrolling = false;\n      } else {\n        // eslint-disable-next-line\n        if (diffX * diffX + diffY * diffY >= 25) {\n          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n        }\n      }\n    }\n    if (data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    if (typeof data.startMoving === 'undefined') {\n      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n        data.startMoving = true;\n      }\n    }\n    if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n      data.isTouched = false;\n      return;\n    }\n    if (!data.startMoving) {\n      return;\n    }\n    swiper.allowClick = false;\n    if (!params.cssMode && e.cancelable) {\n      e.preventDefault();\n    }\n    if (params.touchMoveStopPropagation && !params.nested) {\n      e.stopPropagation();\n    }\n    let diff = swiper.isHorizontal() ? diffX : diffY;\n    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n    if (params.oneWayMovement) {\n      diff = Math.abs(diff) * (rtl ? 1 : -1);\n      touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n    }\n    touches.diff = diff;\n    diff *= params.touchRatio;\n    if (rtl) {\n      diff = -diff;\n      touchesDiff = -touchesDiff;\n    }\n    const prevTouchesDirection = swiper.touchesDirection;\n    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n    swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n    const isLoop = swiper.params.loop && !params.cssMode;\n    if (!data.isMoved) {\n      if (isLoop) {\n        swiper.loopFix({\n          direction: swiper.swipeDirection\n        });\n      }\n      data.startTranslate = swiper.getTranslate();\n      swiper.setTransition(0);\n      if (swiper.animating) {\n        const evt = new window.CustomEvent('transitionend', {\n          bubbles: true,\n          cancelable: true\n        });\n        swiper.wrapperEl.dispatchEvent(evt);\n      }\n      data.allowMomentumBounce = false;\n      // Grab Cursor\n      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(true);\n      }\n      swiper.emit('sliderFirstMove', e);\n    }\n    let loopFixed;\n    if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n      // need another loop fix\n      swiper.loopFix({\n        direction: swiper.swipeDirection,\n        setTranslate: true\n      });\n      loopFixed = true;\n    }\n    swiper.emit('sliderMove', e);\n    data.isMoved = true;\n    data.currentTranslate = diff + data.startTranslate;\n    let disableParentSwiper = true;\n    let resistanceRatio = params.resistanceRatio;\n    if (params.touchReleaseOnEdges) {\n      resistanceRatio = 0;\n    }\n    if (diff > 0) {\n      if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {\n        swiper.loopFix({\n          direction: 'prev',\n          setTranslate: true,\n          activeSlideIndex: 0\n        });\n      }\n      if (data.currentTranslate > swiper.minTranslate()) {\n        disableParentSwiper = false;\n        if (params.resistance) {\n          data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n        }\n      }\n    } else if (diff < 0) {\n      if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {\n        swiper.loopFix({\n          direction: 'next',\n          setTranslate: true,\n          activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n        });\n      }\n      if (data.currentTranslate < swiper.maxTranslate()) {\n        disableParentSwiper = false;\n        if (params.resistance) {\n          data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n        }\n      }\n    }\n    if (disableParentSwiper) {\n      e.preventedByNestedSwiper = true;\n    }\n\n    // Directions locks\n    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n      data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n      data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n      data.currentTranslate = data.startTranslate;\n    }\n\n    // Threshold\n    if (params.threshold > 0) {\n      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n        if (!data.allowThresholdMove) {\n          data.allowThresholdMove = true;\n          touches.startX = touches.currentX;\n          touches.startY = touches.currentY;\n          data.currentTranslate = data.startTranslate;\n          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n          return;\n        }\n      } else {\n        data.currentTranslate = data.startTranslate;\n        return;\n      }\n    }\n    if (!params.followFinger || params.cssMode) return;\n\n    // Update active index in free mode\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n      swiper.freeMode.onTouchMove();\n    }\n    // Update progress\n    swiper.updateProgress(data.currentTranslate);\n    // Update translate\n    swiper.setTranslate(data.currentTranslate);\n  }\n\n  function onTouchEnd(event) {\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);\n    if (pointerIndex >= 0) {\n      data.evCache.splice(pointerIndex, 1);\n    }\n    if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {\n      const proceed = event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);\n      if (!proceed) {\n        return;\n      }\n    }\n    const {\n      params,\n      touches,\n      rtlTranslate: rtl,\n      slidesGrid,\n      enabled\n    } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === 'mouse') return;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    if (data.allowTouchCallbacks) {\n      swiper.emit('touchEnd', e);\n    }\n    data.allowTouchCallbacks = false;\n    if (!data.isTouched) {\n      if (data.isMoved && params.grabCursor) {\n        swiper.setGrabCursor(false);\n      }\n      data.isMoved = false;\n      data.startMoving = false;\n      return;\n    }\n    // Return Grab Cursor\n    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(false);\n    }\n\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    // Tap, doubleTap, Click\n    if (swiper.allowClick) {\n      const pathTree = e.path || e.composedPath && e.composedPath();\n      swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n      swiper.emit('tap click', e);\n      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n        swiper.emit('doubleTap doubleClick', e);\n      }\n    }\n    data.lastClickTime = now();\n    nextTick(() => {\n      if (!swiper.destroyed) swiper.allowClick = true;\n    });\n    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n      data.isTouched = false;\n      data.isMoved = false;\n      data.startMoving = false;\n      return;\n    }\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    let currentPos;\n    if (params.followFinger) {\n      currentPos = rtl ? swiper.translate : -swiper.translate;\n    } else {\n      currentPos = -data.currentTranslate;\n    }\n    if (params.cssMode) {\n      return;\n    }\n    if (params.freeMode && params.freeMode.enabled) {\n      swiper.freeMode.onTouchEnd({\n        currentPos\n      });\n      return;\n    }\n\n    // Find current slide\n    let stopIndex = 0;\n    let groupSize = swiper.slidesSizesGrid[0];\n    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n      const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n      if (typeof slidesGrid[i + increment] !== 'undefined') {\n        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n          stopIndex = i;\n          groupSize = slidesGrid[i + increment] - slidesGrid[i];\n        }\n      } else if (currentPos >= slidesGrid[i]) {\n        stopIndex = i;\n        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n      }\n    }\n    let rewindFirstIndex = null;\n    let rewindLastIndex = null;\n    if (params.rewind) {\n      if (swiper.isBeginning) {\n        rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n      } else if (swiper.isEnd) {\n        rewindFirstIndex = 0;\n      }\n    }\n    // Find current slide size\n    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (timeDiff > params.longSwipesMs) {\n      // Long touches\n      if (!params.longSwipes) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n      if (swiper.swipeDirection === 'next') {\n        if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        if (ratio > 1 - params.longSwipesRatio) {\n          swiper.slideTo(stopIndex + increment);\n        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n          swiper.slideTo(rewindLastIndex);\n        } else {\n          swiper.slideTo(stopIndex);\n        }\n      }\n    } else {\n      // Short swipes\n      if (!params.shortSwipes) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n      const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n      if (!isNavButtonTarget) {\n        if (swiper.swipeDirection === 'next') {\n          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n        }\n        if (swiper.swipeDirection === 'prev') {\n          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n        }\n      } else if (e.target === swiper.navigation.nextEl) {\n        swiper.slideTo(stopIndex + increment);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  }\n\n  function onResize() {\n    const swiper = this;\n    const {\n      params,\n      el\n    } = swiper;\n    if (el && el.offsetWidth === 0) return;\n\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Save locks\n    const {\n      allowSlideNext,\n      allowSlidePrev,\n      snapGrid\n    } = swiper;\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n    // Disable locks on resize\n    swiper.allowSlideNext = true;\n    swiper.allowSlidePrev = true;\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateSlidesClasses();\n    const isVirtualLoop = isVirtual && params.loop;\n    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n      swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n      if (swiper.params.loop && !isVirtual) {\n        swiper.slideToLoop(swiper.realIndex, 0, false, true);\n      } else {\n        swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n    }\n    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n      clearTimeout(swiper.autoplay.resizeTimeout);\n      swiper.autoplay.resizeTimeout = setTimeout(() => {\n        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n          swiper.autoplay.resume();\n        }\n      }, 500);\n    }\n    // Return locks after resize\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n  }\n\n  function onClick(e) {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    if (!swiper.allowClick) {\n      if (swiper.params.preventClicks) e.preventDefault();\n      if (swiper.params.preventClicksPropagation && swiper.animating) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      }\n    }\n  }\n\n  function onScroll() {\n    const swiper = this;\n    const {\n      wrapperEl,\n      rtlTranslate,\n      enabled\n    } = swiper;\n    if (!enabled) return;\n    swiper.previousTranslate = swiper.translate;\n    if (swiper.isHorizontal()) {\n      swiper.translate = -wrapperEl.scrollLeft;\n    } else {\n      swiper.translate = -wrapperEl.scrollTop;\n    }\n    // eslint-disable-next-line\n    if (swiper.translate === 0) swiper.translate = 0;\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n      newProgress = 0;\n    } else {\n      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== swiper.progress) {\n      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n    }\n    swiper.emit('setTranslate', swiper.translate, false);\n  }\n\n  function onLoad(e) {\n    const swiper = this;\n    processLazyPreloader(swiper, e.target);\n    if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n      return;\n    }\n    swiper.update();\n  }\n\n  let dummyEventAttached = false;\n  function dummyEventListener() {}\n  const events = (swiper, method) => {\n    const document = getDocument();\n    const {\n      params,\n      el,\n      wrapperEl,\n      device\n    } = swiper;\n    const capture = !!params.nested;\n    const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n    const swiperMethod = method;\n\n    // Touch Events\n    el[domMethod]('pointerdown', swiper.onTouchStart, {\n      passive: false\n    });\n    document[domMethod]('pointermove', swiper.onTouchMove, {\n      passive: false,\n      capture\n    });\n    document[domMethod]('pointerup', swiper.onTouchEnd, {\n      passive: true\n    });\n    document[domMethod]('pointercancel', swiper.onTouchEnd, {\n      passive: true\n    });\n    document[domMethod]('pointerout', swiper.onTouchEnd, {\n      passive: true\n    });\n    document[domMethod]('pointerleave', swiper.onTouchEnd, {\n      passive: true\n    });\n\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n      el[domMethod]('click', swiper.onClick, true);\n    }\n    if (params.cssMode) {\n      wrapperEl[domMethod]('scroll', swiper.onScroll);\n    }\n\n    // Resize handler\n    if (params.updateOnWindowResize) {\n      swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n    } else {\n      swiper[swiperMethod]('observerUpdate', onResize, true);\n    }\n\n    // Images loader\n    el[domMethod]('load', swiper.onLoad, {\n      capture: true\n    });\n  };\n  function attachEvents() {\n    const swiper = this;\n    const document = getDocument();\n    const {\n      params\n    } = swiper;\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n    if (params.cssMode) {\n      swiper.onScroll = onScroll.bind(swiper);\n    }\n    swiper.onClick = onClick.bind(swiper);\n    swiper.onLoad = onLoad.bind(swiper);\n    if (!dummyEventAttached) {\n      document.addEventListener('touchstart', dummyEventListener);\n      dummyEventAttached = true;\n    }\n    events(swiper, 'on');\n  }\n  function detachEvents() {\n    const swiper = this;\n    events(swiper, 'off');\n  }\n  var events$1 = {\n    attachEvents,\n    detachEvents\n  };\n\n  const isGridEnabled = (swiper, params) => {\n    return swiper.grid && params.grid && params.grid.rows > 1;\n  };\n  function setBreakpoint() {\n    const swiper = this;\n    const {\n      realIndex,\n      initialized,\n      params,\n      el\n    } = swiper;\n    const breakpoints = params.breakpoints;\n    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n    // Get breakpoint for window width and update parameters\n    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    const wasMultiRow = isGridEnabled(swiper, params);\n    const isMultiRow = isGridEnabled(swiper, breakpointParams);\n    const wasEnabled = params.enabled;\n    if (wasMultiRow && !isMultiRow) {\n      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n      swiper.emitContainerClasses();\n    } else if (!wasMultiRow && isMultiRow) {\n      el.classList.add(`${params.containerModifierClass}grid`);\n      if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n        el.classList.add(`${params.containerModifierClass}grid-column`);\n      }\n      swiper.emitContainerClasses();\n    }\n\n    // Toggle navigation, pagination, scrollbar\n    ['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n      if (typeof breakpointParams[prop] === 'undefined') return;\n      const wasModuleEnabled = params[prop] && params[prop].enabled;\n      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n      if (wasModuleEnabled && !isModuleEnabled) {\n        swiper[prop].disable();\n      }\n      if (!wasModuleEnabled && isModuleEnabled) {\n        swiper[prop].enable();\n      }\n    });\n    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n    if (directionChanged && initialized) {\n      swiper.changeDirection();\n    }\n    extend(swiper.params, breakpointParams);\n    const isEnabled = swiper.params.enabled;\n    Object.assign(swiper, {\n      allowTouchMove: swiper.params.allowTouchMove,\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev\n    });\n    if (wasEnabled && !isEnabled) {\n      swiper.disable();\n    } else if (!wasEnabled && isEnabled) {\n      swiper.enable();\n    }\n    swiper.currentBreakpoint = breakpoint;\n    swiper.emit('_beforeBreakpoint', breakpointParams);\n    if (needsReLoop && initialized) {\n      swiper.loopDestroy();\n      swiper.loopCreate(realIndex);\n      swiper.updateSlides();\n    }\n    swiper.emit('breakpoint', breakpointParams);\n  }\n\n  function getBreakpoint(breakpoints, base, containerEl) {\n    if (base === void 0) {\n      base = 'window';\n    }\n    if (!breakpoints || base === 'container' && !containerEl) return undefined;\n    let breakpoint = false;\n    const window = getWindow();\n    const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n    const points = Object.keys(breakpoints).map(point => {\n      if (typeof point === 'string' && point.indexOf('@') === 0) {\n        const minRatio = parseFloat(point.substr(1));\n        const value = currentHeight * minRatio;\n        return {\n          value,\n          point\n        };\n      }\n      return {\n        value: point,\n        point\n      };\n    });\n    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n    for (let i = 0; i < points.length; i += 1) {\n      const {\n        point,\n        value\n      } = points[i];\n      if (base === 'window') {\n        if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n          breakpoint = point;\n        }\n      } else if (value <= containerEl.clientWidth) {\n        breakpoint = point;\n      }\n    }\n    return breakpoint || 'max';\n  }\n\n  var breakpoints = {\n    setBreakpoint,\n    getBreakpoint\n  };\n\n  function prepareClasses(entries, prefix) {\n    const resultClasses = [];\n    entries.forEach(item => {\n      if (typeof item === 'object') {\n        Object.keys(item).forEach(classNames => {\n          if (item[classNames]) {\n            resultClasses.push(prefix + classNames);\n          }\n        });\n      } else if (typeof item === 'string') {\n        resultClasses.push(prefix + item);\n      }\n    });\n    return resultClasses;\n  }\n  function addClasses() {\n    const swiper = this;\n    const {\n      classNames,\n      params,\n      rtl,\n      el,\n      device\n    } = swiper;\n    // prettier-ignore\n    const suffixes = prepareClasses(['initialized', params.direction, {\n      'free-mode': swiper.params.freeMode && params.freeMode.enabled\n    }, {\n      'autoheight': params.autoHeight\n    }, {\n      'rtl': rtl\n    }, {\n      'grid': params.grid && params.grid.rows > 1\n    }, {\n      'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n    }, {\n      'android': device.android\n    }, {\n      'ios': device.ios\n    }, {\n      'css-mode': params.cssMode\n    }, {\n      'centered': params.cssMode && params.centeredSlides\n    }, {\n      'watch-progress': params.watchSlidesProgress\n    }], params.containerModifierClass);\n    classNames.push(...suffixes);\n    el.classList.add(...classNames);\n    swiper.emitContainerClasses();\n  }\n\n  function removeClasses() {\n    const swiper = this;\n    const {\n      el,\n      classNames\n    } = swiper;\n    el.classList.remove(...classNames);\n    swiper.emitContainerClasses();\n  }\n\n  var classes = {\n    addClasses,\n    removeClasses\n  };\n\n  function checkOverflow() {\n    const swiper = this;\n    const {\n      isLocked: wasLocked,\n      params\n    } = swiper;\n    const {\n      slidesOffsetBefore\n    } = params;\n    if (slidesOffsetBefore) {\n      const lastSlideIndex = swiper.slides.length - 1;\n      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n      swiper.isLocked = swiper.size > lastSlideRightEdge;\n    } else {\n      swiper.isLocked = swiper.snapGrid.length === 1;\n    }\n    if (params.allowSlideNext === true) {\n      swiper.allowSlideNext = !swiper.isLocked;\n    }\n    if (params.allowSlidePrev === true) {\n      swiper.allowSlidePrev = !swiper.isLocked;\n    }\n    if (wasLocked && wasLocked !== swiper.isLocked) {\n      swiper.isEnd = false;\n    }\n    if (wasLocked !== swiper.isLocked) {\n      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n    }\n  }\n  var checkOverflow$1 = {\n    checkOverflow\n  };\n\n  var defaults = {\n    init: true,\n    direction: 'horizontal',\n    oneWayMovement: false,\n    touchEventsTarget: 'wrapper',\n    initialSlide: 0,\n    speed: 300,\n    cssMode: false,\n    updateOnWindowResize: true,\n    resizeObserver: true,\n    nested: false,\n    createElements: false,\n    enabled: true,\n    focusableElements: 'input, select, option, textarea, button, video, label',\n    // Overrides\n    width: null,\n    height: null,\n    //\n    preventInteractionOnTransition: false,\n    // ssr\n    userAgent: null,\n    url: null,\n    // To support iOS's swipe-to-go-back gesture (when being used in-app).\n    edgeSwipeDetection: false,\n    edgeSwipeThreshold: 20,\n    // Autoheight\n    autoHeight: false,\n    // Set wrapper width\n    setWrapperSize: false,\n    // Virtual Translate\n    virtualTranslate: false,\n    // Effects\n    effect: 'slide',\n    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n    // Breakpoints\n    breakpoints: undefined,\n    breakpointsBase: 'window',\n    // Slides grid\n    spaceBetween: 0,\n    slidesPerView: 1,\n    slidesPerGroup: 1,\n    slidesPerGroupSkip: 0,\n    slidesPerGroupAuto: false,\n    centeredSlides: false,\n    centeredSlidesBounds: false,\n    slidesOffsetBefore: 0,\n    // in px\n    slidesOffsetAfter: 0,\n    // in px\n    normalizeSlideIndex: true,\n    centerInsufficientSlides: false,\n    // Disable swiper and hide navigation when container not overflow\n    watchOverflow: true,\n    // Round length\n    roundLengths: false,\n    // Touches\n    touchRatio: 1,\n    touchAngle: 45,\n    simulateTouch: true,\n    shortSwipes: true,\n    longSwipes: true,\n    longSwipesRatio: 0.5,\n    longSwipesMs: 300,\n    followFinger: true,\n    allowTouchMove: true,\n    threshold: 5,\n    touchMoveStopPropagation: false,\n    touchStartPreventDefault: true,\n    touchStartForcePreventDefault: false,\n    touchReleaseOnEdges: false,\n    // Unique Navigation Elements\n    uniqueNavElements: true,\n    // Resistance\n    resistance: true,\n    resistanceRatio: 0.85,\n    // Progress\n    watchSlidesProgress: false,\n    // Cursor\n    grabCursor: false,\n    // Clicks\n    preventClicks: true,\n    preventClicksPropagation: true,\n    slideToClickedSlide: false,\n    // loop\n    loop: false,\n    loopedSlides: null,\n    loopPreventsSliding: true,\n    // rewind\n    rewind: false,\n    // Swiping/no swiping\n    allowSlidePrev: true,\n    allowSlideNext: true,\n    swipeHandler: null,\n    // '.swipe-handler',\n    noSwiping: true,\n    noSwipingClass: 'swiper-no-swiping',\n    noSwipingSelector: null,\n    // Passive Listeners\n    passiveListeners: true,\n    maxBackfaceHiddenSlides: 10,\n    // NS\n    containerModifierClass: 'swiper-',\n    // NEW\n    slideClass: 'swiper-slide',\n    slideActiveClass: 'swiper-slide-active',\n    slideVisibleClass: 'swiper-slide-visible',\n    slideNextClass: 'swiper-slide-next',\n    slidePrevClass: 'swiper-slide-prev',\n    wrapperClass: 'swiper-wrapper',\n    lazyPreloaderClass: 'swiper-lazy-preloader',\n    lazyPreloadPrevNext: 0,\n    // Callbacks\n    runCallbacksOnInit: true,\n    // Internals\n    _emitClasses: false\n  };\n\n  function moduleExtendParams(params, allModulesParams) {\n    return function extendParams(obj) {\n      if (obj === void 0) {\n        obj = {};\n      }\n      const moduleParamName = Object.keys(obj)[0];\n      const moduleParams = obj[moduleParamName];\n      if (typeof moduleParams !== 'object' || moduleParams === null) {\n        extend(allModulesParams, obj);\n        return;\n      }\n      if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n        params[moduleParamName] = {\n          auto: true\n        };\n      }\n      if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n        extend(allModulesParams, obj);\n        return;\n      }\n      if (params[moduleParamName] === true) {\n        params[moduleParamName] = {\n          enabled: true\n        };\n      }\n      if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n        params[moduleParamName].enabled = true;\n      }\n      if (!params[moduleParamName]) params[moduleParamName] = {\n        enabled: false\n      };\n      extend(allModulesParams, obj);\n    };\n  }\n\n  /* eslint no-param-reassign: \"off\" */\n  const prototypes = {\n    eventsEmitter,\n    update,\n    translate,\n    transition,\n    slide,\n    loop,\n    grabCursor,\n    events: events$1,\n    breakpoints,\n    checkOverflow: checkOverflow$1,\n    classes\n  };\n  const extendedDefaults = {};\n  class Swiper {\n    constructor() {\n      let el;\n      let params;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n        params = args[0];\n      } else {\n        [el, params] = args;\n      }\n      if (!params) params = {};\n      params = extend({}, params);\n      if (el && !params.el) params.el = el;\n      const document = getDocument();\n      if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n        const swipers = [];\n        document.querySelectorAll(params.el).forEach(containerEl => {\n          const newParams = extend({}, params, {\n            el: containerEl\n          });\n          swipers.push(new Swiper(newParams));\n        });\n        // eslint-disable-next-line no-constructor-return\n        return swipers;\n      }\n\n      // Swiper Instance\n      const swiper = this;\n      swiper.__swiper__ = true;\n      swiper.support = getSupport();\n      swiper.device = getDevice({\n        userAgent: params.userAgent\n      });\n      swiper.browser = getBrowser();\n      swiper.eventsListeners = {};\n      swiper.eventsAnyListeners = [];\n      swiper.modules = [...swiper.__modules__];\n      if (params.modules && Array.isArray(params.modules)) {\n        swiper.modules.push(...params.modules);\n      }\n      const allModulesParams = {};\n      swiper.modules.forEach(mod => {\n        mod({\n          params,\n          swiper,\n          extendParams: moduleExtendParams(params, allModulesParams),\n          on: swiper.on.bind(swiper),\n          once: swiper.once.bind(swiper),\n          off: swiper.off.bind(swiper),\n          emit: swiper.emit.bind(swiper)\n        });\n      });\n\n      // Extend defaults with modules params\n      const swiperParams = extend({}, defaults, allModulesParams);\n\n      // Extend defaults with passed params\n      swiper.params = extend({}, swiperParams, extendedDefaults, params);\n      swiper.originalParams = extend({}, swiper.params);\n      swiper.passedParams = extend({}, params);\n\n      // add event listeners\n      if (swiper.params && swiper.params.on) {\n        Object.keys(swiper.params.on).forEach(eventName => {\n          swiper.on(eventName, swiper.params.on[eventName]);\n        });\n      }\n      if (swiper.params && swiper.params.onAny) {\n        swiper.onAny(swiper.params.onAny);\n      }\n\n      // Extend Swiper\n      Object.assign(swiper, {\n        enabled: swiper.params.enabled,\n        el,\n        // Classes\n        classNames: [],\n        // Slides\n        slides: [],\n        slidesGrid: [],\n        snapGrid: [],\n        slidesSizesGrid: [],\n        // isDirection\n        isHorizontal() {\n          return swiper.params.direction === 'horizontal';\n        },\n        isVertical() {\n          return swiper.params.direction === 'vertical';\n        },\n        // Indexes\n        activeIndex: 0,\n        realIndex: 0,\n        //\n        isBeginning: true,\n        isEnd: false,\n        // Props\n        translate: 0,\n        previousTranslate: 0,\n        progress: 0,\n        velocity: 0,\n        animating: false,\n        cssOverflowAdjustment() {\n          // Returns 0 unless `translate` is > 2**23\n          // Should be subtracted from css values to prevent overflow\n          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n        },\n        // Locks\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev,\n        // Touch Events\n        touchEventsData: {\n          isTouched: undefined,\n          isMoved: undefined,\n          allowTouchCallbacks: undefined,\n          touchStartTime: undefined,\n          isScrolling: undefined,\n          currentTranslate: undefined,\n          startTranslate: undefined,\n          allowThresholdMove: undefined,\n          // Form elements to match\n          focusableElements: swiper.params.focusableElements,\n          // Last click time\n          lastClickTime: 0,\n          clickTimeout: undefined,\n          // Velocities\n          velocities: [],\n          allowMomentumBounce: undefined,\n          startMoving: undefined,\n          evCache: []\n        },\n        // Clicks\n        allowClick: true,\n        // Touches\n        allowTouchMove: swiper.params.allowTouchMove,\n        touches: {\n          startX: 0,\n          startY: 0,\n          currentX: 0,\n          currentY: 0,\n          diff: 0\n        },\n        // Images\n        imagesToLoad: [],\n        imagesLoaded: 0\n      });\n      swiper.emit('_swiper');\n\n      // Init\n      if (swiper.params.init) {\n        swiper.init();\n      }\n\n      // Return app instance\n      // eslint-disable-next-line no-constructor-return\n      return swiper;\n    }\n    getSlideIndex(slideEl) {\n      const {\n        slidesEl,\n        params\n      } = this;\n      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n      const firstSlideIndex = elementIndex(slides[0]);\n      return elementIndex(slideEl) - firstSlideIndex;\n    }\n    getSlideIndexByData(index) {\n      return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n    }\n    recalcSlides() {\n      const swiper = this;\n      const {\n        slidesEl,\n        params\n      } = swiper;\n      swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    }\n    enable() {\n      const swiper = this;\n      if (swiper.enabled) return;\n      swiper.enabled = true;\n      if (swiper.params.grabCursor) {\n        swiper.setGrabCursor();\n      }\n      swiper.emit('enable');\n    }\n    disable() {\n      const swiper = this;\n      if (!swiper.enabled) return;\n      swiper.enabled = false;\n      if (swiper.params.grabCursor) {\n        swiper.unsetGrabCursor();\n      }\n      swiper.emit('disable');\n    }\n    setProgress(progress, speed) {\n      const swiper = this;\n      progress = Math.min(Math.max(progress, 0), 1);\n      const min = swiper.minTranslate();\n      const max = swiper.maxTranslate();\n      const current = (max - min) * progress + min;\n      swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    emitContainerClasses() {\n      const swiper = this;\n      if (!swiper.params._emitClasses || !swiper.el) return;\n      const cls = swiper.el.className.split(' ').filter(className => {\n        return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n      });\n      swiper.emit('_containerClasses', cls.join(' '));\n    }\n    getSlideClasses(slideEl) {\n      const swiper = this;\n      if (swiper.destroyed) return '';\n      return slideEl.className.split(' ').filter(className => {\n        return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n      }).join(' ');\n    }\n    emitSlidesClasses() {\n      const swiper = this;\n      if (!swiper.params._emitClasses || !swiper.el) return;\n      const updates = [];\n      swiper.slides.forEach(slideEl => {\n        const classNames = swiper.getSlideClasses(slideEl);\n        updates.push({\n          slideEl,\n          classNames\n        });\n        swiper.emit('_slideClass', slideEl, classNames);\n      });\n      swiper.emit('_slideClasses', updates);\n    }\n    slidesPerViewDynamic(view, exact) {\n      if (view === void 0) {\n        view = 'current';\n      }\n      if (exact === void 0) {\n        exact = false;\n      }\n      const swiper = this;\n      const {\n        params,\n        slides,\n        slidesGrid,\n        slidesSizesGrid,\n        size: swiperSize,\n        activeIndex\n      } = swiper;\n      let spv = 1;\n      if (params.centeredSlides) {\n        let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n        let breakLoop;\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          if (slides[i] && !breakLoop) {\n            slideSize += slides[i].swiperSlideSize;\n            spv += 1;\n            if (slideSize > swiperSize) breakLoop = true;\n          }\n        }\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          if (slides[i] && !breakLoop) {\n            slideSize += slides[i].swiperSlideSize;\n            spv += 1;\n            if (slideSize > swiperSize) breakLoop = true;\n          }\n        }\n      } else {\n        // eslint-disable-next-line\n        if (view === 'current') {\n          for (let i = activeIndex + 1; i < slides.length; i += 1) {\n            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n            if (slideInView) {\n              spv += 1;\n            }\n          }\n        } else {\n          // previous\n          for (let i = activeIndex - 1; i >= 0; i -= 1) {\n            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n            if (slideInView) {\n              spv += 1;\n            }\n          }\n        }\n      }\n      return spv;\n    }\n    update() {\n      const swiper = this;\n      if (!swiper || swiper.destroyed) return;\n      const {\n        snapGrid,\n        params\n      } = swiper;\n      // Breakpoints\n      if (params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n      [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n        if (imageEl.complete) {\n          processLazyPreloader(swiper, imageEl);\n        }\n      });\n      swiper.updateSize();\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      function setTranslate() {\n        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n        swiper.setTranslate(newTranslate);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      let translated;\n      if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n        setTranslate();\n        if (params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n      } else {\n        if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n          const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n          translated = swiper.slideTo(slides.length - 1, 0, false, true);\n        } else {\n          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n        if (!translated) {\n          setTranslate();\n        }\n      }\n      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n      }\n      swiper.emit('update');\n    }\n    changeDirection(newDirection, needUpdate) {\n      if (needUpdate === void 0) {\n        needUpdate = true;\n      }\n      const swiper = this;\n      const currentDirection = swiper.params.direction;\n      if (!newDirection) {\n        // eslint-disable-next-line\n        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n      }\n      if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n        return swiper;\n      }\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n      swiper.emitContainerClasses();\n      swiper.params.direction = newDirection;\n      swiper.slides.forEach(slideEl => {\n        if (newDirection === 'vertical') {\n          slideEl.style.width = '';\n        } else {\n          slideEl.style.height = '';\n        }\n      });\n      swiper.emit('changeDirection');\n      if (needUpdate) swiper.update();\n      return swiper;\n    }\n    changeLanguageDirection(direction) {\n      const swiper = this;\n      if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n      swiper.rtl = direction === 'rtl';\n      swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n      if (swiper.rtl) {\n        swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n        swiper.el.dir = 'rtl';\n      } else {\n        swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n        swiper.el.dir = 'ltr';\n      }\n      swiper.update();\n    }\n    mount(element) {\n      const swiper = this;\n      if (swiper.mounted) return true;\n\n      // Find el\n      let el = element || swiper.params.el;\n      if (typeof el === 'string') {\n        el = document.querySelector(el);\n      }\n      if (!el) {\n        return false;\n      }\n      el.swiper = swiper;\n      if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === 'SWIPER-CONTAINER') {\n        swiper.isElement = true;\n      }\n      const getWrapperSelector = () => {\n        return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n      };\n      const getWrapper = () => {\n        if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n          const res = el.shadowRoot.querySelector(getWrapperSelector());\n          // Children needs to return slot items\n          return res;\n        }\n        return elementChildren(el, getWrapperSelector())[0];\n      };\n      // Find Wrapper\n      let wrapperEl = getWrapper();\n      if (!wrapperEl && swiper.params.createElements) {\n        wrapperEl = createElement('div', swiper.params.wrapperClass);\n        el.append(wrapperEl);\n        elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n          wrapperEl.append(slideEl);\n        });\n      }\n      Object.assign(swiper, {\n        el,\n        wrapperEl,\n        slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n        hostEl: swiper.isElement ? el.parentNode.host : el,\n        mounted: true,\n        // RTL\n        rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n        wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n      });\n      return true;\n    }\n    init(el) {\n      const swiper = this;\n      if (swiper.initialized) return swiper;\n      const mounted = swiper.mount(el);\n      if (mounted === false) return swiper;\n      swiper.emit('beforeInit');\n\n      // Set breakpoint\n      if (swiper.params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n\n      // Add Classes\n      swiper.addClasses();\n\n      // Update size\n      swiper.updateSize();\n\n      // Update slides\n      swiper.updateSlides();\n      if (swiper.params.watchOverflow) {\n        swiper.checkOverflow();\n      }\n\n      // Set Grab Cursor\n      if (swiper.params.grabCursor && swiper.enabled) {\n        swiper.setGrabCursor();\n      }\n\n      // Slide To Initial Slide\n      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n      } else {\n        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n      }\n\n      // Create loop\n      if (swiper.params.loop) {\n        swiper.loopCreate();\n      }\n\n      // Attach events\n      swiper.attachEvents();\n      [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n        if (imageEl.complete) {\n          processLazyPreloader(swiper, imageEl);\n        } else {\n          imageEl.addEventListener('load', e => {\n            processLazyPreloader(swiper, e.target);\n          });\n        }\n      });\n      preload(swiper);\n\n      // Init Flag\n      swiper.initialized = true;\n      preload(swiper);\n\n      // Emit\n      swiper.emit('init');\n      swiper.emit('afterInit');\n      return swiper;\n    }\n    destroy(deleteInstance, cleanStyles) {\n      if (deleteInstance === void 0) {\n        deleteInstance = true;\n      }\n      if (cleanStyles === void 0) {\n        cleanStyles = true;\n      }\n      const swiper = this;\n      const {\n        params,\n        el,\n        wrapperEl,\n        slides\n      } = swiper;\n      if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n        return null;\n      }\n      swiper.emit('beforeDestroy');\n\n      // Init Flag\n      swiper.initialized = false;\n\n      // Detach events\n      swiper.detachEvents();\n\n      // Destroy loop\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n\n      // Cleanup styles\n      if (cleanStyles) {\n        swiper.removeClasses();\n        el.removeAttribute('style');\n        wrapperEl.removeAttribute('style');\n        if (slides && slides.length) {\n          slides.forEach(slideEl => {\n            slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n            slideEl.removeAttribute('style');\n            slideEl.removeAttribute('data-swiper-slide-index');\n          });\n        }\n      }\n      swiper.emit('destroy');\n\n      // Detach emitter events\n      Object.keys(swiper.eventsListeners).forEach(eventName => {\n        swiper.off(eventName);\n      });\n      if (deleteInstance !== false) {\n        swiper.el.swiper = null;\n        deleteProps(swiper);\n      }\n      swiper.destroyed = true;\n      return null;\n    }\n    static extendDefaults(newDefaults) {\n      extend(extendedDefaults, newDefaults);\n    }\n    static get extendedDefaults() {\n      return extendedDefaults;\n    }\n    static get defaults() {\n      return defaults;\n    }\n    static installModule(mod) {\n      if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n      const modules = Swiper.prototype.__modules__;\n      if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n        modules.push(mod);\n      }\n    }\n    static use(module) {\n      if (Array.isArray(module)) {\n        module.forEach(m => Swiper.installModule(m));\n        return Swiper;\n      }\n      Swiper.installModule(module);\n      return Swiper;\n    }\n  }\n  Object.keys(prototypes).forEach(prototypeGroup => {\n    Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n    });\n  });\n  Swiper.use([Resize, Observer]);\n\n  function Virtual(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    extendParams({\n      virtual: {\n        enabled: false,\n        slides: [],\n        cache: true,\n        renderSlide: null,\n        renderExternal: null,\n        renderExternalUpdate: true,\n        addSlidesBefore: 0,\n        addSlidesAfter: 0\n      }\n    });\n    let cssModeTimeout;\n    const document = getDocument();\n    swiper.virtual = {\n      cache: {},\n      from: undefined,\n      to: undefined,\n      slides: [],\n      offset: 0,\n      slidesGrid: []\n    };\n    const tempDOM = document.createElement('div');\n    function renderSlide(slide, index) {\n      const params = swiper.params.virtual;\n      if (params.cache && swiper.virtual.cache[index]) {\n        return swiper.virtual.cache[index];\n      }\n      // eslint-disable-next-line\n      let slideEl;\n      if (params.renderSlide) {\n        slideEl = params.renderSlide.call(swiper, slide, index);\n        if (typeof slideEl === 'string') {\n          tempDOM.innerHTML = slideEl;\n          slideEl = tempDOM.children[0];\n        }\n      } else if (swiper.isElement) {\n        slideEl = createElement('swiper-slide');\n      } else {\n        slideEl = createElement('div', swiper.params.slideClass);\n      }\n      slideEl.setAttribute('data-swiper-slide-index', index);\n      if (!params.renderSlide) {\n        slideEl.innerHTML = slide;\n      }\n      if (params.cache) swiper.virtual.cache[index] = slideEl;\n      return slideEl;\n    }\n    function update(force) {\n      const {\n        slidesPerView,\n        slidesPerGroup,\n        centeredSlides,\n        loop: isLoop\n      } = swiper.params;\n      const {\n        addSlidesBefore,\n        addSlidesAfter\n      } = swiper.params.virtual;\n      const {\n        from: previousFrom,\n        to: previousTo,\n        slides,\n        slidesGrid: previousSlidesGrid,\n        offset: previousOffset\n      } = swiper.virtual;\n      if (!swiper.params.cssMode) {\n        swiper.updateActiveIndex();\n      }\n      const activeIndex = swiper.activeIndex || 0;\n      let offsetProp;\n      if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n      let slidesAfter;\n      let slidesBefore;\n      if (centeredSlides) {\n        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n      } else {\n        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n        slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n      }\n      let from = activeIndex - slidesBefore;\n      let to = activeIndex + slidesAfter;\n      if (!isLoop) {\n        from = Math.max(from, 0);\n        to = Math.min(to, slides.length - 1);\n      }\n      let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n      if (isLoop && activeIndex >= slidesBefore) {\n        from -= slidesBefore;\n        if (!centeredSlides) offset += swiper.slidesGrid[0];\n      } else if (isLoop && activeIndex < slidesBefore) {\n        from = -slidesBefore;\n        if (centeredSlides) offset += swiper.slidesGrid[0];\n      }\n      Object.assign(swiper.virtual, {\n        from,\n        to,\n        offset,\n        slidesGrid: swiper.slidesGrid,\n        slidesBefore,\n        slidesAfter\n      });\n      function onRendered() {\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n        emit('virtualUpdate');\n      }\n      if (previousFrom === from && previousTo === to && !force) {\n        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n          swiper.slides.forEach(slideEl => {\n            slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n          });\n        }\n        swiper.updateProgress();\n        emit('virtualUpdate');\n        return;\n      }\n      if (swiper.params.virtual.renderExternal) {\n        swiper.params.virtual.renderExternal.call(swiper, {\n          offset,\n          from,\n          to,\n          slides: function getSlides() {\n            const slidesToRender = [];\n            for (let i = from; i <= to; i += 1) {\n              slidesToRender.push(slides[i]);\n            }\n            return slidesToRender;\n          }()\n        });\n        if (swiper.params.virtual.renderExternalUpdate) {\n          onRendered();\n        } else {\n          emit('virtualUpdate');\n        }\n        return;\n      }\n      const prependIndexes = [];\n      const appendIndexes = [];\n      const getSlideIndex = index => {\n        let slideIndex = index;\n        if (index < 0) {\n          slideIndex = slides.length + index;\n        } else if (slideIndex >= slides.length) {\n          // eslint-disable-next-line\n          slideIndex = slideIndex - slides.length;\n        }\n        return slideIndex;\n      };\n      if (force) {\n        swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach(slideEl => {\n          slideEl.remove();\n        });\n      } else {\n        for (let i = previousFrom; i <= previousTo; i += 1) {\n          if (i < from || i > to) {\n            const slideIndex = getSlideIndex(i);\n            swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach(slideEl => {\n              slideEl.remove();\n            });\n          }\n        }\n      }\n      const loopFrom = isLoop ? -slides.length : 0;\n      const loopTo = isLoop ? slides.length * 2 : slides.length;\n      for (let i = loopFrom; i < loopTo; i += 1) {\n        if (i >= from && i <= to) {\n          const slideIndex = getSlideIndex(i);\n          if (typeof previousTo === 'undefined' || force) {\n            appendIndexes.push(slideIndex);\n          } else {\n            if (i > previousTo) appendIndexes.push(slideIndex);\n            if (i < previousFrom) prependIndexes.push(slideIndex);\n          }\n        }\n      }\n      appendIndexes.forEach(index => {\n        swiper.slidesEl.append(renderSlide(slides[index], index));\n      });\n      if (isLoop) {\n        for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n          const index = prependIndexes[i];\n          swiper.slidesEl.prepend(renderSlide(slides[index], index));\n        }\n      } else {\n        prependIndexes.sort((a, b) => b - a);\n        prependIndexes.forEach(index => {\n          swiper.slidesEl.prepend(renderSlide(slides[index], index));\n        });\n      }\n      elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n        slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n      });\n      onRendered();\n    }\n    function appendSlide(slides) {\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) swiper.virtual.slides.push(slides[i]);\n        }\n      } else {\n        swiper.virtual.slides.push(slides);\n      }\n      update(true);\n    }\n    function prependSlide(slides) {\n      const activeIndex = swiper.activeIndex;\n      let newActiveIndex = activeIndex + 1;\n      let numberOfNewSlides = 1;\n      if (Array.isArray(slides)) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n        }\n        newActiveIndex = activeIndex + slides.length;\n        numberOfNewSlides = slides.length;\n      } else {\n        swiper.virtual.slides.unshift(slides);\n      }\n      if (swiper.params.virtual.cache) {\n        const cache = swiper.virtual.cache;\n        const newCache = {};\n        Object.keys(cache).forEach(cachedIndex => {\n          const cachedEl = cache[cachedIndex];\n          const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n          if (cachedElIndex) {\n            cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n          }\n          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n        });\n        swiper.virtual.cache = newCache;\n      }\n      update(true);\n      swiper.slideTo(newActiveIndex, 0);\n    }\n    function removeSlide(slidesIndexes) {\n      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n      let activeIndex = swiper.activeIndex;\n      if (Array.isArray(slidesIndexes)) {\n        for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n          swiper.virtual.slides.splice(slidesIndexes[i], 1);\n          if (swiper.params.virtual.cache) {\n            delete swiper.virtual.cache[slidesIndexes[i]];\n          }\n          if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n          activeIndex = Math.max(activeIndex, 0);\n        }\n      } else {\n        swiper.virtual.slides.splice(slidesIndexes, 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes];\n        }\n        if (slidesIndexes < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n      update(true);\n      swiper.slideTo(activeIndex, 0);\n    }\n    function removeAllSlides() {\n      swiper.virtual.slides = [];\n      if (swiper.params.virtual.cache) {\n        swiper.virtual.cache = {};\n      }\n      update(true);\n      swiper.slideTo(0, 0);\n    }\n    on('beforeInit', () => {\n      if (!swiper.params.virtual.enabled) return;\n      let domSlidesAssigned;\n      if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n        const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n        if (slides && slides.length) {\n          swiper.virtual.slides = [...slides];\n          domSlidesAssigned = true;\n          slides.forEach((slideEl, slideIndex) => {\n            slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n            swiper.virtual.cache[slideIndex] = slideEl;\n            slideEl.remove();\n          });\n        }\n      }\n      if (!domSlidesAssigned) {\n        swiper.virtual.slides = swiper.params.virtual.slides;\n      }\n      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n      if (!swiper.params.initialSlide) {\n        update();\n      }\n    });\n    on('setTranslate', () => {\n      if (!swiper.params.virtual.enabled) return;\n      if (swiper.params.cssMode && !swiper._immediateVirtual) {\n        clearTimeout(cssModeTimeout);\n        cssModeTimeout = setTimeout(() => {\n          update();\n        }, 100);\n      } else {\n        update();\n      }\n    });\n    on('init update resize', () => {\n      if (!swiper.params.virtual.enabled) return;\n      if (swiper.params.cssMode) {\n        setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n      }\n    });\n    Object.assign(swiper.virtual, {\n      appendSlide,\n      prependSlide,\n      removeSlide,\n      removeAllSlides,\n      update\n    });\n  }\n\n  /* eslint-disable consistent-return */\n  function Keyboard(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const document = getDocument();\n    const window = getWindow();\n    swiper.keyboard = {\n      enabled: false\n    };\n    extendParams({\n      keyboard: {\n        enabled: false,\n        onlyInViewport: true,\n        pageUpDown: true\n      }\n    });\n    function handle(event) {\n      if (!swiper.enabled) return;\n      const {\n        rtlTranslate: rtl\n      } = swiper;\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent; // jquery fix\n      const kc = e.keyCode || e.charCode;\n      const pageUpDown = swiper.params.keyboard.pageUpDown;\n      const isPageUp = pageUpDown && kc === 33;\n      const isPageDown = pageUpDown && kc === 34;\n      const isArrowLeft = kc === 37;\n      const isArrowRight = kc === 39;\n      const isArrowUp = kc === 38;\n      const isArrowDown = kc === 40;\n      // Directions locks\n      if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n        return false;\n      }\n      if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n        return false;\n      }\n      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n        return undefined;\n      }\n      if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n        return undefined;\n      }\n      if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n        let inView = false;\n        // Check that swiper should be inside of visible area of window\n        if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n          return undefined;\n        }\n        const el = swiper.el;\n        const swiperWidth = el.clientWidth;\n        const swiperHeight = el.clientHeight;\n        const windowWidth = window.innerWidth;\n        const windowHeight = window.innerHeight;\n        const swiperOffset = elementOffset(el);\n        if (rtl) swiperOffset.left -= el.scrollLeft;\n        const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n        for (let i = 0; i < swiperCoord.length; i += 1) {\n          const point = swiperCoord[i];\n          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n            if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n            inView = true;\n          }\n        }\n        if (!inView) return undefined;\n      }\n      if (swiper.isHorizontal()) {\n        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n          if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        }\n        if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n        if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n      } else {\n        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n          if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        }\n        if (isPageDown || isArrowDown) swiper.slideNext();\n        if (isPageUp || isArrowUp) swiper.slidePrev();\n      }\n      emit('keyPress', kc);\n      return undefined;\n    }\n    function enable() {\n      if (swiper.keyboard.enabled) return;\n      document.addEventListener('keydown', handle);\n      swiper.keyboard.enabled = true;\n    }\n    function disable() {\n      if (!swiper.keyboard.enabled) return;\n      document.removeEventListener('keydown', handle);\n      swiper.keyboard.enabled = false;\n    }\n    on('init', () => {\n      if (swiper.params.keyboard.enabled) {\n        enable();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.keyboard.enabled) {\n        disable();\n      }\n    });\n    Object.assign(swiper.keyboard, {\n      enable,\n      disable\n    });\n  }\n\n  /* eslint-disable consistent-return */\n  function Mousewheel(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const window = getWindow();\n    extendParams({\n      mousewheel: {\n        enabled: false,\n        releaseOnEdges: false,\n        invert: false,\n        forceToAxis: false,\n        sensitivity: 1,\n        eventsTarget: 'container',\n        thresholdDelta: null,\n        thresholdTime: null,\n        noMousewheelClass: 'swiper-no-mousewheel'\n      }\n    });\n    swiper.mousewheel = {\n      enabled: false\n    };\n    let timeout;\n    let lastScrollTime = now();\n    let lastEventBeforeSnap;\n    const recentWheelEvents = [];\n    function normalize(e) {\n      // Reasonable defaults\n      const PIXEL_STEP = 10;\n      const LINE_HEIGHT = 40;\n      const PAGE_HEIGHT = 800;\n      let sX = 0;\n      let sY = 0; // spinX, spinY\n      let pX = 0;\n      let pY = 0; // pixelX, pixelY\n\n      // Legacy\n      if ('detail' in e) {\n        sY = e.detail;\n      }\n      if ('wheelDelta' in e) {\n        sY = -e.wheelDelta / 120;\n      }\n      if ('wheelDeltaY' in e) {\n        sY = -e.wheelDeltaY / 120;\n      }\n      if ('wheelDeltaX' in e) {\n        sX = -e.wheelDeltaX / 120;\n      }\n\n      // side scrolling on FF with DOMMouseScroll\n      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n        sX = sY;\n        sY = 0;\n      }\n      pX = sX * PIXEL_STEP;\n      pY = sY * PIXEL_STEP;\n      if ('deltaY' in e) {\n        pY = e.deltaY;\n      }\n      if ('deltaX' in e) {\n        pX = e.deltaX;\n      }\n      if (e.shiftKey && !pX) {\n        // if user scrolls with shift he wants horizontal scroll\n        pX = pY;\n        pY = 0;\n      }\n      if ((pX || pY) && e.deltaMode) {\n        if (e.deltaMode === 1) {\n          // delta in LINE units\n          pX *= LINE_HEIGHT;\n          pY *= LINE_HEIGHT;\n        } else {\n          // delta in PAGE units\n          pX *= PAGE_HEIGHT;\n          pY *= PAGE_HEIGHT;\n        }\n      }\n\n      // Fall-back if spin cannot be determined\n      if (pX && !sX) {\n        sX = pX < 1 ? -1 : 1;\n      }\n      if (pY && !sY) {\n        sY = pY < 1 ? -1 : 1;\n      }\n      return {\n        spinX: sX,\n        spinY: sY,\n        pixelX: pX,\n        pixelY: pY\n      };\n    }\n    function handleMouseEnter() {\n      if (!swiper.enabled) return;\n      swiper.mouseEntered = true;\n    }\n    function handleMouseLeave() {\n      if (!swiper.enabled) return;\n      swiper.mouseEntered = false;\n    }\n    function animateSlider(newEvent) {\n      if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n        // Prevent if delta of wheel scroll delta is below configured threshold\n        return false;\n      }\n      if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n        // Prevent if time between scrolls is below configured threshold\n        return false;\n      }\n\n      // If the movement is NOT big enough and\n      // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n      //   Don't go any further (avoid insignificant scroll movement).\n      if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n        // Return false as a default\n        return true;\n      }\n      // If user is scrolling towards the end:\n      //   If the slider hasn't hit the latest slide or\n      //   if the slider is a loop and\n      //   if the slider isn't moving right now:\n      //     Go to next slide and\n      //     emit a scroll event.\n      // Else (the user is scrolling towards the beginning) and\n      // if the slider hasn't hit the first slide or\n      // if the slider is a loop and\n      // if the slider isn't moving right now:\n      //   Go to prev slide and\n      //   emit a scroll event.\n      if (newEvent.direction < 0) {\n        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n          swiper.slideNext();\n          emit('scroll', newEvent.raw);\n        }\n      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n        swiper.slidePrev();\n        emit('scroll', newEvent.raw);\n      }\n      // If you got here is because an animation has been triggered so store the current time\n      lastScrollTime = new window.Date().getTime();\n      // Return false as a default\n      return false;\n    }\n    function releaseScroll(newEvent) {\n      const params = swiper.params.mousewheel;\n      if (newEvent.direction < 0) {\n        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n          // Return true to animate scroll on edges\n          return true;\n        }\n      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n      return false;\n    }\n    function handle(event) {\n      let e = event;\n      let disableParentSwiper = true;\n      if (!swiper.enabled) return;\n\n      // Ignore event if the target or its parents have the swiper-no-mousewheel class\n      if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n      const params = swiper.params.mousewheel;\n      if (swiper.params.cssMode) {\n        e.preventDefault();\n      }\n      let targetEl = swiper.el;\n      if (swiper.params.mousewheel.eventsTarget !== 'container') {\n        targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n      }\n      const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n      if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n      if (e.originalEvent) e = e.originalEvent; // jquery fix\n      let delta = 0;\n      const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n      const data = normalize(e);\n      if (params.forceToAxis) {\n        if (swiper.isHorizontal()) {\n          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n      } else {\n        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n      }\n      if (delta === 0) return true;\n      if (params.invert) delta = -delta;\n\n      // Get the scroll positions\n      let positions = swiper.getTranslate() + delta * params.sensitivity;\n      if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n      if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n      // When loop is true:\n      //     the disableParentSwiper will be true.\n      // When loop is false:\n      //     if the scroll positions is not on edge,\n      //     then the disableParentSwiper will be true.\n      //     if the scroll on edge positions,\n      //     then the disableParentSwiper will be false.\n      disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n      if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n      if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n        // Register the new event in a variable which stores the relevant data\n        const newEvent = {\n          time: now(),\n          delta: Math.abs(delta),\n          direction: Math.sign(delta),\n          raw: event\n        };\n\n        // Keep the most recent events\n        if (recentWheelEvents.length >= 2) {\n          recentWheelEvents.shift(); // only store the last N events\n        }\n\n        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n        recentWheelEvents.push(newEvent);\n\n        // If there is at least one previous recorded event:\n        //   If direction has changed or\n        //   if the scroll is quicker than the previous one:\n        //     Animate the slider.\n        // Else (this is the first time the wheel is moved):\n        //     Animate the slider.\n        if (prevEvent) {\n          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n            animateSlider(newEvent);\n          }\n        } else {\n          animateSlider(newEvent);\n        }\n\n        // If it's time to release the scroll:\n        //   Return now so you don't hit the preventDefault.\n        if (releaseScroll(newEvent)) {\n          return true;\n        }\n      } else {\n        // Freemode or scrollContainer:\n\n        // If we recently snapped after a momentum scroll, then ignore wheel events\n        // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n        // or if it's a new scroll (larger delta or inverse sign as last event before\n        // an end-of-momentum snap).\n        const newEvent = {\n          time: now(),\n          delta: Math.abs(delta),\n          direction: Math.sign(delta)\n        };\n        const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n        if (!ignoreWheelEvents) {\n          lastEventBeforeSnap = undefined;\n          let position = swiper.getTranslate() + delta * params.sensitivity;\n          const wasBeginning = swiper.isBeginning;\n          const wasEnd = swiper.isEnd;\n          if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n          if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n          swiper.setTransition(0);\n          swiper.setTranslate(position);\n          swiper.updateProgress();\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n          if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n            swiper.updateSlidesClasses();\n          }\n          if (swiper.params.loop) {\n            swiper.loopFix({\n              direction: newEvent.direction < 0 ? 'next' : 'prev',\n              byMousewheel: true\n            });\n          }\n          if (swiper.params.freeMode.sticky) {\n            // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n            // the end of a momentum scroll by storing recent (N=15?) wheel events.\n            // 1. do all N events have decreasing or same (absolute value) delta?\n            // 2. did all N events arrive in the last M (M=500?) msecs?\n            // 3. does the earliest event have an (absolute value) delta that's\n            //    at least P (P=1?) larger than the most recent event's delta?\n            // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n            // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n            // Snap immediately and ignore remaining wheel events in this scroll.\n            // See comment above for \"remaining wheel events in this scroll\" determination.\n            // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n            clearTimeout(timeout);\n            timeout = undefined;\n            if (recentWheelEvents.length >= 15) {\n              recentWheelEvents.shift(); // only store the last N events\n            }\n\n            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n            const firstEvent = recentWheelEvents[0];\n            recentWheelEvents.push(newEvent);\n            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n              // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n              recentWheelEvents.splice(0);\n            } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n              // We're at the end of the deceleration of a momentum scroll, so there's no need\n              // to wait for more events. Snap ASAP on the next tick.\n              // Also, because there's some remaining momentum we'll bias the snap in the\n              // direction of the ongoing scroll because it's better UX for the scroll to snap\n              // in the same direction as the scroll instead of reversing to snap.  Therefore,\n              // if it's already scrolled more than 20% in the current direction, keep going.\n              const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              timeout = nextTick(() => {\n                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n              }, 0); // no delay; move on next tick\n            }\n\n            if (!timeout) {\n              // if we get here, then we haven't detected the end of a momentum scroll, so\n              // we'll consider a scroll \"complete\" when there haven't been any wheel events\n              // for 500ms.\n              timeout = nextTick(() => {\n                const snapToThreshold = 0.5;\n                lastEventBeforeSnap = newEvent;\n                recentWheelEvents.splice(0);\n                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n              }, 500);\n            }\n          }\n\n          // Emit event\n          if (!ignoreWheelEvents) emit('scroll', e);\n\n          // Stop autoplay\n          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n          // Return page scroll on edge positions\n          if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n            return true;\n          }\n        }\n      }\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      return false;\n    }\n    function events(method) {\n      let targetEl = swiper.el;\n      if (swiper.params.mousewheel.eventsTarget !== 'container') {\n        targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n      }\n      targetEl[method]('mouseenter', handleMouseEnter);\n      targetEl[method]('mouseleave', handleMouseLeave);\n      targetEl[method]('wheel', handle);\n    }\n    function enable() {\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.removeEventListener('wheel', handle);\n        return true;\n      }\n      if (swiper.mousewheel.enabled) return false;\n      events('addEventListener');\n      swiper.mousewheel.enabled = true;\n      return true;\n    }\n    function disable() {\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.addEventListener(event, handle);\n        return true;\n      }\n      if (!swiper.mousewheel.enabled) return false;\n      events('removeEventListener');\n      swiper.mousewheel.enabled = false;\n      return true;\n    }\n    on('init', () => {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        disable();\n      }\n      if (swiper.params.mousewheel.enabled) enable();\n    });\n    on('destroy', () => {\n      if (swiper.params.cssMode) {\n        enable();\n      }\n      if (swiper.mousewheel.enabled) disable();\n    });\n    Object.assign(swiper.mousewheel, {\n      enable,\n      disable\n    });\n  }\n\n  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n    if (swiper.params.createElements) {\n      Object.keys(checkProps).forEach(key => {\n        if (!params[key] && params.auto === true) {\n          let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n          if (!element) {\n            element = createElement('div', checkProps[key]);\n            element.className = checkProps[key];\n            swiper.el.append(element);\n          }\n          params[key] = element;\n          originalParams[key] = element;\n        }\n      });\n    }\n    return params;\n  }\n\n  function Navigation(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    extendParams({\n      navigation: {\n        nextEl: null,\n        prevEl: null,\n        hideOnClick: false,\n        disabledClass: 'swiper-button-disabled',\n        hiddenClass: 'swiper-button-hidden',\n        lockClass: 'swiper-button-lock',\n        navigationDisabledClass: 'swiper-navigation-disabled'\n      }\n    });\n    swiper.navigation = {\n      nextEl: null,\n      prevEl: null\n    };\n    const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);\n    function getEl(el) {\n      let res;\n      if (el && typeof el === 'string' && swiper.isElement) {\n        res = swiper.el.querySelector(el);\n        if (res) return res;\n      }\n      if (el) {\n        if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n        if (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n          res = swiper.el.querySelector(el);\n        }\n      }\n      if (el && !res) return el;\n      // if (Array.isArray(res) && res.length === 1) res = res[0];\n      return res;\n    }\n    function toggleEl(el, disabled) {\n      const params = swiper.params.navigation;\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        if (subEl) {\n          subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n          if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n          if (swiper.params.watchOverflow && swiper.enabled) {\n            subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n          }\n        }\n      });\n    }\n    function update() {\n      // Update Navigation Buttons\n      const {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      if (swiper.params.loop) {\n        toggleEl(prevEl, false);\n        toggleEl(nextEl, false);\n        return;\n      }\n      toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n      toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n    }\n    function onPrevClick(e) {\n      e.preventDefault();\n      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n      swiper.slidePrev();\n      emit('navigationPrev');\n    }\n    function onNextClick(e) {\n      e.preventDefault();\n      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n      swiper.slideNext();\n      emit('navigationNext');\n    }\n    function init() {\n      const params = swiper.params.navigation;\n      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n        nextEl: 'swiper-button-next',\n        prevEl: 'swiper-button-prev'\n      });\n      if (!(params.nextEl || params.prevEl)) return;\n      let nextEl = getEl(params.nextEl);\n      let prevEl = getEl(params.prevEl);\n      Object.assign(swiper.navigation, {\n        nextEl,\n        prevEl\n      });\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      const initButton = (el, dir) => {\n        if (el) {\n          el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n        }\n        if (!swiper.enabled && el) {\n          el.classList.add(...params.lockClass.split(' '));\n        }\n      };\n      nextEl.forEach(el => initButton(el, 'next'));\n      prevEl.forEach(el => initButton(el, 'prev'));\n    }\n    function destroy() {\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      const destroyButton = (el, dir) => {\n        el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n        el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n      };\n      nextEl.forEach(el => destroyButton(el, 'next'));\n      prevEl.forEach(el => destroyButton(el, 'prev'));\n    }\n    on('init', () => {\n      if (swiper.params.navigation.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        update();\n      }\n    });\n    on('toEdge fromEdge lock unlock', () => {\n      update();\n    });\n    on('destroy', () => {\n      destroy();\n    });\n    on('enable disable', () => {\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass));\n    });\n    on('click', (_s, e) => {\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      const targetEl = e.target;\n      if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n        let isHidden;\n        if (nextEl.length) {\n          isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n        } else if (prevEl.length) {\n          isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n        }\n        if (isHidden === true) {\n          emit('navigationShow');\n        } else {\n          emit('navigationHide');\n        }\n        [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n      }\n    });\n    const enable = () => {\n      swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n      init();\n      update();\n    };\n    const disable = () => {\n      swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n      destroy();\n    };\n    Object.assign(swiper.navigation, {\n      enable,\n      disable,\n      update,\n      init,\n      destroy\n    });\n  }\n\n  function classesToSelector(classes) {\n    if (classes === void 0) {\n      classes = '';\n    }\n    return `.${classes.trim().replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n  .replace(/ /g, '.')}`;\n  }\n\n  function Pagination(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const pfx = 'swiper-pagination';\n    extendParams({\n      pagination: {\n        el: null,\n        bulletElement: 'span',\n        clickable: false,\n        hideOnClick: false,\n        renderBullet: null,\n        renderProgressbar: null,\n        renderFraction: null,\n        renderCustom: null,\n        progressbarOpposite: false,\n        type: 'bullets',\n        // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n        dynamicBullets: false,\n        dynamicMainBullets: 1,\n        formatFractionCurrent: number => number,\n        formatFractionTotal: number => number,\n        bulletClass: `${pfx}-bullet`,\n        bulletActiveClass: `${pfx}-bullet-active`,\n        modifierClass: `${pfx}-`,\n        currentClass: `${pfx}-current`,\n        totalClass: `${pfx}-total`,\n        hiddenClass: `${pfx}-hidden`,\n        progressbarFillClass: `${pfx}-progressbar-fill`,\n        progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n        clickableClass: `${pfx}-clickable`,\n        lockClass: `${pfx}-lock`,\n        horizontalClass: `${pfx}-horizontal`,\n        verticalClass: `${pfx}-vertical`,\n        paginationDisabledClass: `${pfx}-disabled`\n      }\n    });\n    swiper.pagination = {\n      el: null,\n      bullets: []\n    };\n    let bulletSize;\n    let dynamicBulletIndex = 0;\n    const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);\n    function isPaginationDisabled() {\n      return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n    }\n    function setSideBullets(bulletEl, position) {\n      const {\n        bulletActiveClass\n      } = swiper.params.pagination;\n      if (!bulletEl) return;\n      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n      if (bulletEl) {\n        bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n        bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n        if (bulletEl) {\n          bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n        }\n      }\n    }\n    function onBulletClick(e) {\n      const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n      if (!bulletEl) {\n        return;\n      }\n      e.preventDefault();\n      const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n      if (swiper.params.loop) {\n        if (swiper.realIndex === index) return;\n        const newSlideIndex = swiper.getSlideIndexByData(index);\n        const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n        if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {\n          swiper.loopFix({\n            direction: newSlideIndex > currentSlideIndex ? 'next' : 'prev',\n            activeSlideIndex: newSlideIndex,\n            slideTo: false\n          });\n        }\n        swiper.slideToLoop(index);\n      } else {\n        swiper.slideTo(index);\n      }\n    }\n    function update() {\n      // Render || Update Pagination bullets/items\n      const rtl = swiper.rtl;\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      let el = swiper.pagination.el;\n      el = makeElementsArray(el);\n      // Current/Total\n      let current;\n      let previousIndex;\n      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n      const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      if (swiper.params.loop) {\n        previousIndex = swiper.previousRealIndex || 0;\n        current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n      } else if (typeof swiper.snapIndex !== 'undefined') {\n        current = swiper.snapIndex;\n        previousIndex = swiper.previousSnapIndex;\n      } else {\n        previousIndex = swiper.previousIndex || 0;\n        current = swiper.activeIndex || 0;\n      }\n      // Types\n      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n        const bullets = swiper.pagination.bullets;\n        let firstIndex;\n        let lastIndex;\n        let midIndex;\n        if (params.dynamicBullets) {\n          bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n          el.forEach(subEl => {\n            subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n          });\n          if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n            dynamicBulletIndex += current - (previousIndex || 0);\n            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n              dynamicBulletIndex = params.dynamicMainBullets - 1;\n            } else if (dynamicBulletIndex < 0) {\n              dynamicBulletIndex = 0;\n            }\n          }\n          firstIndex = Math.max(current - dynamicBulletIndex, 0);\n          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n          midIndex = (lastIndex + firstIndex) / 2;\n        }\n        bullets.forEach(bulletEl => {\n          const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n          bulletEl.classList.remove(...classesToRemove);\n        });\n        if (el.length > 1) {\n          bullets.forEach(bullet => {\n            const bulletIndex = elementIndex(bullet);\n            if (bulletIndex === current) {\n              bullet.classList.add(...params.bulletActiveClass.split(' '));\n            } else if (swiper.isElement) {\n              bullet.setAttribute('part', 'bullet');\n            }\n            if (params.dynamicBullets) {\n              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n                bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n              }\n              if (bulletIndex === firstIndex) {\n                setSideBullets(bullet, 'prev');\n              }\n              if (bulletIndex === lastIndex) {\n                setSideBullets(bullet, 'next');\n              }\n            }\n          });\n        } else {\n          const bullet = bullets[current];\n          if (bullet) {\n            bullet.classList.add(...params.bulletActiveClass.split(' '));\n          }\n          if (swiper.isElement) {\n            bullets.forEach((bulletEl, bulletIndex) => {\n              bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n            });\n          }\n          if (params.dynamicBullets) {\n            const firstDisplayedBullet = bullets[firstIndex];\n            const lastDisplayedBullet = bullets[lastIndex];\n            for (let i = firstIndex; i <= lastIndex; i += 1) {\n              if (bullets[i]) {\n                bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n              }\n            }\n            setSideBullets(firstDisplayedBullet, 'prev');\n            setSideBullets(lastDisplayedBullet, 'next');\n          }\n        }\n        if (params.dynamicBullets) {\n          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n          const offsetProp = rtl ? 'right' : 'left';\n          bullets.forEach(bullet => {\n            bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n          });\n        }\n      }\n      el.forEach((subEl, subElIndex) => {\n        if (params.type === 'fraction') {\n          subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n            fractionEl.textContent = params.formatFractionCurrent(current + 1);\n          });\n          subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n            totalEl.textContent = params.formatFractionTotal(total);\n          });\n        }\n        if (params.type === 'progressbar') {\n          let progressbarDirection;\n          if (params.progressbarOpposite) {\n            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n          } else {\n            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n          }\n          const scale = (current + 1) / total;\n          let scaleX = 1;\n          let scaleY = 1;\n          if (progressbarDirection === 'horizontal') {\n            scaleX = scale;\n          } else {\n            scaleY = scale;\n          }\n          subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n          });\n        }\n        if (params.type === 'custom' && params.renderCustom) {\n          subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n          if (subElIndex === 0) emit('paginationRender', subEl);\n        } else {\n          if (subElIndex === 0) emit('paginationRender', subEl);\n          emit('paginationUpdate', subEl);\n        }\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n        }\n      });\n    }\n    function render() {\n      // Render Container\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n      let el = swiper.pagination.el;\n      el = makeElementsArray(el);\n      let paginationHTML = '';\n      if (params.type === 'bullets') {\n        let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n          numberOfBullets = slidesLength;\n        }\n        for (let i = 0; i < numberOfBullets; i += 1) {\n          if (params.renderBullet) {\n            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n          } else {\n            // prettier-ignore\n            paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n          }\n        }\n      }\n      if (params.type === 'fraction') {\n        if (params.renderFraction) {\n          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n        } else {\n          paginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n        }\n      }\n      if (params.type === 'progressbar') {\n        if (params.renderProgressbar) {\n          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n        } else {\n          paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n        }\n      }\n      swiper.pagination.bullets = [];\n      el.forEach(subEl => {\n        if (params.type !== 'custom') {\n          subEl.innerHTML = paginationHTML || '';\n        }\n        if (params.type === 'bullets') {\n          swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n        }\n      });\n      if (params.type !== 'custom') {\n        emit('paginationRender', el[0]);\n      }\n    }\n    function init() {\n      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n        el: 'swiper-pagination'\n      });\n      const params = swiper.params.pagination;\n      if (!params.el) return;\n      let el;\n      if (typeof params.el === 'string' && swiper.isElement) {\n        el = swiper.el.querySelector(params.el);\n      }\n      if (!el && typeof params.el === 'string') {\n        el = [...document.querySelectorAll(params.el)];\n      }\n      if (!el) {\n        el = params.el;\n      }\n      if (!el || el.length === 0) return;\n      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n        el = [...swiper.el.querySelectorAll(params.el)];\n        // check if it belongs to another nested Swiper\n        if (el.length > 1) {\n          el = el.filter(subEl => {\n            if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n            return true;\n          })[0];\n        }\n      }\n      if (Array.isArray(el) && el.length === 1) el = el[0];\n      Object.assign(swiper.pagination, {\n        el\n      });\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        if (params.type === 'bullets' && params.clickable) {\n          subEl.classList.add(params.clickableClass);\n        }\n        subEl.classList.add(params.modifierClass + params.type);\n        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        if (params.type === 'bullets' && params.dynamicBullets) {\n          subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n          dynamicBulletIndex = 0;\n          if (params.dynamicMainBullets < 1) {\n            params.dynamicMainBullets = 1;\n          }\n        }\n        if (params.type === 'progressbar' && params.progressbarOpposite) {\n          subEl.classList.add(params.progressbarOppositeClass);\n        }\n        if (params.clickable) {\n          subEl.addEventListener('click', onBulletClick);\n        }\n        if (!swiper.enabled) {\n          subEl.classList.add(params.lockClass);\n        }\n      });\n    }\n    function destroy() {\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      let el = swiper.pagination.el;\n      if (el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.classList.remove(params.hiddenClass);\n          subEl.classList.remove(params.modifierClass + params.type);\n          subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n          if (params.clickable) {\n            subEl.removeEventListener('click', onBulletClick);\n          }\n        });\n      }\n      if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n    }\n    on('changeDirection', () => {\n      if (!swiper.pagination || !swiper.pagination.el) return;\n      const params = swiper.params.pagination;\n      let {\n        el\n      } = swiper.pagination;\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.classList.remove(params.horizontalClass, params.verticalClass);\n        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      });\n    });\n    on('init', () => {\n      if (swiper.params.pagination.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        render();\n        update();\n      }\n    });\n    on('activeIndexChange', () => {\n      if (typeof swiper.snapIndex === 'undefined') {\n        update();\n      }\n    });\n    on('snapIndexChange', () => {\n      update();\n    });\n    on('snapGridLengthChange', () => {\n      render();\n      update();\n    });\n    on('destroy', () => {\n      destroy();\n    });\n    on('enable disable', () => {\n      let {\n        el\n      } = swiper.pagination;\n      if (el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n      }\n    });\n    on('lock unlock', () => {\n      update();\n    });\n    on('click', (_s, e) => {\n      const targetEl = e.target;\n      const el = makeElementsArray(swiper.pagination.el);\n      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n        const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n        if (isHidden === true) {\n          emit('paginationShow');\n        } else {\n          emit('paginationHide');\n        }\n        el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n      }\n    });\n    const enable = () => {\n      swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n      let {\n        el\n      } = swiper.pagination;\n      if (el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n      }\n      init();\n      render();\n      update();\n    };\n    const disable = () => {\n      swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n      let {\n        el\n      } = swiper.pagination;\n      if (el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n      }\n      destroy();\n    };\n    Object.assign(swiper.pagination, {\n      enable,\n      disable,\n      render,\n      update,\n      init,\n      destroy\n    });\n  }\n\n  function Scrollbar(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const document = getDocument();\n    let isTouched = false;\n    let timeout = null;\n    let dragTimeout = null;\n    let dragStartPos;\n    let dragSize;\n    let trackSize;\n    let divider;\n    extendParams({\n      scrollbar: {\n        el: null,\n        dragSize: 'auto',\n        hide: false,\n        draggable: false,\n        snapOnRelease: true,\n        lockClass: 'swiper-scrollbar-lock',\n        dragClass: 'swiper-scrollbar-drag',\n        scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n        horizontalClass: `swiper-scrollbar-horizontal`,\n        verticalClass: `swiper-scrollbar-vertical`\n      }\n    });\n    swiper.scrollbar = {\n      el: null,\n      dragEl: null\n    };\n    function setTranslate() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      const {\n        scrollbar,\n        rtlTranslate: rtl\n      } = swiper;\n      const {\n        dragEl,\n        el\n      } = scrollbar;\n      const params = swiper.params.scrollbar;\n      const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n      let newSize = dragSize;\n      let newPos = (trackSize - dragSize) * progress;\n      if (rtl) {\n        newPos = -newPos;\n        if (newPos > 0) {\n          newSize = dragSize - newPos;\n          newPos = 0;\n        } else if (-newPos + dragSize > trackSize) {\n          newSize = trackSize + newPos;\n        }\n      } else if (newPos < 0) {\n        newSize = dragSize + newPos;\n        newPos = 0;\n      } else if (newPos + dragSize > trackSize) {\n        newSize = trackSize - newPos;\n      }\n      if (swiper.isHorizontal()) {\n        dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n        dragEl.style.width = `${newSize}px`;\n      } else {\n        dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n        dragEl.style.height = `${newSize}px`;\n      }\n      if (params.hide) {\n        clearTimeout(timeout);\n        el.style.opacity = 1;\n        timeout = setTimeout(() => {\n          el.style.opacity = 0;\n          el.style.transitionDuration = '400ms';\n        }, 1000);\n      }\n    }\n    function setTransition(duration) {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n    }\n    function updateSize() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      const {\n        scrollbar\n      } = swiper;\n      const {\n        dragEl,\n        el\n      } = scrollbar;\n      dragEl.style.width = '';\n      dragEl.style.height = '';\n      trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n      divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n      if (swiper.params.scrollbar.dragSize === 'auto') {\n        dragSize = trackSize * divider;\n      } else {\n        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n      }\n      if (swiper.isHorizontal()) {\n        dragEl.style.width = `${dragSize}px`;\n      } else {\n        dragEl.style.height = `${dragSize}px`;\n      }\n      if (divider >= 1) {\n        el.style.display = 'none';\n      } else {\n        el.style.display = '';\n      }\n      if (swiper.params.scrollbar.hide) {\n        el.style.opacity = 0;\n      }\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n      }\n    }\n    function getPointerPosition(e) {\n      return swiper.isHorizontal() ? e.clientX : e.clientY;\n    }\n    function setDragPosition(e) {\n      const {\n        scrollbar,\n        rtlTranslate: rtl\n      } = swiper;\n      const {\n        el\n      } = scrollbar;\n      let positionRatio;\n      positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n      positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n      if (rtl) {\n        positionRatio = 1 - positionRatio;\n      }\n      const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n      swiper.updateProgress(position);\n      swiper.setTranslate(position);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    function onDragStart(e) {\n      const params = swiper.params.scrollbar;\n      const {\n        scrollbar,\n        wrapperEl\n      } = swiper;\n      const {\n        el,\n        dragEl\n      } = scrollbar;\n      isTouched = true;\n      dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n      e.preventDefault();\n      e.stopPropagation();\n      wrapperEl.style.transitionDuration = '100ms';\n      dragEl.style.transitionDuration = '100ms';\n      setDragPosition(e);\n      clearTimeout(dragTimeout);\n      el.style.transitionDuration = '0ms';\n      if (params.hide) {\n        el.style.opacity = 1;\n      }\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n      }\n      emit('scrollbarDragStart', e);\n    }\n    function onDragMove(e) {\n      const {\n        scrollbar,\n        wrapperEl\n      } = swiper;\n      const {\n        el,\n        dragEl\n      } = scrollbar;\n      if (!isTouched) return;\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      setDragPosition(e);\n      wrapperEl.style.transitionDuration = '0ms';\n      el.style.transitionDuration = '0ms';\n      dragEl.style.transitionDuration = '0ms';\n      emit('scrollbarDragMove', e);\n    }\n    function onDragEnd(e) {\n      const params = swiper.params.scrollbar;\n      const {\n        scrollbar,\n        wrapperEl\n      } = swiper;\n      const {\n        el\n      } = scrollbar;\n      if (!isTouched) return;\n      isTouched = false;\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style['scroll-snap-type'] = '';\n        wrapperEl.style.transitionDuration = '';\n      }\n      if (params.hide) {\n        clearTimeout(dragTimeout);\n        dragTimeout = nextTick(() => {\n          el.style.opacity = 0;\n          el.style.transitionDuration = '400ms';\n        }, 1000);\n      }\n      emit('scrollbarDragEnd', e);\n      if (params.snapOnRelease) {\n        swiper.slideToClosest();\n      }\n    }\n    function events(method) {\n      const {\n        scrollbar,\n        params\n      } = swiper;\n      const el = scrollbar.el;\n      if (!el) return;\n      const target = el;\n      const activeListener = params.passiveListeners ? {\n        passive: false,\n        capture: false\n      } : false;\n      const passiveListener = params.passiveListeners ? {\n        passive: true,\n        capture: false\n      } : false;\n      if (!target) return;\n      const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n      target[eventMethod]('pointerdown', onDragStart, activeListener);\n      document[eventMethod]('pointermove', onDragMove, activeListener);\n      document[eventMethod]('pointerup', onDragEnd, passiveListener);\n    }\n    function enableDraggable() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      events('on');\n    }\n    function disableDraggable() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      events('off');\n    }\n    function init() {\n      const {\n        scrollbar,\n        el: swiperEl\n      } = swiper;\n      swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n        el: 'swiper-scrollbar'\n      });\n      const params = swiper.params.scrollbar;\n      if (!params.el) return;\n      let el;\n      if (typeof params.el === 'string' && swiper.isElement) {\n        el = swiper.el.querySelector(params.el);\n      }\n      if (!el && typeof params.el === 'string') {\n        el = document.querySelectorAll(params.el);\n      } else if (!el) {\n        el = params.el;\n      }\n      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n        el = swiperEl.querySelector(params.el);\n      }\n      if (el.length > 0) el = el[0];\n      el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      let dragEl;\n      if (el) {\n        dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n        if (!dragEl) {\n          dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n          el.append(dragEl);\n        }\n      }\n      Object.assign(scrollbar, {\n        el,\n        dragEl\n      });\n      if (params.draggable) {\n        enableDraggable();\n      }\n      if (el) {\n        el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n      }\n    }\n    function destroy() {\n      const params = swiper.params.scrollbar;\n      const el = swiper.scrollbar.el;\n      if (el) {\n        el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      }\n      disableDraggable();\n    }\n    on('init', () => {\n      if (swiper.params.scrollbar.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        updateSize();\n        setTranslate();\n      }\n    });\n    on('update resize observerUpdate lock unlock', () => {\n      updateSize();\n    });\n    on('setTranslate', () => {\n      setTranslate();\n    });\n    on('setTransition', (_s, duration) => {\n      setTransition(duration);\n    });\n    on('enable disable', () => {\n      const {\n        el\n      } = swiper.scrollbar;\n      if (el) {\n        el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n      }\n    });\n    on('destroy', () => {\n      destroy();\n    });\n    const enable = () => {\n      swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n      if (swiper.scrollbar.el) {\n        swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n      }\n      init();\n      updateSize();\n      setTranslate();\n    };\n    const disable = () => {\n      swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n      if (swiper.scrollbar.el) {\n        swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n      }\n      destroy();\n    };\n    Object.assign(swiper.scrollbar, {\n      enable,\n      disable,\n      updateSize,\n      setTranslate,\n      init,\n      destroy\n    });\n  }\n\n  function Parallax(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      parallax: {\n        enabled: false\n      }\n    });\n    const setTransform = (el, progress) => {\n      const {\n        rtl\n      } = swiper;\n      const rtlFactor = rtl ? -1 : 1;\n      const p = el.getAttribute('data-swiper-parallax') || '0';\n      let x = el.getAttribute('data-swiper-parallax-x');\n      let y = el.getAttribute('data-swiper-parallax-y');\n      const scale = el.getAttribute('data-swiper-parallax-scale');\n      const opacity = el.getAttribute('data-swiper-parallax-opacity');\n      const rotate = el.getAttribute('data-swiper-parallax-rotate');\n      if (x || y) {\n        x = x || '0';\n        y = y || '0';\n      } else if (swiper.isHorizontal()) {\n        x = p;\n        y = '0';\n      } else {\n        y = p;\n        x = '0';\n      }\n      if (x.indexOf('%') >= 0) {\n        x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n      } else {\n        x = `${x * progress * rtlFactor}px`;\n      }\n      if (y.indexOf('%') >= 0) {\n        y = `${parseInt(y, 10) * progress}%`;\n      } else {\n        y = `${y * progress}px`;\n      }\n      if (typeof opacity !== 'undefined' && opacity !== null) {\n        const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n        el.style.opacity = currentOpacity;\n      }\n      let transform = `translate3d(${x}, ${y}, 0px)`;\n      if (typeof scale !== 'undefined' && scale !== null) {\n        const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n        transform += ` scale(${currentScale})`;\n      }\n      if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n        const currentRotate = rotate * progress * -1;\n        transform += ` rotate(${currentRotate}deg)`;\n      }\n      el.style.transform = transform;\n    };\n    const setTranslate = () => {\n      const {\n        el,\n        slides,\n        progress,\n        snapGrid\n      } = swiper;\n      elementChildren(el, '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(subEl => {\n        setTransform(subEl, progress);\n      });\n      slides.forEach((slideEl, slideIndex) => {\n        let slideProgress = slideEl.progress;\n        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n        }\n        slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n        slideEl.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]').forEach(subEl => {\n          setTransform(subEl, slideProgress);\n        });\n      });\n    };\n    const setTransition = function (duration) {\n      if (duration === void 0) {\n        duration = swiper.params.speed;\n      }\n      const {\n        el\n      } = swiper;\n      el.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(parallaxEl => {\n        let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n        if (duration === 0) parallaxDuration = 0;\n        parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n      });\n    };\n    on('beforeInit', () => {\n      if (!swiper.params.parallax.enabled) return;\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    });\n    on('init', () => {\n      if (!swiper.params.parallax.enabled) return;\n      setTranslate();\n    });\n    on('setTranslate', () => {\n      if (!swiper.params.parallax.enabled) return;\n      setTranslate();\n    });\n    on('setTransition', (_swiper, duration) => {\n      if (!swiper.params.parallax.enabled) return;\n      setTransition(duration);\n    });\n  }\n\n  function Zoom(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const window = getWindow();\n    extendParams({\n      zoom: {\n        enabled: false,\n        maxRatio: 3,\n        minRatio: 1,\n        toggle: true,\n        containerClass: 'swiper-zoom-container',\n        zoomedSlideClass: 'swiper-slide-zoomed'\n      }\n    });\n    swiper.zoom = {\n      enabled: false\n    };\n    let currentScale = 1;\n    let isScaling = false;\n    let fakeGestureTouched;\n    let fakeGestureMoved;\n    const evCache = [];\n    const gesture = {\n      originX: 0,\n      originY: 0,\n      slideEl: undefined,\n      slideWidth: undefined,\n      slideHeight: undefined,\n      imageEl: undefined,\n      imageWrapEl: undefined,\n      maxRatio: 3\n    };\n    const image = {\n      isTouched: undefined,\n      isMoved: undefined,\n      currentX: undefined,\n      currentY: undefined,\n      minX: undefined,\n      minY: undefined,\n      maxX: undefined,\n      maxY: undefined,\n      width: undefined,\n      height: undefined,\n      startX: undefined,\n      startY: undefined,\n      touchesStart: {},\n      touchesCurrent: {}\n    };\n    const velocity = {\n      x: undefined,\n      y: undefined,\n      prevPositionX: undefined,\n      prevPositionY: undefined,\n      prevTime: undefined\n    };\n    let scale = 1;\n    Object.defineProperty(swiper.zoom, 'scale', {\n      get() {\n        return scale;\n      },\n      set(value) {\n        if (scale !== value) {\n          const imageEl = gesture.imageEl;\n          const slideEl = gesture.slideEl;\n          emit('zoomChange', value, imageEl, slideEl);\n        }\n        scale = value;\n      }\n    });\n    function getDistanceBetweenTouches() {\n      if (evCache.length < 2) return 1;\n      const x1 = evCache[0].pageX;\n      const y1 = evCache[0].pageY;\n      const x2 = evCache[1].pageX;\n      const y2 = evCache[1].pageY;\n      const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n      return distance;\n    }\n    function getScaleOrigin() {\n      if (evCache.length < 2) return {\n        x: null,\n        y: null\n      };\n      const box = gesture.imageEl.getBoundingClientRect();\n      return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale];\n    }\n    function getSlideSelector() {\n      return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n    }\n    function eventWithinSlide(e) {\n      const slideSelector = getSlideSelector();\n      if (e.target.matches(slideSelector)) return true;\n      if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n      return false;\n    }\n    function eventWithinZoomContainer(e) {\n      const selector = `.${swiper.params.zoom.containerClass}`;\n      if (e.target.matches(selector)) return true;\n      if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n      return false;\n    }\n\n    // Events\n    function onGestureStart(e) {\n      if (e.pointerType === 'mouse') {\n        evCache.splice(0, evCache.length);\n      }\n      if (!eventWithinSlide(e)) return;\n      const params = swiper.params.zoom;\n      fakeGestureTouched = false;\n      fakeGestureMoved = false;\n      evCache.push(e);\n      if (evCache.length < 2) {\n        return;\n      }\n      fakeGestureTouched = true;\n      gesture.scaleStart = getDistanceBetweenTouches();\n      if (!gesture.slideEl) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n        if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n        if (imageEl) {\n          imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n        }\n        gesture.imageEl = imageEl;\n        if (imageEl) {\n          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n        } else {\n          gesture.imageWrapEl = undefined;\n        }\n        if (!gesture.imageWrapEl) {\n          gesture.imageEl = undefined;\n          return;\n        }\n        gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n      }\n      if (gesture.imageEl) {\n        const [originX, originY] = getScaleOrigin();\n        gesture.originX = originX;\n        gesture.originY = originY;\n        gesture.imageEl.style.transitionDuration = '0ms';\n      }\n      isScaling = true;\n    }\n    function onGestureChange(e) {\n      if (!eventWithinSlide(e)) return;\n      const params = swiper.params.zoom;\n      const zoom = swiper.zoom;\n      const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n      if (pointerIndex >= 0) evCache[pointerIndex] = e;\n      if (evCache.length < 2) {\n        return;\n      }\n      fakeGestureMoved = true;\n      gesture.scaleMove = getDistanceBetweenTouches();\n      if (!gesture.imageEl) {\n        return;\n      }\n      zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n      if (zoom.scale > gesture.maxRatio) {\n        zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n      }\n      if (zoom.scale < params.minRatio) {\n        zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n      }\n      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    }\n    function onGestureEnd(e) {\n      if (!eventWithinSlide(e)) return;\n      if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n      const params = swiper.params.zoom;\n      const zoom = swiper.zoom;\n      const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n      if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n      if (!fakeGestureTouched || !fakeGestureMoved) {\n        return;\n      }\n      fakeGestureTouched = false;\n      fakeGestureMoved = false;\n      if (!gesture.imageEl) return;\n      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n      gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      currentScale = zoom.scale;\n      isScaling = false;\n      if (zoom.scale > 1 && gesture.slideEl) {\n        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n      } else if (zoom.scale <= 1 && gesture.slideEl) {\n        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n      }\n      if (zoom.scale === 1) {\n        gesture.originX = 0;\n        gesture.originY = 0;\n        gesture.slideEl = undefined;\n      }\n    }\n    function onTouchStart(e) {\n      const device = swiper.device;\n      if (!gesture.imageEl) return;\n      if (image.isTouched) return;\n      if (device.android && e.cancelable) e.preventDefault();\n      image.isTouched = true;\n      const event = evCache.length > 0 ? evCache[0] : e;\n      image.touchesStart.x = event.pageX;\n      image.touchesStart.y = event.pageY;\n    }\n    function onTouchMove(e) {\n      if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n      const zoom = swiper.zoom;\n      if (!gesture.imageEl) return;\n      if (!image.isTouched || !gesture.slideEl) return;\n      if (!image.isMoved) {\n        image.width = gesture.imageEl.offsetWidth;\n        image.height = gesture.imageEl.offsetHeight;\n        image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n        image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n        gesture.slideWidth = gesture.slideEl.offsetWidth;\n        gesture.slideHeight = gesture.slideEl.offsetHeight;\n        gesture.imageWrapEl.style.transitionDuration = '0ms';\n      }\n      // Define if we need image drag\n      const scaledWidth = image.width * zoom.scale;\n      const scaledHeight = image.height * zoom.scale;\n      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n      image.maxX = -image.minX;\n      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n      image.maxY = -image.minY;\n      image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n      image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n      const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n      if (touchesDiff > 5) {\n        swiper.allowClick = false;\n      }\n      if (!image.isMoved && !isScaling) {\n        if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n          image.isTouched = false;\n          return;\n        }\n        if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n          image.isTouched = false;\n          return;\n        }\n      }\n      if (e.cancelable) {\n        e.preventDefault();\n      }\n      e.stopPropagation();\n      image.isMoved = true;\n      const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n      const {\n        originX,\n        originY\n      } = gesture;\n      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n      if (image.currentX < image.minX) {\n        image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n      }\n      if (image.currentX > image.maxX) {\n        image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n      }\n      if (image.currentY < image.minY) {\n        image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n      }\n      if (image.currentY > image.maxY) {\n        image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n      }\n\n      // Velocity\n      if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n      if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n      if (!velocity.prevTime) velocity.prevTime = Date.now();\n      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n      velocity.prevPositionX = image.touchesCurrent.x;\n      velocity.prevPositionY = image.touchesCurrent.y;\n      velocity.prevTime = Date.now();\n      gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n    }\n    function onTouchEnd() {\n      const zoom = swiper.zoom;\n      if (!gesture.imageEl) return;\n      if (!image.isTouched || !image.isMoved) {\n        image.isTouched = false;\n        image.isMoved = false;\n        return;\n      }\n      image.isTouched = false;\n      image.isMoved = false;\n      let momentumDurationX = 300;\n      let momentumDurationY = 300;\n      const momentumDistanceX = velocity.x * momentumDurationX;\n      const newPositionX = image.currentX + momentumDistanceX;\n      const momentumDistanceY = velocity.y * momentumDurationY;\n      const newPositionY = image.currentY + momentumDistanceY;\n\n      // Fix duration\n      if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n      if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n      const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n      image.currentX = newPositionX;\n      image.currentY = newPositionY;\n      // Define if we need image drag\n      const scaledWidth = image.width * zoom.scale;\n      const scaledHeight = image.height * zoom.scale;\n      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n      image.maxX = -image.minX;\n      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n      image.maxY = -image.minY;\n      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n      gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n      gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n    }\n    function onTransitionEnd() {\n      const zoom = swiper.zoom;\n      if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n        if (gesture.imageEl) {\n          gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n        }\n        if (gesture.imageWrapEl) {\n          gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n        }\n        gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n        zoom.scale = 1;\n        currentScale = 1;\n        gesture.slideEl = undefined;\n        gesture.imageEl = undefined;\n        gesture.imageWrapEl = undefined;\n        gesture.originX = 0;\n        gesture.originY = 0;\n      }\n    }\n    function zoomIn(e) {\n      const zoom = swiper.zoom;\n      const params = swiper.params.zoom;\n      if (!gesture.slideEl) {\n        if (e && e.target) {\n          gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n        }\n        if (!gesture.slideEl) {\n          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n            gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n          } else {\n            gesture.slideEl = swiper.slides[swiper.activeIndex];\n          }\n        }\n        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n        if (imageEl) {\n          imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n        }\n        gesture.imageEl = imageEl;\n        if (imageEl) {\n          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n        } else {\n          gesture.imageWrapEl = undefined;\n        }\n      }\n      if (!gesture.imageEl || !gesture.imageWrapEl) return;\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style.overflow = 'hidden';\n        swiper.wrapperEl.style.touchAction = 'none';\n      }\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n      let touchX;\n      let touchY;\n      let offsetX;\n      let offsetY;\n      let diffX;\n      let diffY;\n      let translateX;\n      let translateY;\n      let imageWidth;\n      let imageHeight;\n      let scaledWidth;\n      let scaledHeight;\n      let translateMinX;\n      let translateMinY;\n      let translateMaxX;\n      let translateMaxY;\n      let slideWidth;\n      let slideHeight;\n      if (typeof image.touchesStart.x === 'undefined' && e) {\n        touchX = e.pageX;\n        touchY = e.pageY;\n      } else {\n        touchX = image.touchesStart.x;\n        touchY = image.touchesStart.y;\n      }\n      const forceZoomRatio = typeof e === 'number' ? e : null;\n      if (currentScale === 1 && forceZoomRatio) {\n        touchX = undefined;\n        touchY = undefined;\n      }\n      zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n      currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n      if (e && !(currentScale === 1 && forceZoomRatio)) {\n        slideWidth = gesture.slideEl.offsetWidth;\n        slideHeight = gesture.slideEl.offsetHeight;\n        offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n        offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n        diffX = offsetX + slideWidth / 2 - touchX;\n        diffY = offsetY + slideHeight / 2 - touchY;\n        imageWidth = gesture.imageEl.offsetWidth;\n        imageHeight = gesture.imageEl.offsetHeight;\n        scaledWidth = imageWidth * zoom.scale;\n        scaledHeight = imageHeight * zoom.scale;\n        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n        translateMaxX = -translateMinX;\n        translateMaxY = -translateMinY;\n        translateX = diffX * zoom.scale;\n        translateY = diffY * zoom.scale;\n        if (translateX < translateMinX) {\n          translateX = translateMinX;\n        }\n        if (translateX > translateMaxX) {\n          translateX = translateMaxX;\n        }\n        if (translateY < translateMinY) {\n          translateY = translateMinY;\n        }\n        if (translateY > translateMaxY) {\n          translateY = translateMaxY;\n        }\n      } else {\n        translateX = 0;\n        translateY = 0;\n      }\n      if (forceZoomRatio && zoom.scale === 1) {\n        gesture.originX = 0;\n        gesture.originY = 0;\n      }\n      gesture.imageWrapEl.style.transitionDuration = '300ms';\n      gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n      gesture.imageEl.style.transitionDuration = '300ms';\n      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    }\n    function zoomOut() {\n      const zoom = swiper.zoom;\n      const params = swiper.params.zoom;\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n        if (imageEl) {\n          imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n        }\n        gesture.imageEl = imageEl;\n        if (imageEl) {\n          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n        } else {\n          gesture.imageWrapEl = undefined;\n        }\n      }\n      if (!gesture.imageEl || !gesture.imageWrapEl) return;\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.style.touchAction = '';\n      }\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.imageWrapEl.style.transitionDuration = '300ms';\n      gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n      gesture.imageEl.style.transitionDuration = '300ms';\n      gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n      gesture.slideEl = undefined;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n\n    // Toggle Zoom\n    function zoomToggle(e) {\n      const zoom = swiper.zoom;\n      if (zoom.scale && zoom.scale !== 1) {\n        // Zoom Out\n        zoomOut();\n      } else {\n        // Zoom In\n        zoomIn(e);\n      }\n    }\n    function getListeners() {\n      const passiveListener = swiper.params.passiveListeners ? {\n        passive: true,\n        capture: false\n      } : false;\n      const activeListenerWithCapture = swiper.params.passiveListeners ? {\n        passive: false,\n        capture: true\n      } : true;\n      return {\n        passiveListener,\n        activeListenerWithCapture\n      };\n    }\n\n    // Attach/Detach Events\n    function enable() {\n      const zoom = swiper.zoom;\n      if (zoom.enabled) return;\n      zoom.enabled = true;\n      const {\n        passiveListener,\n        activeListenerWithCapture\n      } = getListeners();\n\n      // Scale image\n      swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n      swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n      ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n        swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n      });\n\n      // Move image\n      swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n    }\n    function disable() {\n      const zoom = swiper.zoom;\n      if (!zoom.enabled) return;\n      zoom.enabled = false;\n      const {\n        passiveListener,\n        activeListenerWithCapture\n      } = getListeners();\n\n      // Scale image\n      swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n      swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n      ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n        swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n      });\n\n      // Move image\n      swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n    }\n    on('init', () => {\n      if (swiper.params.zoom.enabled) {\n        enable();\n      }\n    });\n    on('destroy', () => {\n      disable();\n    });\n    on('touchStart', (_s, e) => {\n      if (!swiper.zoom.enabled) return;\n      onTouchStart(e);\n    });\n    on('touchEnd', (_s, e) => {\n      if (!swiper.zoom.enabled) return;\n      onTouchEnd();\n    });\n    on('doubleTap', (_s, e) => {\n      if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n        zoomToggle(e);\n      }\n    });\n    on('transitionEnd', () => {\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n        onTransitionEnd();\n      }\n    });\n    on('slideChange', () => {\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n        onTransitionEnd();\n      }\n    });\n    Object.assign(swiper.zoom, {\n      enable,\n      disable,\n      in: zoomIn,\n      out: zoomOut,\n      toggle: zoomToggle\n    });\n  }\n\n  /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n  function Controller(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      controller: {\n        control: undefined,\n        inverse: false,\n        by: 'slide' // or 'container'\n      }\n    });\n\n    swiper.controller = {\n      control: undefined\n    };\n    function LinearSpline(x, y) {\n      const binarySearch = function search() {\n        let maxIndex;\n        let minIndex;\n        let guess;\n        return (array, val) => {\n          minIndex = -1;\n          maxIndex = array.length;\n          while (maxIndex - minIndex > 1) {\n            guess = maxIndex + minIndex >> 1;\n            if (array[guess] <= val) {\n              minIndex = guess;\n            } else {\n              maxIndex = guess;\n            }\n          }\n          return maxIndex;\n        };\n      }();\n      this.x = x;\n      this.y = y;\n      this.lastIndex = x.length - 1;\n      // Given an x value (x2), return the expected y2 value:\n      // (x1,y1) is the known point before given value,\n      // (x3,y3) is the known point after given value.\n      let i1;\n      let i3;\n      this.interpolate = function interpolate(x2) {\n        if (!x2) return 0;\n\n        // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n        i3 = binarySearch(this.x, x2);\n        i1 = i3 - 1;\n\n        // We have our indexes i1 & i3, so we can calculate already:\n        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n      };\n      return this;\n    }\n    function getInterpolateFunction(c) {\n      swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n    }\n    function setTranslate(_t, byController) {\n      const controlled = swiper.controller.control;\n      let multiplier;\n      let controlledTranslate;\n      const Swiper = swiper.constructor;\n      function setControlledTranslate(c) {\n        if (c.destroyed) return;\n\n        // this will create an Interpolate function based on the snapGrids\n        // x is the Grid of the scrolled scroller and y will be the controlled scroller\n        // it makes sense to create this only once and recall it for the interpolation\n        // the function does a lot of value caching for performance\n        const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n        if (swiper.params.controller.by === 'slide') {\n          getInterpolateFunction(c);\n          // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n          // but it did not work out\n          controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n        }\n        if (!controlledTranslate || swiper.params.controller.by === 'container') {\n          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n          if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n            multiplier = 1;\n          }\n          controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n        }\n        if (swiper.params.controller.inverse) {\n          controlledTranslate = c.maxTranslate() - controlledTranslate;\n        }\n        c.updateProgress(controlledTranslate);\n        c.setTranslate(controlledTranslate, swiper);\n        c.updateActiveIndex();\n        c.updateSlidesClasses();\n      }\n      if (Array.isArray(controlled)) {\n        for (let i = 0; i < controlled.length; i += 1) {\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n            setControlledTranslate(controlled[i]);\n          }\n        }\n      } else if (controlled instanceof Swiper && byController !== controlled) {\n        setControlledTranslate(controlled);\n      }\n    }\n    function setTransition(duration, byController) {\n      const Swiper = swiper.constructor;\n      const controlled = swiper.controller.control;\n      let i;\n      function setControlledTransition(c) {\n        if (c.destroyed) return;\n        c.setTransition(duration, swiper);\n        if (duration !== 0) {\n          c.transitionStart();\n          if (c.params.autoHeight) {\n            nextTick(() => {\n              c.updateAutoHeight();\n            });\n          }\n          elementTransitionEnd(c.wrapperEl, () => {\n            if (!controlled) return;\n            c.transitionEnd();\n          });\n        }\n      }\n      if (Array.isArray(controlled)) {\n        for (i = 0; i < controlled.length; i += 1) {\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n            setControlledTransition(controlled[i]);\n          }\n        }\n      } else if (controlled instanceof Swiper && byController !== controlled) {\n        setControlledTransition(controlled);\n      }\n    }\n    function removeSpline() {\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    }\n    on('beforeInit', () => {\n      if (typeof window !== 'undefined' && (\n      // eslint-disable-line\n      typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n        const controlElement = document.querySelector(swiper.params.controller.control);\n        if (controlElement && controlElement.swiper) {\n          swiper.controller.control = controlElement.swiper;\n        } else if (controlElement) {\n          const onControllerSwiper = e => {\n            swiper.controller.control = e.detail[0];\n            swiper.update();\n            controlElement.removeEventListener('init', onControllerSwiper);\n          };\n          controlElement.addEventListener('init', onControllerSwiper);\n        }\n        return;\n      }\n      swiper.controller.control = swiper.params.controller.control;\n    });\n    on('update', () => {\n      removeSpline();\n    });\n    on('resize', () => {\n      removeSpline();\n    });\n    on('observerUpdate', () => {\n      removeSpline();\n    });\n    on('setTranslate', (_s, translate, byController) => {\n      if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n      swiper.controller.setTranslate(translate, byController);\n    });\n    on('setTransition', (_s, duration, byController) => {\n      if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n      swiper.controller.setTransition(duration, byController);\n    });\n    Object.assign(swiper.controller, {\n      setTranslate,\n      setTransition\n    });\n  }\n\n  function A11y(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      a11y: {\n        enabled: true,\n        notificationClass: 'swiper-notification',\n        prevSlideMessage: 'Previous slide',\n        nextSlideMessage: 'Next slide',\n        firstSlideMessage: 'This is the first slide',\n        lastSlideMessage: 'This is the last slide',\n        paginationBulletMessage: 'Go to slide {{index}}',\n        slideLabelMessage: '{{index}} / {{slidesLength}}',\n        containerMessage: null,\n        containerRoleDescriptionMessage: null,\n        itemRoleDescriptionMessage: null,\n        slideRole: 'group',\n        id: null\n      }\n    });\n    swiper.a11y = {\n      clicked: false\n    };\n    let liveRegion = null;\n    function notify(message) {\n      const notification = liveRegion;\n      if (notification.length === 0) return;\n      notification.innerHTML = '';\n      notification.innerHTML = message;\n    }\n    const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);\n    function getRandomNumber(size) {\n      if (size === void 0) {\n        size = 16;\n      }\n      const randomChar = () => Math.round(16 * Math.random()).toString(16);\n      return 'x'.repeat(size).replace(/x/g, randomChar);\n    }\n    function makeElFocusable(el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('tabIndex', '0');\n      });\n    }\n    function makeElNotFocusable(el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('tabIndex', '-1');\n      });\n    }\n    function addElRole(el, role) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('role', role);\n      });\n    }\n    function addElRoleDescription(el, description) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-roledescription', description);\n      });\n    }\n    function addElControls(el, controls) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-controls', controls);\n      });\n    }\n    function addElLabel(el, label) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-label', label);\n      });\n    }\n    function addElId(el, id) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('id', id);\n      });\n    }\n    function addElLive(el, live) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-live', live);\n      });\n    }\n    function disableEl(el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-disabled', true);\n      });\n    }\n    function enableEl(el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-disabled', false);\n      });\n    }\n    function onEnterOrSpaceKey(e) {\n      if (e.keyCode !== 13 && e.keyCode !== 32) return;\n      const params = swiper.params.a11y;\n      const targetEl = e.target;\n      if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n        if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n      }\n      if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n        if (!(swiper.isEnd && !swiper.params.loop)) {\n          swiper.slideNext();\n        }\n        if (swiper.isEnd) {\n          notify(params.lastSlideMessage);\n        } else {\n          notify(params.nextSlideMessage);\n        }\n      }\n      if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n        if (!(swiper.isBeginning && !swiper.params.loop)) {\n          swiper.slidePrev();\n        }\n        if (swiper.isBeginning) {\n          notify(params.firstSlideMessage);\n        } else {\n          notify(params.prevSlideMessage);\n        }\n      }\n      if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n        targetEl.click();\n      }\n    }\n    function updateNavigation() {\n      if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n      const {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      if (prevEl) {\n        if (swiper.isBeginning) {\n          disableEl(prevEl);\n          makeElNotFocusable(prevEl);\n        } else {\n          enableEl(prevEl);\n          makeElFocusable(prevEl);\n        }\n      }\n      if (nextEl) {\n        if (swiper.isEnd) {\n          disableEl(nextEl);\n          makeElNotFocusable(nextEl);\n        } else {\n          enableEl(nextEl);\n          makeElFocusable(nextEl);\n        }\n      }\n    }\n    function hasPagination() {\n      return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n    }\n    function hasClickablePagination() {\n      return hasPagination() && swiper.params.pagination.clickable;\n    }\n    function updatePagination() {\n      const params = swiper.params.a11y;\n      if (!hasPagination()) return;\n      swiper.pagination.bullets.forEach(bulletEl => {\n        if (swiper.params.pagination.clickable) {\n          makeElFocusable(bulletEl);\n          if (!swiper.params.pagination.renderBullet) {\n            addElRole(bulletEl, 'button');\n            addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n          }\n        }\n        if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n          bulletEl.setAttribute('aria-current', 'true');\n        } else {\n          bulletEl.removeAttribute('aria-current');\n        }\n      });\n    }\n    const initNavEl = (el, wrapperId, message) => {\n      makeElFocusable(el);\n      if (el.tagName !== 'BUTTON') {\n        addElRole(el, 'button');\n        el.addEventListener('keydown', onEnterOrSpaceKey);\n      }\n      addElLabel(el, message);\n      addElControls(el, wrapperId);\n    };\n    const handlePointerDown = () => {\n      swiper.a11y.clicked = true;\n    };\n    const handlePointerUp = () => {\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          if (!swiper.destroyed) {\n            swiper.a11y.clicked = false;\n          }\n        });\n      });\n    };\n    const handleFocus = e => {\n      if (swiper.a11y.clicked) return;\n      const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!slideEl || !swiper.slides.includes(slideEl)) return;\n      const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n      const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n      if (isActive || isVisible) return;\n      if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n      if (swiper.isHorizontal()) {\n        swiper.el.scrollLeft = 0;\n      } else {\n        swiper.el.scrollTop = 0;\n      }\n      swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n    };\n    const initSlides = () => {\n      const params = swiper.params.a11y;\n      if (params.itemRoleDescriptionMessage) {\n        addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n      }\n      if (params.slideRole) {\n        addElRole(swiper.slides, params.slideRole);\n      }\n      const slidesLength = swiper.slides.length;\n      if (params.slideLabelMessage) {\n        swiper.slides.forEach((slideEl, index) => {\n          const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n          const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n          addElLabel(slideEl, ariaLabelMessage);\n        });\n      }\n    };\n    const init = () => {\n      const params = swiper.params.a11y;\n      swiper.el.append(liveRegion);\n\n      // Container\n      const containerEl = swiper.el;\n      if (params.containerRoleDescriptionMessage) {\n        addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n      }\n      if (params.containerMessage) {\n        addElLabel(containerEl, params.containerMessage);\n      }\n\n      // Wrapper\n      const wrapperEl = swiper.wrapperEl;\n      const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n      const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n      addElId(wrapperEl, wrapperId);\n      addElLive(wrapperEl, live);\n\n      // Slide\n      initSlides();\n\n      // Navigation\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation ? swiper.navigation : {};\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      if (nextEl) {\n        nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n      }\n      if (prevEl) {\n        prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n      }\n\n      // Pagination\n      if (hasClickablePagination()) {\n        const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n        paginationEl.forEach(el => {\n          el.addEventListener('keydown', onEnterOrSpaceKey);\n        });\n      }\n\n      // Tab focus\n      swiper.el.addEventListener('focus', handleFocus, true);\n      swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n      swiper.el.addEventListener('pointerup', handlePointerUp, true);\n    };\n    function destroy() {\n      if (liveRegion) liveRegion.remove();\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation ? swiper.navigation : {};\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      if (nextEl) {\n        nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n      }\n      if (prevEl) {\n        prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n      }\n\n      // Pagination\n      if (hasClickablePagination()) {\n        const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n        paginationEl.forEach(el => {\n          el.removeEventListener('keydown', onEnterOrSpaceKey);\n        });\n      }\n\n      // Tab focus\n      swiper.el.removeEventListener('focus', handleFocus, true);\n      swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n      swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n    }\n    on('beforeInit', () => {\n      liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n      liveRegion.setAttribute('aria-live', 'assertive');\n      liveRegion.setAttribute('aria-atomic', 'true');\n    });\n    on('afterInit', () => {\n      if (!swiper.params.a11y.enabled) return;\n      init();\n    });\n    on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n      if (!swiper.params.a11y.enabled) return;\n      initSlides();\n    });\n    on('fromEdge toEdge afterInit lock unlock', () => {\n      if (!swiper.params.a11y.enabled) return;\n      updateNavigation();\n    });\n    on('paginationUpdate', () => {\n      if (!swiper.params.a11y.enabled) return;\n      updatePagination();\n    });\n    on('destroy', () => {\n      if (!swiper.params.a11y.enabled) return;\n      destroy();\n    });\n  }\n\n  function History(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      history: {\n        enabled: false,\n        root: '',\n        replaceState: false,\n        key: 'slides',\n        keepQuery: false\n      }\n    });\n    let initialized = false;\n    let paths = {};\n    const slugify = text => {\n      return text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n    };\n    const getPathValues = urlOverride => {\n      const window = getWindow();\n      let location;\n      if (urlOverride) {\n        location = new URL(urlOverride);\n      } else {\n        location = window.location;\n      }\n      const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n      const total = pathArray.length;\n      const key = pathArray[total - 2];\n      const value = pathArray[total - 1];\n      return {\n        key,\n        value\n      };\n    };\n    const setHistory = (key, index) => {\n      const window = getWindow();\n      if (!initialized || !swiper.params.history.enabled) return;\n      let location;\n      if (swiper.params.url) {\n        location = new URL(swiper.params.url);\n      } else {\n        location = window.location;\n      }\n      const slide = swiper.slides[index];\n      let value = slugify(slide.getAttribute('data-history'));\n      if (swiper.params.history.root.length > 0) {\n        let root = swiper.params.history.root;\n        if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n        value = `${root}/${key ? `${key}/` : ''}${value}`;\n      } else if (!location.pathname.includes(key)) {\n        value = `${key ? `${key}/` : ''}${value}`;\n      }\n      if (swiper.params.history.keepQuery) {\n        value += location.search;\n      }\n      const currentState = window.history.state;\n      if (currentState && currentState.value === value) {\n        return;\n      }\n      if (swiper.params.history.replaceState) {\n        window.history.replaceState({\n          value\n        }, null, value);\n      } else {\n        window.history.pushState({\n          value\n        }, null, value);\n      }\n    };\n    const scrollToSlide = (speed, value, runCallbacks) => {\n      if (value) {\n        for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n          const slide = swiper.slides[i];\n          const slideHistory = slugify(slide.getAttribute('data-history'));\n          if (slideHistory === value) {\n            const index = swiper.getSlideIndex(slide);\n            swiper.slideTo(index, speed, runCallbacks);\n          }\n        }\n      } else {\n        swiper.slideTo(0, speed, runCallbacks);\n      }\n    };\n    const setHistoryPopState = () => {\n      paths = getPathValues(swiper.params.url);\n      scrollToSlide(swiper.params.speed, paths.value, false);\n    };\n    const init = () => {\n      const window = getWindow();\n      if (!swiper.params.history) return;\n      if (!window.history || !window.history.pushState) {\n        swiper.params.history.enabled = false;\n        swiper.params.hashNavigation.enabled = true;\n        return;\n      }\n      initialized = true;\n      paths = getPathValues(swiper.params.url);\n      if (!paths.key && !paths.value) {\n        if (!swiper.params.history.replaceState) {\n          window.addEventListener('popstate', setHistoryPopState);\n        }\n        return;\n      }\n      scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n      if (!swiper.params.history.replaceState) {\n        window.addEventListener('popstate', setHistoryPopState);\n      }\n    };\n    const destroy = () => {\n      const window = getWindow();\n      if (!swiper.params.history.replaceState) {\n        window.removeEventListener('popstate', setHistoryPopState);\n      }\n    };\n    on('init', () => {\n      if (swiper.params.history.enabled) {\n        init();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.params.history.enabled) {\n        destroy();\n      }\n    });\n    on('transitionEnd _freeModeNoMomentumRelease', () => {\n      if (initialized) {\n        setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    });\n    on('slideChange', () => {\n      if (initialized && swiper.params.cssMode) {\n        setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    });\n  }\n\n  function HashNavigation(_ref) {\n    let {\n      swiper,\n      extendParams,\n      emit,\n      on\n    } = _ref;\n    let initialized = false;\n    const document = getDocument();\n    const window = getWindow();\n    extendParams({\n      hashNavigation: {\n        enabled: false,\n        replaceState: false,\n        watchState: false,\n        getSlideIndex(_s, hash) {\n          if (swiper.virtual && swiper.params.virtual.enabled) {\n            const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];\n            if (!slideWithHash) return 0;\n            const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n            return index;\n          }\n          return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n        }\n      }\n    });\n    const onHashChange = () => {\n      emit('hashChange');\n      const newHash = document.location.hash.replace('#', '');\n      const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n      const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n      if (newHash !== activeSlideHash) {\n        const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n        if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n        swiper.slideTo(newIndex);\n      }\n    };\n    const setHash = () => {\n      if (!initialized || !swiper.params.hashNavigation.enabled) return;\n      const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n      const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n      if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n        window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n        emit('hashSet');\n      } else {\n        document.location.hash = activeSlideHash || '';\n        emit('hashSet');\n      }\n    };\n    const init = () => {\n      if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n      initialized = true;\n      const hash = document.location.hash.replace('#', '');\n      if (hash) {\n        const speed = 0;\n        const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n        swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n      }\n      if (swiper.params.hashNavigation.watchState) {\n        window.addEventListener('hashchange', onHashChange);\n      }\n    };\n    const destroy = () => {\n      if (swiper.params.hashNavigation.watchState) {\n        window.removeEventListener('hashchange', onHashChange);\n      }\n    };\n    on('init', () => {\n      if (swiper.params.hashNavigation.enabled) {\n        init();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.params.hashNavigation.enabled) {\n        destroy();\n      }\n    });\n    on('transitionEnd _freeModeNoMomentumRelease', () => {\n      if (initialized) {\n        setHash();\n      }\n    });\n    on('slideChange', () => {\n      if (initialized && swiper.params.cssMode) {\n        setHash();\n      }\n    });\n  }\n\n  /* eslint no-underscore-dangle: \"off\" */\n  /* eslint no-use-before-define: \"off\" */\n  function Autoplay(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit,\n      params\n    } = _ref;\n    swiper.autoplay = {\n      running: false,\n      paused: false,\n      timeLeft: 0\n    };\n    extendParams({\n      autoplay: {\n        enabled: false,\n        delay: 3000,\n        waitForTransition: true,\n        disableOnInteraction: true,\n        stopOnLastSlide: false,\n        reverseDirection: false,\n        pauseOnMouseEnter: false\n      }\n    });\n    let timeout;\n    let raf;\n    let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n    let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n    let autoplayTimeLeft;\n    let autoplayStartTime = new Date().getTime;\n    let wasPaused;\n    let isTouched;\n    let pausedByTouch;\n    let touchStartTimeout;\n    let slideChanged;\n    let pausedByInteraction;\n    function onTransitionEnd(e) {\n      if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n      if (e.target !== swiper.wrapperEl) return;\n      swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n      resume();\n    }\n    const calcTimeLeft = () => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      if (swiper.autoplay.paused) {\n        wasPaused = true;\n      } else if (wasPaused) {\n        autoplayDelayCurrent = autoplayTimeLeft;\n        wasPaused = false;\n      }\n      const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n      swiper.autoplay.timeLeft = timeLeft;\n      emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n      raf = requestAnimationFrame(() => {\n        calcTimeLeft();\n      });\n    };\n    const getSlideDelay = () => {\n      let activeSlideEl;\n      if (swiper.virtual && swiper.params.virtual.enabled) {\n        activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n      } else {\n        activeSlideEl = swiper.slides[swiper.activeIndex];\n      }\n      if (!activeSlideEl) return undefined;\n      const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n      return currentSlideDelay;\n    };\n    const run = delayForce => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      cancelAnimationFrame(raf);\n      calcTimeLeft();\n      let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n      autoplayDelayTotal = swiper.params.autoplay.delay;\n      autoplayDelayCurrent = swiper.params.autoplay.delay;\n      const currentSlideDelay = getSlideDelay();\n      if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n        delay = currentSlideDelay;\n        autoplayDelayTotal = currentSlideDelay;\n        autoplayDelayCurrent = currentSlideDelay;\n      }\n      autoplayTimeLeft = delay;\n      const speed = swiper.params.speed;\n      const proceed = () => {\n        if (!swiper || swiper.destroyed) return;\n        if (swiper.params.autoplay.reverseDirection) {\n          if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n            swiper.slidePrev(speed, true, true);\n            emit('autoplay');\n          } else if (!swiper.params.autoplay.stopOnLastSlide) {\n            swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n            emit('autoplay');\n          }\n        } else {\n          if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n            swiper.slideNext(speed, true, true);\n            emit('autoplay');\n          } else if (!swiper.params.autoplay.stopOnLastSlide) {\n            swiper.slideTo(0, speed, true, true);\n            emit('autoplay');\n          }\n        }\n        if (swiper.params.cssMode) {\n          autoplayStartTime = new Date().getTime();\n          requestAnimationFrame(() => {\n            run();\n          });\n        }\n      };\n      if (delay > 0) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => {\n          proceed();\n        }, delay);\n      } else {\n        requestAnimationFrame(() => {\n          proceed();\n        });\n      }\n\n      // eslint-disable-next-line\n      return delay;\n    };\n    const start = () => {\n      swiper.autoplay.running = true;\n      run();\n      emit('autoplayStart');\n    };\n    const stop = () => {\n      swiper.autoplay.running = false;\n      clearTimeout(timeout);\n      cancelAnimationFrame(raf);\n      emit('autoplayStop');\n    };\n    const pause = (internal, reset) => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      clearTimeout(timeout);\n      if (!internal) {\n        pausedByInteraction = true;\n      }\n      const proceed = () => {\n        emit('autoplayPause');\n        if (swiper.params.autoplay.waitForTransition) {\n          swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n        } else {\n          resume();\n        }\n      };\n      swiper.autoplay.paused = true;\n      if (reset) {\n        if (slideChanged) {\n          autoplayTimeLeft = swiper.params.autoplay.delay;\n        }\n        slideChanged = false;\n        proceed();\n        return;\n      }\n      const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n      autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n      if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n      proceed();\n    };\n    const resume = () => {\n      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n      autoplayStartTime = new Date().getTime();\n      if (pausedByInteraction) {\n        pausedByInteraction = false;\n        run(autoplayTimeLeft);\n      } else {\n        run();\n      }\n      swiper.autoplay.paused = false;\n      emit('autoplayResume');\n    };\n    const onVisibilityChange = () => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      const document = getDocument();\n      if (document.visibilityState === 'hidden') {\n        pausedByInteraction = true;\n        pause(true);\n      }\n      if (document.visibilityState === 'visible') {\n        resume();\n      }\n    };\n    const onPointerEnter = e => {\n      if (e.pointerType !== 'mouse') return;\n      pausedByInteraction = true;\n      pause(true);\n    };\n    const onPointerLeave = e => {\n      if (e.pointerType !== 'mouse') return;\n      if (swiper.autoplay.paused) {\n        resume();\n      }\n    };\n    const attachMouseEvents = () => {\n      if (swiper.params.autoplay.pauseOnMouseEnter) {\n        swiper.el.addEventListener('pointerenter', onPointerEnter);\n        swiper.el.addEventListener('pointerleave', onPointerLeave);\n      }\n    };\n    const detachMouseEvents = () => {\n      swiper.el.removeEventListener('pointerenter', onPointerEnter);\n      swiper.el.removeEventListener('pointerleave', onPointerLeave);\n    };\n    const attachDocumentEvents = () => {\n      const document = getDocument();\n      document.addEventListener('visibilitychange', onVisibilityChange);\n    };\n    const detachDocumentEvents = () => {\n      const document = getDocument();\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n    };\n    on('init', () => {\n      if (swiper.params.autoplay.enabled) {\n        attachMouseEvents();\n        attachDocumentEvents();\n        autoplayStartTime = new Date().getTime();\n        start();\n      }\n    });\n    on('destroy', () => {\n      detachMouseEvents();\n      detachDocumentEvents();\n      if (swiper.autoplay.running) {\n        stop();\n      }\n    });\n    on('beforeTransitionStart', (_s, speed, internal) => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      if (internal || !swiper.params.autoplay.disableOnInteraction) {\n        pause(true, true);\n      } else {\n        stop();\n      }\n    });\n    on('sliderFirstMove', () => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      if (swiper.params.autoplay.disableOnInteraction) {\n        stop();\n        return;\n      }\n      isTouched = true;\n      pausedByTouch = false;\n      pausedByInteraction = false;\n      touchStartTimeout = setTimeout(() => {\n        pausedByInteraction = true;\n        pausedByTouch = true;\n        pause(true);\n      }, 200);\n    });\n    on('touchEnd', () => {\n      if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n      clearTimeout(touchStartTimeout);\n      clearTimeout(timeout);\n      if (swiper.params.autoplay.disableOnInteraction) {\n        pausedByTouch = false;\n        isTouched = false;\n        return;\n      }\n      if (pausedByTouch && swiper.params.cssMode) resume();\n      pausedByTouch = false;\n      isTouched = false;\n    });\n    on('slideChange', () => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      slideChanged = true;\n    });\n    Object.assign(swiper.autoplay, {\n      start,\n      stop,\n      pause,\n      resume\n    });\n  }\n\n  function Thumb(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      thumbs: {\n        swiper: null,\n        multipleActiveThumbs: true,\n        autoScrollOffset: 0,\n        slideThumbActiveClass: 'swiper-slide-thumb-active',\n        thumbsContainerClass: 'swiper-thumbs'\n      }\n    });\n    let initialized = false;\n    let swiperCreated = false;\n    swiper.thumbs = {\n      swiper: null\n    };\n    function onThumbClick() {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      const clickedIndex = thumbsSwiper.clickedIndex;\n      const clickedSlide = thumbsSwiper.clickedSlide;\n      if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n      if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n      let slideToIndex;\n      if (thumbsSwiper.params.loop) {\n        slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n      } else {\n        slideToIndex = clickedIndex;\n      }\n      if (swiper.params.loop) {\n        swiper.slideToLoop(slideToIndex);\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    }\n    function init() {\n      const {\n        thumbs: thumbsParams\n      } = swiper.params;\n      if (initialized) return false;\n      initialized = true;\n      const SwiperClass = swiper.constructor;\n      if (thumbsParams.swiper instanceof SwiperClass) {\n        swiper.thumbs.swiper = thumbsParams.swiper;\n        Object.assign(swiper.thumbs.swiper.originalParams, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false\n        });\n        Object.assign(swiper.thumbs.swiper.params, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false\n        });\n        swiper.thumbs.swiper.update();\n      } else if (isObject(thumbsParams.swiper)) {\n        const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n        Object.assign(thumbsSwiperParams, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false\n        });\n        swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n        swiperCreated = true;\n      }\n      swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n      swiper.thumbs.swiper.on('tap', onThumbClick);\n      return true;\n    }\n    function update(initial) {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n\n      // Activate thumbs\n      let thumbsToActivate = 1;\n      const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n        thumbsToActivate = swiper.params.slidesPerView;\n      }\n      if (!swiper.params.thumbs.multipleActiveThumbs) {\n        thumbsToActivate = 1;\n      }\n      thumbsToActivate = Math.floor(thumbsToActivate);\n      thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n        for (let i = 0; i < thumbsToActivate; i += 1) {\n          elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n            slideEl.classList.add(thumbActiveClass);\n          });\n        }\n      } else {\n        for (let i = 0; i < thumbsToActivate; i += 1) {\n          if (thumbsSwiper.slides[swiper.realIndex + i]) {\n            thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n          }\n        }\n      }\n      const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n      const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n      if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n        const currentThumbsIndex = thumbsSwiper.activeIndex;\n        let newThumbsIndex;\n        let direction;\n        if (thumbsSwiper.params.loop) {\n          const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];\n          newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n          direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n        } else {\n          newThumbsIndex = swiper.realIndex;\n          direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n        }\n        if (useOffset) {\n          newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n        }\n        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n          if (thumbsSwiper.params.centeredSlides) {\n            if (newThumbsIndex > currentThumbsIndex) {\n              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n            } else {\n              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n            }\n          } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;\n          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n        }\n      }\n    }\n    on('beforeInit', () => {\n      const {\n        thumbs\n      } = swiper.params;\n      if (!thumbs || !thumbs.swiper) return;\n      if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n        const document = getDocument();\n        const getThumbsElementAndInit = () => {\n          const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n          if (thumbsElement && thumbsElement.swiper) {\n            thumbs.swiper = thumbsElement.swiper;\n            init();\n            update(true);\n          } else if (thumbsElement) {\n            const onThumbsSwiper = e => {\n              thumbs.swiper = e.detail[0];\n              thumbsElement.removeEventListener('init', onThumbsSwiper);\n              init();\n              update(true);\n              thumbs.swiper.update();\n              swiper.update();\n            };\n            thumbsElement.addEventListener('init', onThumbsSwiper);\n          }\n          return thumbsElement;\n        };\n        const watchForThumbsToAppear = () => {\n          if (swiper.destroyed) return;\n          const thumbsElement = getThumbsElementAndInit();\n          if (!thumbsElement) {\n            requestAnimationFrame(watchForThumbsToAppear);\n          }\n        };\n        requestAnimationFrame(watchForThumbsToAppear);\n      } else {\n        init();\n        update(true);\n      }\n    });\n    on('slideChange update resize observerUpdate', () => {\n      update();\n    });\n    on('setTransition', (_s, duration) => {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      thumbsSwiper.setTransition(duration);\n    });\n    on('beforeDestroy', () => {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      if (swiperCreated) {\n        thumbsSwiper.destroy();\n      }\n    });\n    Object.assign(swiper.thumbs, {\n      init,\n      update\n    });\n  }\n\n  function freeMode(_ref) {\n    let {\n      swiper,\n      extendParams,\n      emit,\n      once\n    } = _ref;\n    extendParams({\n      freeMode: {\n        enabled: false,\n        momentum: true,\n        momentumRatio: 1,\n        momentumBounce: true,\n        momentumBounceRatio: 1,\n        momentumVelocityRatio: 1,\n        sticky: false,\n        minimumVelocity: 0.02\n      }\n    });\n    function onTouchStart() {\n      if (swiper.params.cssMode) return;\n      const translate = swiper.getTranslate();\n      swiper.setTranslate(translate);\n      swiper.setTransition(0);\n      swiper.touchEventsData.velocities.length = 0;\n      swiper.freeMode.onTouchEnd({\n        currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n      });\n    }\n    function onTouchMove() {\n      if (swiper.params.cssMode) return;\n      const {\n        touchEventsData: data,\n        touches\n      } = swiper;\n      // Velocity\n      if (data.velocities.length === 0) {\n        data.velocities.push({\n          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n          time: data.touchStartTime\n        });\n      }\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n        time: now()\n      });\n    }\n    function onTouchEnd(_ref2) {\n      let {\n        currentPos\n      } = _ref2;\n      if (swiper.params.cssMode) return;\n      const {\n        params,\n        wrapperEl,\n        rtlTranslate: rtl,\n        snapGrid,\n        touchEventsData: data\n      } = swiper;\n      // Time diff\n      const touchEndTime = now();\n      const timeDiff = touchEndTime - data.touchStartTime;\n      if (currentPos < -swiper.minTranslate()) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n      if (currentPos > -swiper.maxTranslate()) {\n        if (swiper.slides.length < snapGrid.length) {\n          swiper.slideTo(snapGrid.length - 1);\n        } else {\n          swiper.slideTo(swiper.slides.length - 1);\n        }\n        return;\n      }\n      if (params.freeMode.momentum) {\n        if (data.velocities.length > 1) {\n          const lastMoveEvent = data.velocities.pop();\n          const velocityEvent = data.velocities.pop();\n          const distance = lastMoveEvent.position - velocityEvent.position;\n          const time = lastMoveEvent.time - velocityEvent.time;\n          swiper.velocity = distance / time;\n          swiper.velocity /= 2;\n          if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n            swiper.velocity = 0;\n          }\n          // this implies that the user stopped moving a finger then released.\n          // There would be no events with distance zero, so the last event is stale.\n          if (time > 150 || now() - lastMoveEvent.time > 300) {\n            swiper.velocity = 0;\n          }\n        } else {\n          swiper.velocity = 0;\n        }\n        swiper.velocity *= params.freeMode.momentumVelocityRatio;\n        data.velocities.length = 0;\n        let momentumDuration = 1000 * params.freeMode.momentumRatio;\n        const momentumDistance = swiper.velocity * momentumDuration;\n        let newPosition = swiper.translate + momentumDistance;\n        if (rtl) newPosition = -newPosition;\n        let doBounce = false;\n        let afterBouncePosition;\n        const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n        let needsLoopFix;\n        if (newPosition < swiper.maxTranslate()) {\n          if (params.freeMode.momentumBounce) {\n            if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n              newPosition = swiper.maxTranslate() - bounceAmount;\n            }\n            afterBouncePosition = swiper.maxTranslate();\n            doBounce = true;\n            data.allowMomentumBounce = true;\n          } else {\n            newPosition = swiper.maxTranslate();\n          }\n          if (params.loop && params.centeredSlides) needsLoopFix = true;\n        } else if (newPosition > swiper.minTranslate()) {\n          if (params.freeMode.momentumBounce) {\n            if (newPosition - swiper.minTranslate() > bounceAmount) {\n              newPosition = swiper.minTranslate() + bounceAmount;\n            }\n            afterBouncePosition = swiper.minTranslate();\n            doBounce = true;\n            data.allowMomentumBounce = true;\n          } else {\n            newPosition = swiper.minTranslate();\n          }\n          if (params.loop && params.centeredSlides) needsLoopFix = true;\n        } else if (params.freeMode.sticky) {\n          let nextSlide;\n          for (let j = 0; j < snapGrid.length; j += 1) {\n            if (snapGrid[j] > -newPosition) {\n              nextSlide = j;\n              break;\n            }\n          }\n          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n            newPosition = snapGrid[nextSlide];\n          } else {\n            newPosition = snapGrid[nextSlide - 1];\n          }\n          newPosition = -newPosition;\n        }\n        if (needsLoopFix) {\n          once('transitionEnd', () => {\n            swiper.loopFix();\n          });\n        }\n        // Fix duration\n        if (swiper.velocity !== 0) {\n          if (rtl) {\n            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n          } else {\n            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n          }\n          if (params.freeMode.sticky) {\n            // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n            // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n            // It's easy to see this when simulating touch with mouse events. To fix this,\n            // limit single-slide swipes to the default slide duration. This also has the\n            // nice side effect of matching slide speed if the user stopped moving before\n            // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n            // For faster swipes, also apply limits (albeit higher ones).\n            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n            const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n            if (moveDistance < currentSlideSize) {\n              momentumDuration = params.speed;\n            } else if (moveDistance < 2 * currentSlideSize) {\n              momentumDuration = params.speed * 1.5;\n            } else {\n              momentumDuration = params.speed * 2.5;\n            }\n          }\n        } else if (params.freeMode.sticky) {\n          swiper.slideToClosest();\n          return;\n        }\n        if (params.freeMode.momentumBounce && doBounce) {\n          swiper.updateProgress(afterBouncePosition);\n          swiper.setTransition(momentumDuration);\n          swiper.setTranslate(newPosition);\n          swiper.transitionStart(true, swiper.swipeDirection);\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n            emit('momentumBounce');\n            swiper.setTransition(params.speed);\n            setTimeout(() => {\n              swiper.setTranslate(afterBouncePosition);\n              elementTransitionEnd(wrapperEl, () => {\n                if (!swiper || swiper.destroyed) return;\n                swiper.transitionEnd();\n              });\n            }, 0);\n          });\n        } else if (swiper.velocity) {\n          emit('_freeModeNoMomentumRelease');\n          swiper.updateProgress(newPosition);\n          swiper.setTransition(momentumDuration);\n          swiper.setTranslate(newPosition);\n          swiper.transitionStart(true, swiper.swipeDirection);\n          if (!swiper.animating) {\n            swiper.animating = true;\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }\n        } else {\n          swiper.updateProgress(newPosition);\n        }\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      } else if (params.freeMode) {\n        emit('_freeModeNoMomentumRelease');\n      }\n      if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n    }\n    Object.assign(swiper, {\n      freeMode: {\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd\n      }\n    });\n  }\n\n  function Grid(_ref) {\n    let {\n      swiper,\n      extendParams\n    } = _ref;\n    extendParams({\n      grid: {\n        rows: 1,\n        fill: 'column'\n      }\n    });\n    let slidesNumberEvenToRows;\n    let slidesPerRow;\n    let numFullColumns;\n    const getSpaceBetween = () => {\n      let spaceBetween = swiper.params.spaceBetween;\n      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n      } else if (typeof spaceBetween === 'string') {\n        spaceBetween = parseFloat(spaceBetween);\n      }\n      return spaceBetween;\n    };\n    const initSlides = slidesLength => {\n      const {\n        slidesPerView\n      } = swiper.params;\n      const {\n        rows,\n        fill\n      } = swiper.params.grid;\n      numFullColumns = Math.floor(slidesLength / rows);\n      if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n        slidesNumberEvenToRows = slidesLength;\n      } else {\n        slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n      }\n      if (slidesPerView !== 'auto' && fill === 'row') {\n        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n      }\n      slidesPerRow = slidesNumberEvenToRows / rows;\n    };\n    const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n      const {\n        slidesPerGroup\n      } = swiper.params;\n      const spaceBetween = getSpaceBetween();\n      const {\n        rows,\n        fill\n      } = swiper.params.grid;\n      // Set slides order\n      let newSlideOrderIndex;\n      let column;\n      let row;\n      if (fill === 'row' && slidesPerGroup > 1) {\n        const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n        const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n        const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n        row = Math.floor(slideIndexInGroup / columnsInGroup);\n        column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n        newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n        slide.style.order = newSlideOrderIndex;\n      } else if (fill === 'column') {\n        column = Math.floor(i / rows);\n        row = i - column * rows;\n        if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n          row += 1;\n          if (row >= rows) {\n            row = 0;\n            column += 1;\n          }\n        }\n      } else {\n        row = Math.floor(i / slidesPerRow);\n        column = i - row * slidesPerRow;\n      }\n      slide.row = row;\n      slide.column = column;\n      slide.style[getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n    };\n    const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n      const {\n        centeredSlides,\n        roundLengths\n      } = swiper.params;\n      const spaceBetween = getSpaceBetween();\n      const {\n        rows\n      } = swiper.params.grid;\n      swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n      swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n      swiper.wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n      if (centeredSlides) {\n        const newSlidesGrid = [];\n        for (let i = 0; i < snapGrid.length; i += 1) {\n          let slidesGridItem = snapGrid[i];\n          if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n          if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n        }\n        snapGrid.splice(0, snapGrid.length);\n        snapGrid.push(...newSlidesGrid);\n      }\n    };\n    swiper.grid = {\n      initSlides,\n      updateSlide,\n      updateWrapperSize\n    };\n  }\n\n  function appendSlide(slides) {\n    const swiper = this;\n    const {\n      params,\n      slidesEl\n    } = swiper;\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n    const appendElement = slideEl => {\n      if (typeof slideEl === 'string') {\n        const tempDOM = document.createElement('div');\n        tempDOM.innerHTML = slideEl;\n        slidesEl.append(tempDOM.children[0]);\n        tempDOM.innerHTML = '';\n      } else {\n        slidesEl.append(slideEl);\n      }\n    };\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) appendElement(slides[i]);\n      }\n    } else {\n      appendElement(slides);\n    }\n    swiper.recalcSlides();\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n    if (!params.observer || swiper.isElement) {\n      swiper.update();\n    }\n  }\n\n  function prependSlide(slides) {\n    const swiper = this;\n    const {\n      params,\n      activeIndex,\n      slidesEl\n    } = swiper;\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n    let newActiveIndex = activeIndex + 1;\n    const prependElement = slideEl => {\n      if (typeof slideEl === 'string') {\n        const tempDOM = document.createElement('div');\n        tempDOM.innerHTML = slideEl;\n        slidesEl.prepend(tempDOM.children[0]);\n        tempDOM.innerHTML = '';\n      } else {\n        slidesEl.prepend(slideEl);\n      }\n    };\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) prependElement(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n    } else {\n      prependElement(slides);\n    }\n    swiper.recalcSlides();\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n    if (!params.observer || swiper.isElement) {\n      swiper.update();\n    }\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n\n  function addSlide(index, slides) {\n    const swiper = this;\n    const {\n      params,\n      activeIndex,\n      slidesEl\n    } = swiper;\n    let activeIndexBuffer = activeIndex;\n    if (params.loop) {\n      activeIndexBuffer -= swiper.loopedSlides;\n      swiper.loopDestroy();\n      swiper.recalcSlides();\n    }\n    const baseLength = swiper.slides.length;\n    if (index <= 0) {\n      swiper.prependSlide(slides);\n      return;\n    }\n    if (index >= baseLength) {\n      swiper.appendSlide(slides);\n      return;\n    }\n    let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n    const slidesBuffer = [];\n    for (let i = baseLength - 1; i >= index; i -= 1) {\n      const currentSlide = swiper.slides[i];\n      currentSlide.remove();\n      slidesBuffer.unshift(currentSlide);\n    }\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) slidesEl.append(slides[i]);\n      }\n      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n    } else {\n      slidesEl.append(slides);\n    }\n    for (let i = 0; i < slidesBuffer.length; i += 1) {\n      slidesEl.append(slidesBuffer[i]);\n    }\n    swiper.recalcSlides();\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n    if (!params.observer || swiper.isElement) {\n      swiper.update();\n    }\n    if (params.loop) {\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n    } else {\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n  }\n\n  function removeSlide(slidesIndexes) {\n    const swiper = this;\n    const {\n      params,\n      activeIndex\n    } = swiper;\n    let activeIndexBuffer = activeIndex;\n    if (params.loop) {\n      activeIndexBuffer -= swiper.loopedSlides;\n      swiper.loopDestroy();\n    }\n    let newActiveIndex = activeIndexBuffer;\n    let indexToRemove;\n    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n      for (let i = 0; i < slidesIndexes.length; i += 1) {\n        indexToRemove = slidesIndexes[i];\n        if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n      }\n      newActiveIndex = Math.max(newActiveIndex, 0);\n    } else {\n      indexToRemove = slidesIndexes;\n      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n      newActiveIndex = Math.max(newActiveIndex, 0);\n    }\n    swiper.recalcSlides();\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n    if (!params.observer || swiper.isElement) {\n      swiper.update();\n    }\n    if (params.loop) {\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n    } else {\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n  }\n\n  function removeAllSlides() {\n    const swiper = this;\n    const slidesIndexes = [];\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      slidesIndexes.push(i);\n    }\n    swiper.removeSlide(slidesIndexes);\n  }\n\n  function Manipulation(_ref) {\n    let {\n      swiper\n    } = _ref;\n    Object.assign(swiper, {\n      appendSlide: appendSlide.bind(swiper),\n      prependSlide: prependSlide.bind(swiper),\n      addSlide: addSlide.bind(swiper),\n      removeSlide: removeSlide.bind(swiper),\n      removeAllSlides: removeAllSlides.bind(swiper)\n    });\n  }\n\n  function effectInit(params) {\n    const {\n      effect,\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      overwriteParams,\n      perspective,\n      recreateShadows,\n      getEffectParams\n    } = params;\n    on('beforeInit', () => {\n      if (swiper.params.effect !== effect) return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n      if (perspective && perspective()) {\n        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      }\n      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n      Object.assign(swiper.params, overwriteParamsResult);\n      Object.assign(swiper.originalParams, overwriteParamsResult);\n    });\n    on('setTranslate', () => {\n      if (swiper.params.effect !== effect) return;\n      setTranslate();\n    });\n    on('setTransition', (_s, duration) => {\n      if (swiper.params.effect !== effect) return;\n      setTransition(duration);\n    });\n    on('transitionEnd', () => {\n      if (swiper.params.effect !== effect) return;\n      if (recreateShadows) {\n        if (!getEffectParams || !getEffectParams().slideShadows) return;\n        // remove shadows\n        swiper.slides.forEach(slideEl => {\n          slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n        });\n        // create new one\n        recreateShadows();\n      }\n    });\n    let requireUpdateOnVirtual;\n    on('virtualUpdate', () => {\n      if (swiper.params.effect !== effect) return;\n      if (!swiper.slides.length) {\n        requireUpdateOnVirtual = true;\n      }\n      requestAnimationFrame(() => {\n        if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n          setTranslate();\n          requireUpdateOnVirtual = false;\n        }\n      });\n    });\n  }\n\n  function effectTarget(effectParams, slideEl) {\n    const transformEl = getSlideTransformEl(slideEl);\n    if (transformEl !== slideEl) {\n      transformEl.style.backfaceVisibility = 'hidden';\n      transformEl.style['-webkit-backface-visibility'] = 'hidden';\n    }\n    return transformEl;\n  }\n\n  function effectVirtualTransitionEnd(_ref) {\n    let {\n      swiper,\n      duration,\n      transformElements,\n      allSlides\n    } = _ref;\n    const {\n      activeIndex\n    } = swiper;\n    const getSlide = el => {\n      if (!el.parentElement) {\n        // assume shadow root\n        const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];\n        return slide;\n      }\n      return el.parentElement;\n    };\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      let transitionEndTarget;\n      if (allSlides) {\n        transitionEndTarget = transformElements;\n      } else {\n        transitionEndTarget = transformElements.filter(transformEl => {\n          const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n          return swiper.getSlideIndex(el) === activeIndex;\n        });\n      }\n      transitionEndTarget.forEach(el => {\n        elementTransitionEnd(el, () => {\n          if (eventTriggered) return;\n          if (!swiper || swiper.destroyed) return;\n          eventTriggered = true;\n          swiper.animating = false;\n          const evt = new window.CustomEvent('transitionend', {\n            bubbles: true,\n            cancelable: true\n          });\n          swiper.wrapperEl.dispatchEvent(evt);\n        });\n      });\n    }\n  }\n\n  function EffectFade(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      fadeEffect: {\n        crossFade: false\n      }\n    });\n    const setTranslate = () => {\n      const {\n        slides\n      } = swiper;\n      const params = swiper.params.fadeEffect;\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = swiper.slides[i];\n        const offset = slideEl.swiperSlideOffset;\n        let tx = -offset;\n        if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n        let ty = 0;\n        if (!swiper.isHorizontal()) {\n          ty = tx;\n          tx = 0;\n        }\n        const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.opacity = slideOpacity;\n        targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n      });\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformElements,\n        allSlides: true\n      });\n    };\n    effectInit({\n      effect: 'fade',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: !swiper.params.cssMode\n      })\n    });\n  }\n\n  function EffectCube(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      cubeEffect: {\n        slideShadows: true,\n        shadow: true,\n        shadowOffset: 20,\n        shadowScale: 0.94\n      }\n    });\n    const createSlideShadows = (slideEl, progress, isHorizontal) => {\n      let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n      let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n      if (!shadowBefore) {\n        shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));\n        slideEl.append(shadowBefore);\n      }\n      if (!shadowAfter) {\n        shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));\n        slideEl.append(shadowAfter);\n      }\n      if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n      if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n    };\n    const recreateShadows = () => {\n      // create new ones\n      const isHorizontal = swiper.isHorizontal();\n      swiper.slides.forEach(slideEl => {\n        const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        createSlideShadows(slideEl, progress, isHorizontal);\n      });\n    };\n    const setTranslate = () => {\n      const {\n        el,\n        wrapperEl,\n        slides,\n        width: swiperWidth,\n        height: swiperHeight,\n        rtlTranslate: rtl,\n        size: swiperSize,\n        browser\n      } = swiper;\n      const params = swiper.params.cubeEffect;\n      const isHorizontal = swiper.isHorizontal();\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      let wrapperRotate = 0;\n      let cubeShadowEl;\n      if (params.shadow) {\n        if (isHorizontal) {\n          cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');\n          if (!cubeShadowEl) {\n            cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n            swiper.wrapperEl.append(cubeShadowEl);\n          }\n          cubeShadowEl.style.height = `${swiperWidth}px`;\n        } else {\n          cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n          if (!cubeShadowEl) {\n            cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n            el.append(cubeShadowEl);\n          }\n        }\n      }\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = slides[i];\n        let slideIndex = i;\n        if (isVirtual) {\n          slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n        }\n        let slideAngle = slideIndex * 90;\n        let round = Math.floor(slideAngle / 360);\n        if (rtl) {\n          slideAngle = -slideAngle;\n          round = Math.floor(-slideAngle / 360);\n        }\n        const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        let tx = 0;\n        let ty = 0;\n        let tz = 0;\n        if (slideIndex % 4 === 0) {\n          tx = -round * 4 * swiperSize;\n          tz = 0;\n        } else if ((slideIndex - 1) % 4 === 0) {\n          tx = 0;\n          tz = -round * 4 * swiperSize;\n        } else if ((slideIndex - 2) % 4 === 0) {\n          tx = swiperSize + round * 4 * swiperSize;\n          tz = swiperSize;\n        } else if ((slideIndex - 3) % 4 === 0) {\n          tx = -swiperSize;\n          tz = 3 * swiperSize + swiperSize * 4 * round;\n        }\n        if (rtl) {\n          tx = -tx;\n        }\n        if (!isHorizontal) {\n          ty = tx;\n          tx = 0;\n        }\n        const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n        if (progress <= 1 && progress > -1) {\n          wrapperRotate = slideIndex * 90 + progress * 90;\n          if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n        }\n        slideEl.style.transform = transform;\n        if (params.slideShadows) {\n          createSlideShadows(slideEl, progress, isHorizontal);\n        }\n      }\n      wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n      wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n      if (params.shadow) {\n        if (isHorizontal) {\n          cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n        } else {\n          const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n          const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n          const scale1 = params.shadowScale;\n          const scale2 = params.shadowScale / multiplier;\n          const offset = params.shadowOffset;\n          cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n        }\n      }\n      const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n      wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n      wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n    };\n    const setTransition = duration => {\n      const {\n        el,\n        slides\n      } = swiper;\n      slides.forEach(slideEl => {\n        slideEl.style.transitionDuration = `${duration}ms`;\n        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n          subEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n        const shadowEl = el.querySelector('.swiper-cube-shadow');\n        if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n      }\n    };\n    effectInit({\n      effect: 'cube',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      recreateShadows,\n      getEffectParams: () => swiper.params.cubeEffect,\n      perspective: () => true,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        resistanceRatio: 0,\n        spaceBetween: 0,\n        centeredSlides: false,\n        virtualTranslate: true\n      })\n    });\n  }\n\n  function createShadow(suffix, slideEl, side) {\n    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;\n    const shadowContainer = getSlideTransformEl(slideEl);\n    let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);\n    if (!shadowEl) {\n      shadowEl = createElement('div', shadowClass.split(' '));\n      shadowContainer.append(shadowEl);\n    }\n    return shadowEl;\n  }\n\n  function EffectFlip(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      flipEffect: {\n        slideShadows: true,\n        limitRotation: true\n      }\n    });\n    const createSlideShadows = (slideEl, progress) => {\n      let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n      let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n      if (!shadowBefore) {\n        shadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');\n      }\n      if (!shadowAfter) {\n        shadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n      }\n      if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n      if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n    };\n    const recreateShadows = () => {\n      // Set shadows\n      swiper.params.flipEffect;\n      swiper.slides.forEach(slideEl => {\n        let progress = slideEl.progress;\n        if (swiper.params.flipEffect.limitRotation) {\n          progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        }\n        createSlideShadows(slideEl, progress);\n      });\n    };\n    const setTranslate = () => {\n      const {\n        slides,\n        rtlTranslate: rtl\n      } = swiper;\n      const params = swiper.params.flipEffect;\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = slides[i];\n        let progress = slideEl.progress;\n        if (swiper.params.flipEffect.limitRotation) {\n          progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        }\n        const offset = slideEl.swiperSlideOffset;\n        const rotate = -180 * progress;\n        let rotateY = rotate;\n        let rotateX = 0;\n        let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n        let ty = 0;\n        if (!swiper.isHorizontal()) {\n          ty = tx;\n          tx = 0;\n          rotateX = -rotateY;\n          rotateY = 0;\n        } else if (rtl) {\n          rotateY = -rotateY;\n        }\n        slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n        if (params.slideShadows) {\n          createSlideShadows(slideEl, progress);\n        }\n        const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.transform = transform;\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n        el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n          shadowEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformElements\n      });\n    };\n    effectInit({\n      effect: 'flip',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      recreateShadows,\n      getEffectParams: () => swiper.params.flipEffect,\n      perspective: () => true,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: !swiper.params.cssMode\n      })\n    });\n  }\n\n  function EffectCoverflow(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      coverflowEffect: {\n        rotate: 50,\n        stretch: 0,\n        depth: 100,\n        scale: 1,\n        modifier: 1,\n        slideShadows: true\n      }\n    });\n    const setTranslate = () => {\n      const {\n        width: swiperWidth,\n        height: swiperHeight,\n        slides,\n        slidesSizesGrid\n      } = swiper;\n      const params = swiper.params.coverflowEffect;\n      const isHorizontal = swiper.isHorizontal();\n      const transform = swiper.translate;\n      const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n      const rotate = isHorizontal ? params.rotate : -params.rotate;\n      const translate = params.depth;\n      // Each slide offset from center\n      for (let i = 0, length = slides.length; i < length; i += 1) {\n        const slideEl = slides[i];\n        const slideSize = slidesSizesGrid[i];\n        const slideOffset = slideEl.swiperSlideOffset;\n        const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n        const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n        let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n        let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n        // var rotateZ = 0\n        let translateZ = -translate * Math.abs(offsetMultiplier);\n        let stretch = params.stretch;\n        // Allow percentage to make a relative stretch for responsive sliders\n        if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n          stretch = parseFloat(params.stretch) / 100 * slideSize;\n        }\n        let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n        let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n        let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n        // Fix for ultra small values\n        if (Math.abs(translateX) < 0.001) translateX = 0;\n        if (Math.abs(translateY) < 0.001) translateY = 0;\n        if (Math.abs(translateZ) < 0.001) translateZ = 0;\n        if (Math.abs(rotateY) < 0.001) rotateY = 0;\n        if (Math.abs(rotateX) < 0.001) rotateX = 0;\n        if (Math.abs(scale) < 0.001) scale = 0;\n        const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.transform = slideTransform;\n        slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n        if (params.slideShadows) {\n          // Set shadows\n          let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n          let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n          if (!shadowBeforeEl) {\n            shadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');\n          }\n          if (!shadowAfterEl) {\n            shadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');\n          }\n          if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n          if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n        }\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n        el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n          shadowEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n    };\n    effectInit({\n      effect: 'coverflow',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => true,\n      overwriteParams: () => ({\n        watchSlidesProgress: true\n      })\n    });\n  }\n\n  function EffectCreative(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      creativeEffect: {\n        limitProgress: 1,\n        shadowPerProgress: false,\n        progressMultiplier: 1,\n        perspective: true,\n        prev: {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          opacity: 1,\n          scale: 1\n        },\n        next: {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          opacity: 1,\n          scale: 1\n        }\n      }\n    });\n    const getTranslateValue = value => {\n      if (typeof value === 'string') return value;\n      return `${value}px`;\n    };\n    const setTranslate = () => {\n      const {\n        slides,\n        wrapperEl,\n        slidesSizesGrid\n      } = swiper;\n      const params = swiper.params.creativeEffect;\n      const {\n        progressMultiplier: multiplier\n      } = params;\n      const isCenteredSlides = swiper.params.centeredSlides;\n      if (isCenteredSlides) {\n        const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n        wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n      }\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = slides[i];\n        const slideProgress = slideEl.progress;\n        const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n        let originalProgress = progress;\n        if (!isCenteredSlides) {\n          originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n        }\n        const offset = slideEl.swiperSlideOffset;\n        const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n        const r = [0, 0, 0];\n        let custom = false;\n        if (!swiper.isHorizontal()) {\n          t[1] = t[0];\n          t[0] = 0;\n        }\n        let data = {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          scale: 1,\n          opacity: 1\n        };\n        if (progress < 0) {\n          data = params.next;\n          custom = true;\n        } else if (progress > 0) {\n          data = params.prev;\n          custom = true;\n        }\n        // set translate\n        t.forEach((value, index) => {\n          t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n        });\n        // set rotates\n        r.forEach((value, index) => {\n          r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n        });\n        slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n        const translateString = t.join(', ');\n        const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n        const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n        const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n        const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n        // Set shadows\n        if (custom && data.shadow || !custom) {\n          let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n          if (!shadowEl && data.shadow) {\n            shadowEl = createShadow('creative', slideEl);\n          }\n          if (shadowEl) {\n            const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n            shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n          }\n        }\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.transform = transform;\n        targetEl.style.opacity = opacityString;\n        if (data.origin) {\n          targetEl.style.transformOrigin = data.origin;\n        }\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n        el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n          shadowEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformElements,\n        allSlides: true\n      });\n    };\n    effectInit({\n      effect: 'creative',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => swiper.params.creativeEffect.perspective,\n      overwriteParams: () => ({\n        watchSlidesProgress: true,\n        virtualTranslate: !swiper.params.cssMode\n      })\n    });\n  }\n\n  function EffectCards(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      cardsEffect: {\n        slideShadows: true,\n        rotate: true,\n        perSlideRotate: 2,\n        perSlideOffset: 8\n      }\n    });\n    const setTranslate = () => {\n      const {\n        slides,\n        activeIndex,\n        rtlTranslate: rtl\n      } = swiper;\n      const params = swiper.params.cardsEffect;\n      const {\n        startTranslate,\n        isTouched\n      } = swiper.touchEventsData;\n      const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = slides[i];\n        const slideProgress = slideEl.progress;\n        const progress = Math.min(Math.max(slideProgress, -4), 4);\n        let offset = slideEl.swiperSlideOffset;\n        if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n          swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n        }\n        if (swiper.params.centeredSlides && swiper.params.cssMode) {\n          offset -= slides[0].swiperSlideOffset;\n        }\n        let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n        let tY = 0;\n        const tZ = -100 * Math.abs(progress);\n        let scale = 1;\n        let rotate = -params.perSlideRotate * progress;\n        let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n        const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n        const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n        const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n        if (isSwipeToNext || isSwipeToPrev) {\n          const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n          rotate += -28 * progress * subProgress;\n          scale += -0.5 * subProgress;\n          tXAdd += 96 * subProgress;\n          tY = `${-25 * subProgress * Math.abs(progress)}%`;\n        }\n        if (progress < 0) {\n          // next\n          tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n        } else if (progress > 0) {\n          // prev\n          tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n        } else {\n          tX = `${tX}px`;\n        }\n        if (!swiper.isHorizontal()) {\n          const prevY = tY;\n          tY = tX;\n          tX = prevY;\n        }\n        const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n        /* eslint-disable */\n        const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n        /* eslint-enable */\n\n        if (params.slideShadows) {\n          // Set shadows\n          let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n          if (!shadowEl) {\n            shadowEl = createShadow('cards', slideEl);\n          }\n          if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n        }\n        slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.transform = transform;\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n        el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n          shadowEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformElements\n      });\n    };\n    effectInit({\n      effect: 'cards',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => true,\n      overwriteParams: () => ({\n        watchSlidesProgress: true,\n        virtualTranslate: !swiper.params.cssMode\n      })\n    });\n  }\n\n  /**\n   * Swiper 10.1.0\n   * Most modern mobile touch slider and framework with hardware accelerated transitions\n   * https://swiperjs.com\n   *\n   * Copyright 2014-2023 Vladimir Kharlampidi\n   *\n   * Released under the MIT License\n   *\n   * Released on: August 1, 2023\n   */\n\n\n  // Swiper Class\n  const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\n  Swiper.use(modules);\n\n  return Swiper;\n\n})();\n","import { swiperInit, renderSwiper } from './swiper';\n\nfunction crateSlideMarkup(\n  backdrop_path,\n  title,\n  overview,\n  vote_average,\n  id,\n  name\n) {\n  return `\n<div\n  style=\"background-image: url('https://image.tmdb.org/t/p/original${backdrop_path}');\"\n  class=\"swiper-slide hero-img\">\n <div class=\"hero-gradient\">\n  <div class=\"hero-title-wrap\" data-swiper-parallax=\"-300\">\n    <h1 class=\"hero-title\">${title || name}</h1>\n  </div>\n  <div class=\"hero-description-wrap\" data-swiper-parallax=\"-400\">\n    <p class=\"hero-description\">${overview}</p>\n  </div>\n  <div class=\"hero-btn-wrap\" data-swiper-parallax=\"-450\" data-id=\"${id}\">\n  <button type=\"button\" class=\"hero-btn hero-btn-trailer\" id=\"hero-btn-trailer\" data-id=\"${id}\">\n    Watch trailer\n  </button>\n  <button type=\"button\" class=\"hero-btn hero-btn-more is-id\" id=\"hero-btn-more\"  data-modal-open data-id=\"${id}\" >\n    More details\n  </button></div>\n  </div>\n  </div>`;\n}\n\nfunction createMarkup(arr) {\n  return arr\n    .map(({ backdrop_path, title, overview, vote_average, id, name }) => {\n      return crateSlideMarkup(\n        backdrop_path,\n        title,\n        overview,\n        vote_average,\n        id,\n        name\n      );\n    })\n    .join(' ');\n}\n\nfunction renderHeroSlider(arr) {\n  renderSwiper();\n  const markup = createMarkup(arr);\n  document.querySelector('.swiper-wrapper').innerHTML = markup;\n  swiperInit();\n}\n\nexport { renderHeroSlider };","import { Notify } from 'notiflix';\nimport { swiper } from './swiper';\nimport { getMovie } from './api';\n\n//!const trailerErrorKey = 'DB68T2s7gfI';\n\nconst trailerRefs = {\n  erMod : document.querySelector(\".backdrop-oops\"),\n  erBtn : document.querySelector(\".close-modal-oops\"),\n  backDropRef: document.querySelector('.trailer-backdrop'),\n  trailerRef: document.querySelector('.trailer-container'),\n  trailerImg: document.querySelector('#trailer-img-err'),\n};\n\nfunction onWatchTrailer(e) {\n  if (e.target.classList.contains('hero-btn-trailer')) {\n    const dataId = e.target.dataset.id;\n    getTrailerByFilmId(dataId);;\n  }\n}\n\nasync function getTrailerByFilmId(id) {\n  try {\n    const movieData = await getMovie(id);\n    const trailerKey = movieData.results[0].key;\n    renderTrailer(trailerKey);\n  } catch (err) { \n  trailerRefs.erMod.classList.remove(\"is-hidden\");\n   addEventErr()\n   \n    //! renderTrailer(trailerErrorKey);\n    //! Notify.warning(\n    //!   'OOPS... We are very sorry! But we couldn’t find the trailer.'\n    //! );\n  }\n}\n\nfunction renderTrailer(movieKey) {\n  document.body.classList.add('is-scroll-block');\n\n  trailerRefs.backDropRef.classList.remove('is-trailer-hidden');\n  trailerRefs.trailerRef.innerHTML = `<iframe class=\"trailer-iframe\" src='https://www.youtube.com/embed/${movieKey}\n  'frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n  <p>Oops! Trailer not found...</p>`;\n\n  trailerRefs.backDropRef.addEventListener('click', listenBackdropClick);\n  document.body.addEventListener('keydown', listenKeyDawn);\n}\n\nconst listenBackdropClick = event => {\n  if (event.target.classList.contains('trailer-backdrop')) {\n    closeTrailer();\n  }\n};\n\nconst listenKeyDawn = event => {\n  if (event.key === 'Escape' || event.keyCode === 27) {\n    closeTrailer();\n  }\n};\n\nconst closeTrailer = () => {\n  document.body.classList.remove('is-scroll-block');\n  trailerRefs.backDropRef.classList.add('is-trailer-hidden');\n\n  trailerRefs.trailerRef.innerHTML = '';\n\n  if (!window.location.href.includes('/my-lib-page.html'))\n\n  document.body.removeEventListener('keydown', listenKeyDawn);\n  trailerRefs.backDropRef.removeEventListener('click', listenBackdropClick);\n};\n\nexport { renderTrailer, getTrailerByFilmId, onWatchTrailer };\n//?======\nfunction addEventErr() {                            //добавляю слушателей\n  trailerRefs.erMod.addEventListener(\"click\", onBackdropClick);\n  trailerRefs.erBtn.addEventListener(\"click\", clsModal)\n  document.addEventListener('keydown', keyBoardPress);  \n  \n}\nfunction onBackdropClick(event) {                   //закрываю по backdrop\n  if(event.target === event.currentTarget ){  \n  trailerRefs.erMod.classList.add(\"is-hidden\");\n  removeEventErr()\n}}\nfunction keyBoardPress(event) {                     //закрытие по 'Escape'\n  if (event.key === 'Escape'){\n    trailerRefs.erMod.classList.add(\"is-hidden\")  \n    removeEventErr()\n}\n}\nfunction removeEventErr() {                          //убираю слушателей\n  trailerRefs.erMod.removeEventListener(\"click\", onBackdropClick)\n  document.removeEventListener('keydown', keyBoardPress);\n  trailerRefs.erBtn.removeEventListener(\"click\", clsModal)\n}\nfunction clsModal(event) {                           //закрытие по крестику\n  trailerRefs.erMod.classList.add(\"is-hidden\");  \n  removeEventErr();\n}","import axios from 'axios';\nimport { onLoader, removeLoader } from './loader';\n\nconst BASE_URL = 'https://api.themoviedb.org/3';\nconst API_KEY = '5e0b2043a7bdefdf129debb784bbe1f7';\n\nasync function fetchData(url) {\n  try {\n    onLoader();\n    const response = await axios.get(url);\n    removeLoader();\n    return response.data;\n  } catch (error) {\n    removeLoader();\n    return null;\n  }\n}\n\nasync function getTrending(page = 1) {\n  const url = `${BASE_URL}/trending/all/day?api_key=${API_KEY}&language=en-US&page=${page}`;\n  return await fetchData(url);\n}\n\nasync function getByQuery(page, query, date) {\n  const url = `${BASE_URL}/search/movie?api_key=${API_KEY}&query=${query}&page=${page}&language=en-US${\n    date ? `&primary_release_year=${date}` : ''\n  }`;\n  return await fetchData(url);\n}\n\nasync function getInfoByMovie(movie_id) {\n  const url = `${BASE_URL}/movie/${movie_id}?api_key=${API_KEY}&language=en-US`;\n  return await fetchData(url);\n}\n\nasync function getMovie(movie_id) {\n  const url = `${BASE_URL}/movie/${movie_id}/videos?api_key=${API_KEY}&language=en-US`;\n  return await fetchData(url);\n}\n\nasync function getArrMovies(arr) {\n  const promises = arr.map(async movie_id => {\n    const url = `${BASE_URL}/movie/${movie_id}?api_key=${API_KEY}&language=en-US`;\n    return fetchData(url);\n  });\n\n  return await Promise.all(promises);\n}\n\n// ================== add =============\n\nasync function getWeeklyTrending(page = 1) {\n  const url = `${BASE_URL}/trending/all/day?api_key=${API_KEY}&language=en-US&page=${page}`;\n  return await fetchData(url);\n}\n\nasync function getUpcoming(formattedStartDate, formattedEndDate) {\n  const url = `${BASE_URL}/discover/movie?api_key=${API_KEY}&&primary_release_date.gte=${formattedStartDate}&primary_release_date.lte=${formattedEndDate}`;\n  return await fetchData(url);\n}\n\nasync function getGenre() {\n  const url = `${BASE_URL}/genre/movie/list?api_key=${API_KEY}&language=en-USs`;\n  return await fetchData(url);\n}\n\n// ==================================\n\nexport {\n  getTrending,\n  getByQuery,\n  getInfoByMovie,\n  getMovie,\n  getArrMovies,\n  getWeeklyTrending,\n  getUpcoming,\n  getGenre,\n};\n","import { Loading } from 'notiflix/build/notiflix-loading-aio';\n\nfunction onLoader() {\n  Loading.dots({\n    svgColor: 'orange',\n    svgSize: '100px',\n    messageFontSize: '25px',\n    clickToClose: true,\n  });\n}\n\nfunction removeLoader() {\n  Loading.remove();\n}\n\nexport { onLoader, removeLoader };\n","/*\n* Notiflix Loading AIO (https://notiflix.github.io)\n* Description: This file has been created automatically that using \"notiflix.js\", and \"notiflix.css\" files.\n* Version: 3.2.6\n* Author: Furkan (https://github.com/furcan)\n* Copyright 2019 - 2023 Notiflix, MIT Licence (https://opensource.org/licenses/MIT)\n*/\n\n/* global define */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return factory(root);\n    });\n  } else if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory(root);\n  } else {\n    root.Notiflix = factory(root);\n  }\n})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this, function (window) {\n\n  'use strict';\n\n  // COMMON: SSR check: begin\n  if (typeof window === 'undefined' && typeof window.document === 'undefined') {\n    return false;\n  }\n  // COMMON: SSR check: end\n\n  // COMMON: Variables: begin\n  var notiflixNamespace = 'Notiflix';\n  var notiflixConsoleDocs = '\\n\\nVisit documentation page to learn more: https://notiflix.github.io/documentation';\n  var defaultFontFamily = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif';\n  // COMMON: Variables: end\n\n  // LOADING: Default Settings: begin\n  var typesLoading = {\n    Standard: 'Standard',\n    Hourglass: 'Hourglass',\n    Circle: 'Circle',\n    Arrows: 'Arrows',\n    Dots: 'Dots',\n    Pulse: 'Pulse',\n    Custom: 'Custom',\n    Notiflix: 'Notiflix',\n  };\n  var newLoadingSettings;\n  var loadingSettings = {\n    ID: 'NotiflixLoadingWrap', // can not customizable\n    className: 'notiflix-loading',\n    zindex: 4000,\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    rtl: false,\n    fontFamily: 'Quicksand',\n    cssAnimation: true,\n    cssAnimationDuration: 400,\n    clickToClose: false,\n    customSvgUrl: null,\n    customSvgCode: null,\n    svgSize: '80px',\n    svgColor: '#32c682',\n    messageID: 'NotiflixLoadingMessage',\n    messageFontSize: '15px',\n    messageMaxLength: 34,\n    messageColor: '#dcdcdc',\n  };\n  // LOADING: Default Settings: end\n\n  // COMMON: Console Error: begin\n  var commonConsoleError = function (message) {\n    return console.error('%c ' + notiflixNamespace + ' Error ', 'padding:2px;border-radius:20px;color:#fff;background:#ff5549', '\\n' + message + notiflixConsoleDocs);\n  };\n  // COMMON: Console Error: end\n\n  // COMMON: Check Head or Body: begin\n  var commonCheckHeadOrBody = function (element) {\n    if (!element) { element = 'head'; }\n    if (window.document[element] === null) {\n      commonConsoleError('\\nNotiflix needs to be appended to the \"<' + element + '>\" element, but you called it before the \"<' + element + '>\" element has been created.');\n      return false;\n    }\n    return true;\n  };\n  // COMMON: Check Head or Body: end\n\n  // COMMON: Set Internal CSS Codes: begin\n  var commonSetInternalCSSCodes = function (getInternalCSSCodes, styleElementId) {\n    // check doc head\n    if (!commonCheckHeadOrBody('head')) { return false; }\n\n    // internal css\n    if (getInternalCSSCodes() !== null && !window.document.getElementById(styleElementId)) {\n      var internalCSS = window.document.createElement('style');\n      internalCSS.id = styleElementId;\n      internalCSS.innerHTML = getInternalCSSCodes();\n      window.document.head.appendChild(internalCSS);\n    }\n  };\n  // COMMON: Set Internal CSS Codes: end\n\n  // COMMON: Extend Options: begin\n  var commonExtendOptions = function () {\n    // variables\n    var extended = {};\n    var deep = false;\n    var i = 0;\n    // check if a deep merge\n    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {\n      deep = arguments[0];\n      i++;\n    }\n    // merge the object into the extended object\n    var merge = function (obj) {\n      for (var prop in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n          // if property is an object, merge properties\n          if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {\n            extended[prop] = commonExtendOptions(extended[prop], obj[prop]);\n          } else {\n            extended[prop] = obj[prop];\n          }\n        }\n      }\n    };\n    // loop through each object and conduct a merge\n    for (; i < arguments.length; i++) {\n      merge(arguments[i]);\n    }\n    return extended;\n  };\n  // COMMON: Extend Options: end\n\n  // COMMON: Get Plaintext: begin\n  var commonGetPlaintext = function (html) {\n    var htmlPool = window.document.createElement('div');\n    htmlPool.innerHTML = html;\n    return htmlPool.textContent || htmlPool.innerText || '';\n  };\n  // COMMON: Get Plaintext: end\n\n  // LOADING && BLOCK: SVG Icon Standard: begin\n  var loadingAndBlockSvgIconStandard = function (width, color) {\n    if (!width) { width = '60px'; }\n    if (!color) { color = '#32c682'; }\n    var standard = '<svg xmlns=\"http://www.w3.org/2000/svg\" stroke=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" transform=\"scale(.8)\" viewBox=\"0 0 38 38\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\" transform=\"translate(1 1)\"><circle cx=\"18\" cy=\"18\" r=\"18\" stroke-opacity=\".25\"/><path d=\"M36 18c0-9.94-8.06-18-18-18\"><animateTransform attributeName=\"transform\" dur=\"1s\" from=\"0 18 18\" repeatCount=\"indefinite\" to=\"360 18 18\" type=\"rotate\"/></path></g></svg>';\n    return standard;\n  };\n  // LOADING && BLOCK: SVG Icon Standard: end\n\n  // LOADING && BLOCK: SVG Icon Hourglass: begin\n  var loadingAndBlockSvgIconHourglass = function (width, color) {\n    if (!width) { width = '60px'; }\n    if (!color) { color = '#32c682'; }\n    var hourglass = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXLoadingHourglass\" fill=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 200 200\"><style>@-webkit-keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@keyframes NXhourglass5-animation{0%{-webkit-transform:scale(1,1);transform:scale(1,1)}16.67%{-webkit-transform:scale(1,.8);transform:scale(1,.8)}33.33%{-webkit-transform:scale(.88,.6);transform:scale(.88,.6)}37.5%{-webkit-transform:scale(.85,.55);transform:scale(.85,.55)}41.67%{-webkit-transform:scale(.8,.5);transform:scale(.8,.5)}45.83%{-webkit-transform:scale(.75,.45);transform:scale(.75,.45)}50%{-webkit-transform:scale(.7,.4);transform:scale(.7,.4)}54.17%{-webkit-transform:scale(.6,.35);transform:scale(.6,.35)}58.33%{-webkit-transform:scale(.5,.3);transform:scale(.5,.3)}83.33%,to{-webkit-transform:scale(.2,0);transform:scale(.2,0)}}@-webkit-keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@keyframes NXhourglass3-animation{0%{-webkit-transform:scale(1,.02);transform:scale(1,.02)}79.17%,to{-webkit-transform:scale(1,1);transform:scale(1,1)}}@-webkit-keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}@keyframes NXhourglass1-animation{0%,83.33%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}#NXLoadingHourglass *{-webkit-animation-duration:1.2s;animation-duration:1.2s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:cubic-bezier(0,0,1,1);animation-timing-function:cubic-bezier(0,0,1,1)}</style><g data-animator-group=\"true\" data-animator-type=\"1\" style=\"-webkit-animation-name:NXhourglass1-animation;animation-name:NXhourglass1-animation;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transform-box:fill-box\"><g id=\"NXhourglass2\" fill=\"inherit\"><g data-animator-group=\"true\" data-animator-type=\"2\" style=\"-webkit-animation-name:NXhourglass3-animation;animation-name:NXhourglass3-animation;-webkit-animation-timing-function:cubic-bezier(.42,0,.58,1);animation-timing-function:cubic-bezier(.42,0,.58,1);-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\" opacity=\".4\"><path id=\"NXhourglass4\" d=\"M100 100l-34.38 32.08v31.14h68.76v-31.14z\"/></g><g data-animator-group=\"true\" data-animator-type=\"2\" style=\"-webkit-animation-name:NXhourglass5-animation;animation-name:NXhourglass5-animation;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;transform-box:fill-box\" opacity=\".4\"><path id=\"NXhourglass6\" d=\"M100 100L65.62 67.92V36.78h68.76v31.14z\"/></g><path d=\"M51.14 38.89h8.33v14.93c0 15.1 8.29 28.99 23.34 39.1 1.88 1.25 3.04 3.97 3.04 7.08s-1.16 5.83-3.04 7.09c-15.05 10.1-23.34 23.99-23.34 39.09v14.93h-8.33a4.859 4.859 0 1 0 0 9.72h97.72a4.859 4.859 0 1 0 0-9.72h-8.33v-14.93c0-15.1-8.29-28.99-23.34-39.09-1.88-1.26-3.04-3.98-3.04-7.09s1.16-5.83 3.04-7.08c15.05-10.11 23.34-24 23.34-39.1V38.89h8.33a4.859 4.859 0 1 0 0-9.72H51.14a4.859 4.859 0 1 0 0 9.72zm79.67 14.93c0 15.87-11.93 26.25-19.04 31.03-4.6 3.08-7.34 8.75-7.34 15.15 0 6.41 2.74 12.07 7.34 15.15 7.11 4.78 19.04 15.16 19.04 31.03v14.93H69.19v-14.93c0-15.87 11.93-26.25 19.04-31.02 4.6-3.09 7.34-8.75 7.34-15.16 0-6.4-2.74-12.07-7.34-15.15-7.11-4.78-19.04-15.16-19.04-31.03V38.89h61.62v14.93z\"/></g></g></svg>';\n    return hourglass;\n  };\n  // LOADING && BLOCK: SVG Icon Hourglass: end\n\n  // LOADING && BLOCK: SVG Icon Circle: begin\n  var loadingAndBlockSvgIconCircle = function (width, color) {\n    if (!width) { width = '60px'; }\n    if (!color) { color = '#32c682'; }\n    var circle = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"25 25 50 50\" style=\"-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite;height:' + width + ';-webkit-transform-origin:center center;-ms-transform-origin:center center;transform-origin:center center;width:' + width + ';position:absolute;top:0;left:0;margin:auto\"><style>@-webkit-keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}@keyframes dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:89,200;stroke-dashoffset:-35}to{stroke-dasharray:89,200;stroke-dashoffset:-124}}</style><circle cx=\"50\" cy=\"50\" r=\"20\" fill=\"none\" stroke=\"' + color + '\" stroke-width=\"2\" style=\"-webkit-animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite,color 1.5s ease-in-out infinite\" stroke-dasharray=\"150 200\" stroke-dashoffset=\"-10\" stroke-linecap=\"round\"/></svg>';\n    return circle;\n  };\n  // LOADING && BLOCK: SVG Icon Circle: end\n\n  // LOADING && BLOCK: SVG Icon Arrows: begin\n  var loadingAndBlockSvgIconArrows = function (width, color) {\n    if (!width) { width = '60px'; }\n    if (!color) { color = '#32c682'; }\n    var arrows = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 128 128\"><g><path fill=\"inherit\" d=\"M109.25 55.5h-36l12-12a29.54 29.54 0 0 0-49.53 12H18.75A46.04 46.04 0 0 1 96.9 31.84l12.35-12.34v36zm-90.5 17h36l-12 12a29.54 29.54 0 0 0 49.53-12h16.97A46.04 46.04 0 0 1 31.1 96.16L18.74 108.5v-36z\"/><animateTransform attributeName=\"transform\" dur=\"1.5s\" from=\"0 64 64\" repeatCount=\"indefinite\" to=\"360 64 64\" type=\"rotate\"/></g></svg>';\n    return arrows;\n  };\n  // LOADING && BLOCK: SVG Icon Arrows: end\n\n  // LOADING && BLOCK: SVG Icon Dots: begin\n  var loadingAndBlockSvgIconDots = function (width, color) {\n    if (!width) { width = '60px'; }\n    if (!color) { color = '#32c682'; }\n    var dots = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 100 100\"><g transform=\"translate(25 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.239)\"><animateTransform attributeName=\"transform\" begin=\"-0.266s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g><g transform=\"translate(50 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.00152)\"><animateTransform attributeName=\"transform\" begin=\"-0.133s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g><g transform=\"translate(75 50)\"><circle r=\"9\" fill=\"inherit\" transform=\"scale(.299)\"><animateTransform attributeName=\"transform\" begin=\"0s\" calcMode=\"spline\" dur=\"0.8s\" keySplines=\"0.3 0 0.7 1;0.3 0 0.7 1\" keyTimes=\"0;0.5;1\" repeatCount=\"indefinite\" type=\"scale\" values=\"0;1;0\"/></circle></g></svg>';\n    return dots;\n  };\n  // LOADING && BLOCK: SVG Icon Dots: end\n\n  // LOADING && BLOCK: SVG Icon Pulse: begin\n  var loadingAndBlockSvgIconPulse = function (width, color) {\n    if (!width) { width = '60px'; }\n    if (!color) { color = '#32c682'; }\n    var pulse = '<svg xmlns=\"http://www.w3.org/2000/svg\" stroke=\"' + color + '\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 44 44\"><g fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"2\"><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"0s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle><circle cx=\"22\" cy=\"22\" r=\"1\"><animate attributeName=\"r\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.165, 0.84, 0.44, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 20\"/><animate attributeName=\"stroke-opacity\" begin=\"-0.9s\" calcMode=\"spline\" dur=\"1.8s\" keySplines=\"0.3, 0.61, 0.355, 1\" keyTimes=\"0; 1\" repeatCount=\"indefinite\" values=\"1; 0\"/></circle></g></svg>';\n    return pulse;\n  };\n  // LOADING && BLOCK: SVG Icon Pulse: end\n\n  // LOADING && BLOCK: SVG Icon Notiflix: begin\n  var loadingAndBlockSvgIconNotiflix = function (width, white, green) {\n    if (!width) { width = '60px'; }\n    if (!white) { white = '#f8f8f8'; }\n    if (!green) { green = '#32c682'; }\n    var notiflixIcon = '<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"NXLoadingNotiflixLib\" width=\"' + width + '\" height=\"' + width + '\" viewBox=\"0 0 200 200\"><defs><style>@keyframes notiflix-n{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-x{0%{stroke-dashoffset:1000}to{stroke-dashoffset:0}}@keyframes notiflix-dot{0%,to{stroke-width:0}50%{stroke-width:12}}.nx-icon-line{stroke:' + white + ';stroke-width:12;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:22;fill:none}</style></defs><path d=\"M47.97 135.05a6.5 6.5 0 1 1 0 13 6.5 6.5 0 0 1 0-13z\" style=\"animation-name:notiflix-dot;animation-timing-function:ease-in-out;animation-duration:1.25s;animation-iteration-count:infinite;animation-direction:normal\" fill=\"' + green + '\" stroke=\"' + green + '\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"22\" stroke-width=\"12\"/><path class=\"nx-icon-line\" d=\"M10.14 144.76V87.55c0-5.68-4.54-41.36 37.83-41.36 42.36 0 37.82 35.68 37.82 41.36v57.21\" style=\"animation-name:notiflix-n;animation-timing-function:linear;animation-duration:2.5s;animation-delay:0s;animation-iteration-count:infinite;animation-direction:normal\" stroke-dasharray=\"500\"/><path class=\"nx-icon-line\" d=\"M115.06 144.49c24.98-32.68 49.96-65.35 74.94-98.03M114.89 46.6c25.09 32.58 50.19 65.17 75.29 97.75\" style=\"animation-name:notiflix-x;animation-timing-function:linear;animation-duration:2.5s;animation-delay:.2s;animation-iteration-count:infinite;animation-direction:normal\" stroke-dasharray=\"500\"/></svg>';\n    return notiflixIcon;\n  };\n  // LOADING && BLOCK: SVG Icon Notiflix: end\n\n  // LOADING: Get Internal CSS Codes: begin\n  var loadingGetInternalCSSCodes = function () {\n    var loadingCSS = '[id^=NotiflixLoadingWrap]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:fixed;z-index:4000;width:100%;height:100%;left:0;top:0;right:0;bottom:0;margin:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;background:rgba(0,0,0,.8);font-family:\"Quicksand\",-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif}[id^=NotiflixLoadingWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixLoadingWrap].nx-loading-click-to-close{cursor:pointer}[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"]{width:60px;height:60px;position:relative;-webkit-transition:top .2s ease-in-out;-o-transition:top .2s ease-in-out;transition:top .2s ease-in-out;margin:0 auto}[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"] img,[id^=NotiflixLoadingWrap]>div[class*=\"-icon\"] svg{max-width:unset;max-height:unset;width:100%;height:auto;position:absolute;left:0;top:0}[id^=NotiflixLoadingWrap]>p{position:relative;margin:10px auto 0;font-family:inherit!important;font-weight:normal;font-size:15px;line-height:1.4;padding:0 10px;width:100%;text-align:center}[id^=NotiflixLoadingWrap].nx-with-animation{-webkit-animation:loading-animation-fade .3s ease-in-out 0s normal;animation:loading-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixLoadingWrap].nx-with-animation.nx-remove{opacity:0;-webkit-animation:loading-animation-fade-remove .3s ease-in-out 0s normal;animation:loading-animation-fade-remove .3s ease-in-out 0s normal}@-webkit-keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}@keyframes loading-animation-fade-remove{0%{opacity:1}100%{opacity:0}}[id^=NotiflixLoadingWrap]>p.nx-loading-message-new{-webkit-animation:loading-new-message-fade .3s ease-in-out 0s normal;animation:loading-new-message-fade .3s ease-in-out 0s normal}@-webkit-keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}@keyframes loading-new-message-fade{0%{opacity:0}100%{opacity:1}}';\n    return loadingCSS || null;\n  };\n  // LOADING: Get Internal CSS Codes: end\n\n  // LOADING: Create: begin\n  var loadingCreate = function (loadingType, messageOrOptions, options, display, delay) {\n    // check doc body\n    if (!commonCheckHeadOrBody('body')) { return false; }\n\n    // if not initialized pretend like init\n    if (!newLoadingSettings) {\n      Notiflix.Loading.init({});\n    }\n\n    // create a backup for new settings\n    var newLoadingSettingsBackup = commonExtendOptions(true, newLoadingSettings, {});\n\n    // check \"messageOrOptions\" and \"options\": begin\n    if ((typeof messageOrOptions === 'object' && !Array.isArray(messageOrOptions)) || (typeof options === 'object' && !Array.isArray(options))) {\n      // new options\n      var newOptions = {};\n      if (typeof messageOrOptions === 'object') {\n        newOptions = messageOrOptions;\n      } else if (typeof options === 'object') {\n        newOptions = options;\n      }\n\n      // extend new settings with the new options\n      newLoadingSettings = commonExtendOptions(true, newLoadingSettings, newOptions);\n    }\n    // check \"messageOrOptions\" and \"options\": end\n\n    // check the message\n    var message = '';\n    if (typeof messageOrOptions === 'string' && messageOrOptions.length > 0) {\n      message = messageOrOptions;\n    }\n\n    // show loading\n    if (display) {\n\n      // if message settings: begin\n      if (message.length > newLoadingSettings.messageMaxLength) {\n        message = commonGetPlaintext(message).toString().substring(0, newLoadingSettings.messageMaxLength) + '...';\n      } else {\n        message = commonGetPlaintext(message).toString();\n      }\n      var messageHTML = '';\n      if (message.length > 0) {\n        messageHTML = '<p id=\"' + newLoadingSettings.messageID + '\" class=\"nx-loading-message\" style=\"color:' + newLoadingSettings.messageColor + ';font-size:' + newLoadingSettings.messageFontSize + ';\">' + message + '</p>';\n      }\n      // if message settings: end\n\n      // if cssAnimaion is false => duration: begin\n      if (!newLoadingSettings.cssAnimation) {\n        newLoadingSettings.cssAnimationDuration = 0;\n      }\n      // if cssAnimaion is false => duration: end\n\n      // svgIcon: begin\n      var svgIcon = '';\n      if (loadingType === typesLoading.Standard) {\n        svgIcon = loadingAndBlockSvgIconStandard(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n      } else if (loadingType === typesLoading.Hourglass) {\n        svgIcon = loadingAndBlockSvgIconHourglass(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n      } else if (loadingType === typesLoading.Circle) {\n        svgIcon = loadingAndBlockSvgIconCircle(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n      } else if (loadingType === typesLoading.Arrows) {\n        svgIcon = loadingAndBlockSvgIconArrows(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n      } else if (loadingType === typesLoading.Dots) {\n        svgIcon = loadingAndBlockSvgIconDots(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n      } else if (loadingType === typesLoading.Pulse) {\n        svgIcon = loadingAndBlockSvgIconPulse(newLoadingSettings.svgSize, newLoadingSettings.svgColor);\n      } else if (\n        loadingType === typesLoading.Custom &&\n        newLoadingSettings.customSvgCode !== null &&\n        newLoadingSettings.customSvgUrl === null\n      ) {\n        svgIcon = newLoadingSettings.customSvgCode || '';\n      } else if (\n        loadingType === typesLoading.Custom &&\n        newLoadingSettings.customSvgUrl !== null &&\n        newLoadingSettings.customSvgCode === null\n      ) {\n        svgIcon = '<img class=\"nx-custom-loading-icon\" width=\"' + newLoadingSettings.svgSize + '\" height=\"' + newLoadingSettings.svgSize + '\" src=\"' + newLoadingSettings.customSvgUrl + '\" alt=\"Notiflix\">';\n      } else if (\n        loadingType === typesLoading.Custom &&\n        (newLoadingSettings.customSvgUrl === null || newLoadingSettings.customSvgCode === null)\n      ) {\n        commonConsoleError('You have to set a static SVG url to \"customSvgUrl\" option to use Loading Custom.');\n        return false;\n      } else {\n        svgIcon = loadingAndBlockSvgIconNotiflix(newLoadingSettings.svgSize, '#f8f8f8', '#32c682');\n      }\n      var svgSizeAsDigit = parseInt((newLoadingSettings.svgSize || '').replace(/[^0-9]/g, ''));\n      var winWidth = window.innerWidth;\n      var maxSvgWidthPx = svgSizeAsDigit >= winWidth ? (winWidth - 40) + 'px' : svgSizeAsDigit + 'px';\n      var svgIconHTML = '<div style=\"width:' + maxSvgWidthPx + '; height:' + maxSvgWidthPx + ';\" class=\"' + newLoadingSettings.className + '-icon' + (message.length > 0 ? ' nx-with-message' : '') + '\">' + svgIcon + '</div>';\n      // svgIcon: end\n\n      // loading wrap: begin\n      var ntflxLoadingWrap = window.document.createElement('div');\n      ntflxLoadingWrap.id = loadingSettings.ID;\n      ntflxLoadingWrap.className = newLoadingSettings.className + (newLoadingSettings.cssAnimation ? ' nx-with-animation' : '') + (newLoadingSettings.clickToClose ? ' nx-loading-click-to-close' : '');\n      ntflxLoadingWrap.style.zIndex = newLoadingSettings.zindex;\n      ntflxLoadingWrap.style.background = newLoadingSettings.backgroundColor;\n      ntflxLoadingWrap.style.animationDuration = newLoadingSettings.cssAnimationDuration + 'ms';\n      ntflxLoadingWrap.style.fontFamily = '\"' + newLoadingSettings.fontFamily + '\", ' + defaultFontFamily;\n      ntflxLoadingWrap.style.display = 'flex';\n      ntflxLoadingWrap.style.flexWrap = 'wrap';\n      ntflxLoadingWrap.style.flexDirection = 'column';\n      ntflxLoadingWrap.style.alignItems = 'center';\n      ntflxLoadingWrap.style.justifyContent = 'center';\n\n      // rtl: begin\n      if (newLoadingSettings.rtl) {\n        ntflxLoadingWrap.setAttribute('dir', 'rtl');\n        ntflxLoadingWrap.classList.add('nx-rtl-on');\n      }\n      // rtl: end\n\n      // append: begin\n      ntflxLoadingWrap.innerHTML = svgIconHTML + messageHTML;\n\n      // if there is no loading element\n      if (!window.document.getElementById(ntflxLoadingWrap.id)) {\n        // append\n        window.document.body.appendChild(ntflxLoadingWrap);\n\n        // if click to close\n        if (newLoadingSettings.clickToClose) {\n          var loadingWrapElm = window.document.getElementById(ntflxLoadingWrap.id);\n          loadingWrapElm.addEventListener('click', function () {\n            ntflxLoadingWrap.classList.add('nx-remove');\n            var timeout = setTimeout(function () {\n              if (ntflxLoadingWrap.parentNode !== null) {\n                ntflxLoadingWrap.parentNode.removeChild(ntflxLoadingWrap);\n                clearTimeout(timeout);\n              }\n            }, newLoadingSettings.cssAnimationDuration);\n          });\n        }\n      }\n      // append: end\n    }\n    // remove loading\n    else {\n      // if there is a loading element\n      if (window.document.getElementById(loadingSettings.ID)) {\n        var loadingElm = window.document.getElementById(loadingSettings.ID);\n        var timeout = setTimeout(function () {\n          loadingElm.classList.add('nx-remove');\n          var timeout2 = setTimeout(function () {\n            if (loadingElm.parentNode !== null) {\n              loadingElm.parentNode.removeChild(loadingElm);\n              clearTimeout(timeout2);\n            }\n          }, newLoadingSettings.cssAnimationDuration);\n          clearTimeout(timeout);\n        }, delay);\n      }\n    }\n\n    // extend new settings with the backup settings\n    newLoadingSettings = commonExtendOptions(true, newLoadingSettings, newLoadingSettingsBackup);\n  };\n  // LOADING: Create: end\n\n  // LOADING: Change Message: begin\n  var loadingChangeMessage = function (newMessage) {\n    // check the new message\n    if (typeof newMessage !== 'string') {\n      newMessage = '';\n    }\n    // if has any loading\n    var messageWrap = window.document.getElementById(loadingSettings.ID);\n    if (messageWrap) {\n      // if there is a new message\n      if (newMessage.length > 0) {\n        // max length: begin\n        if (newMessage.length > newLoadingSettings.messageMaxLength) {\n          newMessage = commonGetPlaintext(newMessage).substring(0, newLoadingSettings.messageMaxLength) + '...';\n        } else {\n          newMessage = commonGetPlaintext(newMessage);\n        }\n        // max length: end\n\n        // there is a message element\n        var oldMessageElm = messageWrap.getElementsByTagName('p')[0];\n        if (oldMessageElm) {\n          oldMessageElm.innerHTML = newMessage; // change the message\n        }\n        // there is no message element\n        else {\n          // create a new message element: begin\n          var newMessageHTML = window.document.createElement('p');\n          newMessageHTML.id = newLoadingSettings.messageID;\n          newMessageHTML.className = 'nx-loading-message nx-loading-message-new';\n          newMessageHTML.style.color = newLoadingSettings.messageColor;\n          newMessageHTML.style.fontSize = newLoadingSettings.messageFontSize;\n          newMessageHTML.innerHTML = newMessage;\n          messageWrap.appendChild(newMessageHTML);\n          // create a new message element: end\n        }\n      }\n      // if no message\n      else {\n        commonConsoleError('Where is the new message?');\n      }\n    }\n  };\n  // LOADING: Change Message: end\n\n  var Notiflix = {\n    Loading: {\n      // Init\n      init: function (userLoadingOptions) {\n        // extend options\n        newLoadingSettings = commonExtendOptions(true, loadingSettings, userLoadingOptions);\n        // internal css if exist\n        commonSetInternalCSSCodes(loadingGetInternalCSSCodes, 'NotiflixLoadingInternalCSS');\n      },\n      // Merge First Init\n      merge: function (userLoadingExtendOptions) {\n        // if initialized already\n        if (newLoadingSettings) {\n          newLoadingSettings = commonExtendOptions(true, newLoadingSettings, userLoadingExtendOptions);\n        }\n        // initialize first\n        else {\n          commonConsoleError('You have to initialize the Loading module before call Merge function.');\n          return false;\n        }\n      },\n      // Standard\n      standard: function (messageOrOptions, options) {\n        loadingCreate(typesLoading.Standard, messageOrOptions, options, true, 0); // true => show && 0 => delay\n      },\n      // Hourglass\n      hourglass: function (messageOrOptions, options) {\n        loadingCreate(typesLoading.Hourglass, messageOrOptions, options, true, 0); // true => show && 0 => delay\n      },\n      // Circle\n      circle: function (messageOrOptions, options) {\n        loadingCreate(typesLoading.Circle, messageOrOptions, options, true, 0); // true => show && 0 => delay\n      },\n      // Arrows\n      arrows: function (messageOrOptions, options) {\n        loadingCreate(typesLoading.Arrows, messageOrOptions, options, true, 0); // true => show && 0 => delay\n      },\n      // Dots\n      dots: function (messageOrOptions, options) {\n        loadingCreate(typesLoading.Dots, messageOrOptions, options, true, 0); // true => show && 0 => delay\n      },\n      // Pulse\n      pulse: function (messageOrOptions, options) {\n        loadingCreate(typesLoading.Pulse, messageOrOptions, options, true, 0); // true => show && 0 => delay\n      },\n      // Custom\n      custom: function (messageOrOptions, options) {\n        loadingCreate(typesLoading.Custom, messageOrOptions, options, true, 0); // true => show && 0 => delay\n      },\n      // Notiflix\n      notiflix: function (messageOrOptions, options) {\n        loadingCreate(typesLoading.Notiflix, messageOrOptions, options, true, 0); // true => show && 0 => delay\n      },\n      // Remove\n      remove: function (delay) {\n        if (typeof delay !== 'number') { delay = 0; }\n        loadingCreate(null, null, null, false, delay); // false => hide/remove\n      },\n      // Change The Message\n      change: function (newMessage) {\n        loadingChangeMessage(newMessage);\n      },\n    },\n  };\n\n  if (typeof window.Notiflix === 'object') {\n    return commonExtendOptions(true, window.Notiflix, { Loading: Notiflix.Loading });\n  } else {\n    return { Loading: Notiflix.Loading };\n  }\n\n});"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$c519d076f6352209$export$4ab48b83441cb96c","$758Z4","$cxvFw","$b7ONl","$6JpON","hero","document","querySelector","backDropRef","trailerRef","trailerBtn","heroBtn","heroImgRef","$c519d076f6352209$var$getTopMoviesArr","numberOfMovies","data","getTrending","moviesArr","results","$c519d076f6352209$var$createRandomMoviesArr","randomMoviesArr","i","randomIndex","Math","floor","random","length","push","splice","error","Notify","warning","$c519d076f6352209$var$heroHandler","location","href","includes","classList","add","style","display","movieArr","renderHeroSlider","addEventListener","onWatchTrailer","$0a22c6e20035bdaf$export$858f609fb9acf511","$0a22c6e20035bdaf$export$dfd6410bdb174d21","$e6cIt","$gVa74","a","__esModule","default","direction","loop","speed","parallax","spaceBetween","autoplay","delay","disableOnInteraction","markup","heroRefs","innerHTML","support","deviceCached","browser","isObject$1","obj","constructor","extend$1","target","src","keys","forEach","key","ssrDocument","body","removeEventListener","activeElement","blur","nodeName","querySelectorAll","getElementById","createEvent","initEvent","createElement","children","childNodes","setAttribute","getElementsByTagName","createElementNS","importNode","hash","host","hostname","origin","pathname","protocol","search","getDocument","doc","ssrWindow","navigator","userAgent","history","replaceState","pushState","go","back","CustomEvent","getComputedStyle","getPropertyValue","Image","Date","screen","setTimeout","clearTimeout","matchMedia","requestAnimationFrame","callback","cancelAnimationFrame","getWindow","win","nextTick","now","getTranslate","el","axis","matrix","curTransform","transformMatrix","window1","curStyle","getComputedStyle$1","currentStyle","WebKitCSSMatrix","transform","webkitTransform","split","map","replace","join","MozTransform","OTransform","MsTransform","msTransform","toString","m41","parseFloat","m42","isObject","o","prototype","slice","extend","to","arguments","undefined","noExtend","nextSource","HTMLElement","node","nodeType","keysArray","filter","indexOf","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","__swiper__","setCSSProperty","varName","varValue","setProperty","animateCSSModeScroll","_ref","time","swiper","targetPosition","side","startPosition","translate","startTime","duration","params","wrapperEl","scrollSnapType","cssModeFrameID","dir","isOutOfBound","current","animate","getTime","progress","max","min","currentPosition","easeProgress","cos","PI","scrollTo","overflow","getSlideTransformEl","slideEl","shadowRoot","elementChildren","element","selector","matches","tag","classes","Array","isArray","elementOffset","document1","box","getBoundingClientRect","clientTop","clientLeft","scrollTop","scrollY","scrollLeft","scrollX","top","left","elementStyle","prop","elementIndex","child","previousSibling","elementParents","parents","parent","parentElement","elementTransitionEnd","fireCallBack","elementOuterSize","size","includeMargins","offsetWidth","getSupport","calcSupport","smoothScroll","documentElement","touch","DocumentTouch","processLazyPreloader","imageEl","destroyed","closest","isElement","slideClass","lazyEl","lazyPreloaderClass","remove","unlazy","index","slides","removeAttribute","preload","amount","lazyPreloadPrevNext","slidesPerView","slidesPerViewDynamic","ceil","activeIndex","grid","rows","preloadColumns","activeColumn","from","_","column","slideIndexLastInView","rewind","realIndex","transitionEmit","runCallbacks","step","previousIndex","emit","onTouchStart","event1","touchEventsData","evCache","touches","enabled","simulateTouch","pointerType","animating","preventInteractionOnTransition","cssMode","loopFix","originalEvent","targetEl","touchEventsTarget","contains","which","button","isTouched","isMoved","swipingClassHasValue","noSwipingClass","eventPath","composedPath","path","noSwipingSelector","isTargetShadow","noSwiping","closestElement","base","__closestFrom","assignedSlot","found","getRootNode","allowClick","swipeHandler","currentX","pageX","currentY","pageY","startX","startY","edgeSwipeDetection","iOSEdgeSwipeDetection","edgeSwipeThreshold","iOSEdgeSwipeThreshold","innerWidth","preventDefault","assign","allowTouchCallbacks","isScrolling","startMoving","touchStartTime","updateSize","swipeDirection","threshold","allowThresholdMove","focusableElements","shouldPreventDefault","allowTouchMove","touchStartPreventDefault","touchStartForcePreventDefault","isContentEditable","freeMode","onTouchMove","loopFixed","rtlTranslate","rtl","pointerIndex","findIndex","cachedEv","pointerId","targetTouch","preventedByNestedSwiper","prevX","prevY","touchReleaseOnEdges","isVertical","maxTranslate","minTranslate","targetTouches","diffX","diffY","sqrt","touchAngle","isHorizontal","atan2","abs","zoom","cancelable","touchMoveStopPropagation","nested","stopPropagation","diff","touchesDiff","previousX","previousY","oneWayMovement","touchRatio","prevTouchesDirection","touchesDirection","isLoop","startTranslate","setTransition","evt","bubbles","dispatchEvent","allowMomentumBounce","grabCursor","allowSlideNext","allowSlidePrev","setGrabCursor","setTranslate","currentTranslate","disableParentSwiper","resistanceRatio","centeredSlides","activeSlideIndex","resistance","followFinger","watchSlidesProgress","updateActiveIndex","updateSlidesClasses","updateProgress","onTouchEnd","currentPos","type","proceed","isSafari","isWebView","slidesGrid","touchEndTime","timeDiff","pathTree","updateClickedSlide","lastClickTime","stopIndex","groupSize","slidesSizesGrid","slidesPerGroupSkip","slidesPerGroup","increment","rewindFirstIndex","rewindLastIndex","isBeginning","virtual","isEnd","ratio","longSwipesMs","longSwipes","slideTo","longSwipesRatio","shortSwipes","isNavButtonTarget","navigation","nextEl","prevEl","onResize","breakpoints","setBreakpoint","snapGrid","isVirtual","updateSlides","isVirtualLoop","slideToLoop","running","paused","resizeTimeout","resume","watchOverflow","checkOverflow","onClick","preventClicks","preventClicksPropagation","stopImmediatePropagation","onScroll","previousTranslate","translatesDiff","onLoad","autoHeight","update","dummyEventAttached","dummyEventListener","events","method","device","capture","domMethod","passive","updateOnWindowResize","ios","android","isGridEnabled","defaults","initialSlide","resizeObserver","createElements","width","height","url","setWrapperSize","virtualTranslate","effect","breakpointsBase","slidesPerGroupAuto","centeredSlidesBounds","slidesOffsetBefore","slidesOffsetAfter","normalizeSlideIndex","centerInsufficientSlides","roundLengths","uniqueNavElements","slideToClickedSlide","loopedSlides","loopPreventsSliding","passiveListeners","maxBackfaceHiddenSlides","containerModifierClass","slideActiveClass","slideVisibleClass","slideNextClass","slidePrevClass","wrapperClass","runCallbacksOnInit","_emitClasses","prototypes","eventsEmitter","on","handler","priority","eventsListeners","once","onceHandler","off","__emitterProxy","_len","args","_key","apply","onAny","eventsAnyListeners","offAny","eventHandler","context","_len2","_key2","unshift","eventsArray","clientWidth","clientHeight","parseInt","Number","isNaN","slideSize","getDirectionLabel","property","getDirectionPropertyValue","label","slidesEl","swiperSize","wrongRTL","previousSlidesLength","slidesLength","offsetBefore","offsetAfter","previousSnapGridLength","previousSlidesGridLength","slidePosition","prevSlideSize","virtualSize","marginLeft","marginRight","marginBottom","marginTop","gridEnabled","initSlides","shouldResetSlideSize","slide","updateSlide","slideStyles","currentTransform","currentWebKitTransform","paddingLeft","paddingRight","boxSizing","swiperSlideSize","updateWrapperSize","newSlidesGrid","slidesGridItem","groups","slidesBefore","slidesAfter","slideIndex","allSlidesSize","slideSizeValue","maxSnap","snap","allSlidesOffset","snapIndex","addToSnapGrid","addToSlidesGrid","updateSlidesOffset","backFaceHiddenClass","hasClassBackfaceClassAdded","updateAutoHeight","activeSlides","newHeight","getSlideByIndex","getSlideIndexByData","visibleSlides","offsetHeight","minusOffset","offsetLeft","offsetTop","swiperSlideOffset","cssOverflowAdjustment","updateSlidesProgress","offsetCenter","visibleSlidesIndexes","slideOffset","slideProgress","originalSlideProgress","slideBefore","slideAfter","isVisible","originalProgress","multiplier","progressLoop","wasBeginning","wasEnd","isBeginningRounded","isEndRounded","firstSlideIndex","lastSlideIndex","firstSlideTranslate","lastSlideTranslate","translateMax","translateAbs","activeSlide","getFilteredSlide","nextSlide","elementNextAll","nextEls","nextElementSibling","next","prevSlide","elementPrevAll","prevEls","previousElementSibling","prev","emitSlidesClasses","newActiveIndex","previousRealIndex","previousSnapIndex","getVirtualRealIndex","aIndex","getActiveIndexByTranslate","skip","getAttribute","initialized","slideFound","clickedSlide","clickedIndex","byController","x","y","translateTo","translateBounds","internal","newTranslate","isH","behavior","onTranslateToWrapperTransitionEnd","transition","transitionDuration","transitionStart","transitionEnd","initial","normalizedTranslate","normalizedGrid","normalizedGridNext","t","_immediateVirtual","_cssModeVirtualInitialSet","onSlideToWrapperTransitionEnd","indexAsNumber","newIndex","slideNext","perGroup","_clientLeft","slidePrev","normalize","val","normalizedSnapGrid","prevSnap","prevSnapIndex","prevIndex","lastIndex","slideReset","slideToClosest","currentSnap","nextSnap","slideToIndex","slideSelector","getSlideIndex","loopCreate","slideRealIndex","_temp","byMousewheel","prependSlidesIndexes","appendSlidesIndexes","isNext","isPrev","slidesPrepended","slidesAppended","swiperLoopMoveDOM","prepend","append","recalcSlides","currentSlideTranslate","newSlideTranslate","controller","control","loopParams","c","loopDestroy","newSlidesOrder","swiperSlideIndex","moving","isLocked","__preventObserver__","cursor","unsetGrabCursor","attachEvents","bind","detachEvents","breakpoint","getBreakpoint","currentBreakpoint","breakpointOnlyParams","breakpointParams","originalParams","wasMultiRow","isMultiRow","wasEnabled","emitContainerClasses","fill","wasModuleEnabled","isModuleEnabled","disable","enable","directionChanged","needsReLoop","changeDirection","isEnabled","containerEl","currentHeight","innerHeight","points","point","minRatio","substr","value","sort","b","wasLocked","lastSlideRightEdge","addClasses","classNames","suffixes","prepareClasses","entries","prefix","resultClasses","item","removeClasses","extendedDefaults","Swiper","overrides","swipers","newParams","calcDevice","platform","ua","screenWidth","screenHeight","match","ipad","ipod","iphone","macos","iPadScreens","os","calcBrowser","needPerspectiveFix","toLowerCase","String","major","minor","num","test","modules","__modules__","allModulesParams","mod","extendParams","moduleParamName","moduleParams","auto","swiperParams","passedParams","eventName","velocity","trunc","clickTimeout","velocities","imagesToLoad","imagesLoaded","setProgress","cls","className","getSlideClasses","updates","view","exact","spv","breakLoop","slideInView","translated","translateValue","complete","newDirection","needUpdate","currentDirection","changeLanguageDirection","mount","mounted","parentNode","getWrapperSelector","trim","getWrapper","res","slideSlots","hostEl","destroy","deleteInstance","cleanStyles","deleteProps","object","extendDefaults","newDefaults","installModule","use","m","createElementIfNotDefined","checkProps","classesToSelector","appendSlide","appendElement","tempDOM","observer","prependSlide","prependElement","addSlide","activeIndexBuffer","baseLength","slidesBuffer","currentSlide","removeSlide","slidesIndexes","indexToRemove","removeAllSlides","effectInit","requireUpdateOnVirtual","overwriteParams","perspective","recreateShadows","getEffectParams","overwriteParamsResult","_s","slideShadows","shadowEl","effectTarget","effectParams","transformEl","backfaceVisibility","effectVirtualTransitionEnd","transformElements","allSlides","getSlide","eventTriggered","transitionEndTarget","createShadow","suffix","shadowClass","shadowContainer","prototypeGroup","protoMethod","animationFrame","resizeHandler","createObserver","ResizeObserver","newWidth","_ref2","contentBoxSize","contentRect","inlineSize","blockSize","observe","removeObserver","unobserve","orientationChangeHandler","observers","attach","options","ObserverFunc","MutationObserver","WebkitMutationObserver","mutations","observerUpdate","attributes","childList","characterData","observeParents","observeSlideChildren","containerParents","disconnect","cssModeTimeout","cache","renderSlide","renderExternal","renderExternalUpdate","addSlidesBefore","addSlidesAfter","offset","force","offsetProp","previousFrom","previousTo","previousSlidesGrid","previousOffset","onRendered","slidesToRender","prependIndexes","appendIndexes","loopFrom","loopTo","domSlidesAssigned","numberOfNewSlides","newCache","cachedIndex","cachedEl","cachedElIndex","handle","kc","keyCode","charCode","pageUpDown","keyboard","isPageUp","isPageDown","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","shiftKey","altKey","ctrlKey","metaKey","onlyInViewport","inView","swiperWidth","swiperHeight","windowWidth","windowHeight","swiperOffset","swiperCoord","returnValue","timeout","lastEventBeforeSnap","mousewheel","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","noMousewheelClass","lastScrollTime","recentWheelEvents","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","delta","raw","sX","sY","pX","pY","targetElContainsTarget","rtlFactor","detail","wheelDelta","wheelDeltaY","wheelDeltaX","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","positions","sign","ignoreWheelEvents","position","sticky","shift","prevEvent","firstEvent","snapToThreshold","autoplayDisableOnInteraction","stop","releaseScroll","event","hideOnClick","disabledClass","hiddenClass","lockClass","navigationDisabledClass","makeElementsArray","getEl","toggleEl","disabled","subEl","tagName","onPrevClick","onNextClick","initButton","destroyButton","isHidden","pagination","clickable","toggle","bulletSize","pfx","bulletElement","renderBullet","renderProgressbar","renderFraction","renderCustom","progressbarOpposite","dynamicBullets","dynamicMainBullets","formatFractionCurrent","number","formatFractionTotal","bulletClass","bulletActiveClass","modifierClass","currentClass","totalClass","progressbarFillClass","progressbarOppositeClass","clickableClass","horizontalClass","verticalClass","paginationDisabledClass","bullets","dynamicBulletIndex","isPaginationDisabled","setSideBullets","bulletEl","onBulletClick","newSlideIndex","currentSlideIndex","total","firstIndex","midIndex","classesToRemove","flat","bullet","bulletIndex","firstDisplayedBullet","lastDisplayedBullet","dynamicBulletsLength","bulletsOffset","subElIndex","fractionEl","textContent","totalEl","progressbarDirection","scale","scaleX","scaleY","progressEl","render","paginationHTML","numberOfBullets","dragStartPos","dragSize","trackSize","divider","dragTimeout","scrollbar","dragEl","newSize","newPos","hide","opacity","getPointerPosition","clientX","clientY","setDragPosition","positionRatio","onDragStart","onDragMove","onDragEnd","snapOnRelease","activeListener","passiveListener","eventMethod","swiperEl","dragClass","draggable","scrollbarDisabledClass","setTransform","p","rotate","parallaxEl","parallaxDuration","_swiper","fakeGestureTouched","fakeGestureMoved","maxRatio","containerClass","zoomedSlideClass","currentScale","isScaling","gesture","originX","originY","slideWidth","slideHeight","imageWrapEl","image","minX","minY","maxX","maxY","touchesStart","touchesCurrent","prevPositionX","prevPositionY","prevTime","getDistanceBetweenTouches","x1","y1","x2","y2","eventWithinSlide","onGestureStart","scaleStart","getScaleOrigin","onGestureChange","scaleMove","onGestureEnd","eventWithinZoomContainer","scaledWidth","scaledHeight","scaleRatio","onTransitionEnd","zoomIn","touchX","touchY","offsetX","offsetY","translateX","translateY","imageWidth","imageHeight","translateMinX","translateMinY","translateMaxX","translateMaxY","touchAction","forceZoomRatio","zoomOut","zoomToggle","getListeners","activeListenerWithCapture","momentumDurationX","momentumDurationY","momentumDistanceX","newPositionX","momentumDistanceY","newPositionY","momentumDuration","in","out","LinearSpline","i1","i3","maxIndex","minIndex","guess","binarySearch","array","interpolate","removeSpline","spline","inverse","by","controlElement","onControllerSwiper","_t","controlledTranslate","controlled","setControlledTranslate","isFinite","setControlledTransition","a11y","notificationClass","prevSlideMessage","nextSlideMessage","firstSlideMessage","lastSlideMessage","paginationBulletMessage","slideLabelMessage","containerMessage","containerRoleDescriptionMessage","itemRoleDescriptionMessage","slideRole","clicked","liveRegion","notify","message","notification","makeElFocusable","makeElNotFocusable","addElRole","role","addElRoleDescription","description","addElLabel","disableEl","enableEl","onEnterOrSpaceKey","click","hasPagination","hasClickablePagination","initNavEl","wrapperId","addElControls","controls","handlePointerDown","handlePointerUp","handleFocus","isActive","sourceCapabilities","firesTouchEvents","ariaLabelMessage","repeat","round","live","addElId","addElLive","paginationEl","updateNavigation","updatePagination","root","keepQuery","paths","slugify","text","getPathValues","urlOverride","URL","pathArray","part","setHistory","currentState","state","scrollToSlide","slideHistory","setHistoryPopState","hashNavigation","watchState","slideWithHash","onHashChange","newHash","activeSlideEl","activeSlideHash","setHash","raf","autoplayTimeLeft","wasPaused","pausedByTouch","touchStartTimeout","slideChanged","pausedByInteraction","timeLeft","waitForTransition","stopOnLastSlide","reverseDirection","pauseOnMouseEnter","autoplayDelayTotal","autoplayDelayCurrent","autoplayStartTime","calcTimeLeft","getSlideDelay","currentSlideDelay","run","delayForce","start","pause","reset","onVisibilityChange","visibilityState","onPointerEnter","onPointerLeave","attachMouseEvents","detachMouseEvents","attachDocumentEvents","detachDocumentEvents","thumbs","multipleActiveThumbs","autoScrollOffset","slideThumbActiveClass","thumbsContainerClass","swiperCreated","onThumbClick","thumbsSwiper","thumbsParams","SwiperClass","thumbsSwiperParams","thumbsToActivate","thumbActiveClass","useOffset","newThumbsIndex","currentThumbsIndex","newThumbsSlide","getThumbsElementAndInit","thumbsElement","onThumbsSwiper","watchForThumbsToAppear","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","minimumVelocity","afterBouncePosition","needsLoopFix","lastMoveEvent","pop","velocityEvent","distance","momentumDistance","newPosition","doBounce","bounceAmount","j","moveDistance","currentSlideSize","slidesNumberEvenToRows","slidesPerRow","numFullColumns","getSpaceBetween","newSlideOrderIndex","row","groupIndex","slideIndexInGroup","columnsInGroup","order","fadeEffect","crossFade","tx","ty","slideOpacity","cubeEffect","shadow","shadowOffset","shadowScale","createSlideShadows","shadowBefore","shadowAfter","cubeShadowEl","wrapperRotate","slideAngle","tz","transformOrigin","shadowAngle","scale1","scale2","sin","zFactor","flipEffect","limitRotation","rotateY","rotateX","zIndex","coverflowEffect","stretch","depth","modifier","center","centerOffset","offsetMultiplier","translateZ","slideTransform","shadowBeforeEl","shadowAfterEl","creativeEffect","limitProgress","shadowPerProgress","progressMultiplier","getTranslateValue","isCenteredSlides","margin","r","custom","translateString","rotateString","scaleString","opacityString","shadowOpacity","cardsEffect","perSlideRotate","perSlideOffset","tX","tY","tZ","tXAdd","isSwipeToNext","isSwipeToPrev","subProgress","$527ff81843881d46$export$f841641769cf6254","$RX4Re","arr","renderSwiper","backdrop_path","title","overview","vote_average","name","swiperInit","$921121d4eacbf085$export$8b0b07c04ee595a3","$921121d4eacbf085$var$trailerRefs","erMod","erBtn","trailerImg","dataId","dataset","$921121d4eacbf085$export$a408a7ab7d56d7a7","movieData","getMovie","trailerKey","$921121d4eacbf085$var$listenBackdropClick","$921121d4eacbf085$var$listenKeyDawn","$921121d4eacbf085$var$onBackdropClick","$921121d4eacbf085$var$clsModal","$921121d4eacbf085$var$keyBoardPress","$921121d4eacbf085$var$closeTrailer","currentTarget","$921121d4eacbf085$var$removeEventErr","$8197bff4c39d585a$export$998f00da2813713d","$8197bff4c39d585a$export$bdba5afeee6501b","$dIxxU","$kvC6y","$8197bff4c39d585a$var$BASE_URL","$8197bff4c39d585a$var$API_KEY","$8197bff4c39d585a$var$fetchData","onLoader","response","removeLoader","page","movie_id","$03da642c15b09e5e$export$bb9bc927e7d77389","$03da642c15b09e5e$export$5303cf8b8f096deb","$7rQOT","Loading","dots","svgColor","svgSize","messageFontSize","clickToClose","factory","newLoadingSettings","typesLoading","Standard","Hourglass","Circle","Arrows","Dots","Pulse","Custom","Notiflix","loadingSettings","ID","zindex","backgroundColor","fontFamily","cssAnimation","cssAnimationDuration","customSvgUrl","customSvgCode","messageID","messageMaxLength","messageColor","commonConsoleError","console","commonCheckHeadOrBody","commonSetInternalCSSCodes","getInternalCSSCodes","styleElementId","internalCSS","head","appendChild","commonExtendOptions","extended","deep","merge","hasOwnProperty","commonGetPlaintext","html","htmlPool","innerText","loadingGetInternalCSSCodes","loadingCreate","loadingType","messageOrOptions","newLoadingSettingsBackup","newOptions","substring","color","green","messageHTML","svgIcon","svgSizeAsDigit","winWidth","maxSvgWidthPx","svgIconHTML","ntflxLoadingWrap","background","animationDuration","flexWrap","flexDirection","alignItems","justifyContent","loadingWrapElm","removeChild","loadingElm","timeout2","loadingChangeMessage","newMessage","messageWrap","oldMessageElm","newMessageHTML","fontSize","userLoadingOptions","userLoadingExtendOptions","standard","hourglass","circle","arrows","pulse","notiflix","change","define","amd"],"version":3,"file":"catalog.b216e0c8.js.map"}